--
-- PostgreSQL database dump
--

\restrict 0a1ZAxETmGuIa7r6N7gOITP2Ti2BvDDMcNhsSaQAGZupOMJWqwkoPj14DpmYJKQ

-- Dumped from database version 14.18 (Ubuntu 14.18-0ubuntu0.22.04.1)
-- Dumped by pg_dump version 17.6 (Ubuntu 17.6-1.pgdg24.04+1)

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET transaction_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

ALTER TABLE IF EXISTS ONLY public.whatsapptemplate DROP CONSTRAINT IF EXISTS whatsapptemplate_companyid_fkey;
ALTER TABLE IF EXISTS ONLY public.userauth DROP CONSTRAINT IF EXISTS userauth_companyid_fkey;
ALTER TABLE IF EXISTS ONLY public.callsubmission DROP CONSTRAINT IF EXISTS status_substatus_fkey;
ALTER TABLE IF EXISTS ONLY public.rlookup DROP CONSTRAINT IF EXISTS sidrlookup_idlookup;
ALTER TABLE IF EXISTS ONLY public.statuslog DROP CONSTRAINT IF EXISTS restidstatuslog_restidrestparams;
ALTER TABLE IF EXISTS ONLY public.pointlog DROP CONSTRAINT IF EXISTS restidpointlog_restidrestparams;
ALTER TABLE IF EXISTS ONLY public.relatedproduct DROP CONSTRAINT IF EXISTS relatedproduct_relatedproductid_fkey;
ALTER TABLE IF EXISTS ONLY public.relatedproduct DROP CONSTRAINT IF EXISTS relatedproduct_productid_fkey;
ALTER TABLE IF EXISTS ONLY public.questionattributes DROP CONSTRAINT IF EXISTS questionattributes_productquestionid_fkey;
ALTER TABLE IF EXISTS ONLY public.questionattributes DROP CONSTRAINT IF EXISTS questionattributes_attributeid_fkey;
ALTER TABLE IF EXISTS ONLY public.promocodechannel DROP CONSTRAINT IF EXISTS promocodechannal_promocodeid_fkey;
ALTER TABLE IF EXISTS ONLY public.promocodecategory DROP CONSTRAINT IF EXISTS promocodecategory_promocodeid_fkey;
ALTER TABLE IF EXISTS ONLY public.promocodecategory DROP CONSTRAINT IF EXISTS promocodecategory_categoryid_fkey;
ALTER TABLE IF EXISTS ONLY public.promocodebranch DROP CONSTRAINT IF EXISTS promocodebranch_promocodeid_fkey;
ALTER TABLE IF EXISTS ONLY public.promocodebranch DROP CONSTRAINT IF EXISTS promocodebranch_branchid_fkey;
ALTER TABLE IF EXISTS ONLY public.promocode DROP CONSTRAINT IF EXISTS promocode_companyid_fk;
ALTER TABLE IF EXISTS ONLY public.productselectedattribute DROP CONSTRAINT IF EXISTS productselectedattribute_product_fkey;
ALTER TABLE IF EXISTS ONLY public.productquestions DROP CONSTRAINT IF EXISTS productquestions_questionid_fkey;
ALTER TABLE IF EXISTS ONLY public.productquestions DROP CONSTRAINT IF EXISTS productquestions_productid_fkey;
ALTER TABLE IF EXISTS ONLY public.productattribute DROP CONSTRAINT IF EXISTS productattribute_productid_fkey;
ALTER TABLE IF EXISTS ONLY public.promocodecustomers DROP CONSTRAINT IF EXISTS procutom_promocode_fkey;
ALTER TABLE IF EXISTS ONLY public.branchtemplate DROP CONSTRAINT IF EXISTS printers_fk_branchid;
ALTER TABLE IF EXISTS ONLY public.posintegration DROP CONSTRAINT IF EXISTS posintegration_companyid_fkey;
ALTER TABLE IF EXISTS ONLY public.generalcomplain DROP CONSTRAINT IF EXISTS orderstatuspossibilitiesid_fkey;
ALTER TABLE IF EXISTS ONLY public.orderstatuspossibilities DROP CONSTRAINT IF EXISTS orderstatus_branchid_fkey;
ALTER TABLE IF EXISTS ONLY public.orderproduct DROP CONSTRAINT IF EXISTS orderproduct_productid_fkey;
ALTER TABLE IF EXISTS ONLY public.orderproduct_2025 DROP CONSTRAINT IF EXISTS orderproduct_2025_productid_fkey;
ALTER TABLE IF EXISTS ONLY public.ordernotificationsettings DROP CONSTRAINT IF EXISTS ordernotificationsettings_branchid_fkey;
ALTER TABLE IF EXISTS ONLY public.menuintegratiosync DROP CONSTRAINT IF EXISTS menuid_fk_menu;
ALTER TABLE IF EXISTS ONLY public.menucategories DROP CONSTRAINT IF EXISTS menucategories_menu;
ALTER TABLE IF EXISTS ONLY public.linkeradditionalattributes DROP CONSTRAINT IF EXISTS linkeradditionalattributes_questionattributeid_fkey;
ALTER TABLE IF EXISTS ONLY public.linkeradditionalattributes DROP CONSTRAINT IF EXISTS linkeradditionalattributes_connecterid_fkey;
ALTER TABLE IF EXISTS ONLY public.offerimage DROP CONSTRAINT IF EXISTS fki_fk_offerimage_company;
ALTER TABLE IF EXISTS ONLY public.customeraddress DROP CONSTRAINT IF EXISTS fkcustomeraddress_customer;
ALTER TABLE IF EXISTS ONLY public.tax DROP CONSTRAINT IF EXISTS fk_taxcategoryid_taxcategoryid;
ALTER TABLE IF EXISTS ONLY public.taxcategory DROP CONSTRAINT IF EXISTS fk_taxcategorycompanyid_companyid;
ALTER TABLE IF EXISTS ONLY public.product DROP CONSTRAINT IF EXISTS fk_product_category_categoryid;
ALTER TABLE IF EXISTS ONLY public.orderstatuspossibilities DROP CONSTRAINT IF EXISTS fk_possibilities_companyid;
ALTER TABLE IF EXISTS ONLY public.orderstatuspossibilities DROP CONSTRAINT IF EXISTS fk_ordersettings_next;
ALTER TABLE IF EXISTS ONLY public.orderproductattribute DROP CONSTRAINT IF EXISTS fk_orderproductatribute_orderproductid;
ALTER TABLE IF EXISTS ONLY public.orderproductattribute DROP CONSTRAINT IF EXISTS fk_orderproductatribute_attributeid;
ALTER TABLE IF EXISTS ONLY public.orderproduct DROP CONSTRAINT IF EXISTS fk_orderproduct_orderid;
ALTER TABLE IF EXISTS ONLY public.orderfollowupdetails DROP CONSTRAINT IF EXISTS fk_orderfollowupdetails_orderid;
ALTER TABLE IF EXISTS ONLY public.orderfollowup DROP CONSTRAINT IF EXISTS fk_orderfollowup_orderid;
ALTER TABLE IF EXISTS ONLY public."order" DROP CONSTRAINT IF EXISTS fk_order_branchid;
ALTER TABLE IF EXISTS ONLY public.orderconfig DROP CONSTRAINT IF EXISTS fk_online_company;
ALTER TABLE IF EXISTS ONLY public.notificationfollowup DROP CONSTRAINT IF EXISTS fk_notificationfollowup_notificationid;
ALTER TABLE IF EXISTS ONLY public.namelookup DROP CONSTRAINT IF EXISTS fk_namelookup_referanceid;
ALTER TABLE IF EXISTS ONLY public.menuproduct DROP CONSTRAINT IF EXISTS fk_menuproduct_productid;
ALTER TABLE IF EXISTS ONLY public.menuproduct DROP CONSTRAINT IF EXISTS fk_menuproduct_menuid;
ALTER TABLE IF EXISTS ONLY public.menucategories DROP CONSTRAINT IF EXISTS fk_menucategories_category;
ALTER TABLE IF EXISTS ONLY public.branch DROP CONSTRAINT IF EXISTS fk_menu;
ALTER TABLE IF EXISTS ONLY public.ishbekareas DROP CONSTRAINT IF EXISTS fk_ishbekareas_cityid_ishbekcities_cityid;
ALTER TABLE IF EXISTS ONLY public.posintegration DROP CONSTRAINT IF EXISTS fk_integrationcompanyid;
ALTER TABLE IF EXISTS ONLY public.generalcomplain DROP CONSTRAINT IF EXISTS fk_generalcomplain_branchid;
ALTER TABLE IF EXISTS ONLY public.branchdelivery DROP CONSTRAINT IF EXISTS fk_deliverycompany_branchid;
ALTER TABLE IF EXISTS ONLY public.delayedorders DROP CONSTRAINT IF EXISTS fk_delayedorder_order;
ALTER TABLE IF EXISTS ONLY public.branchorderconfig DROP CONSTRAINT IF EXISTS fk_branchorderconfig_company;
ALTER TABLE IF EXISTS ONLY public.branchorderseq DROP CONSTRAINT IF EXISTS fk_branchid_seq;
ALTER TABLE IF EXISTS ONLY public.branchdeliveryaddress DROP CONSTRAINT IF EXISTS fk_branchdeliveyaddress_branchaddressid;
ALTER TABLE IF EXISTS ONLY public.branchdeliveryaddress DROP CONSTRAINT IF EXISTS fk_branchdeliveryaddress_branchdeliverycompany;
ALTER TABLE IF EXISTS ONLY public.branchdelivery DROP CONSTRAINT IF EXISTS fk_branchdelivery_deliverycompanyid;
ALTER TABLE IF EXISTS ONLY public.branchaddress DROP CONSTRAINT IF EXISTS fk_branchaddress_branchid;
ALTER TABLE IF EXISTS ONLY public.tempaddress DROP CONSTRAINT IF EXISTS fk_addresses_ishbekareaid_ishbekareas_areaid;
ALTER TABLE IF EXISTS ONLY public.addresses DROP CONSTRAINT IF EXISTS fk_addresses_ishbekareaid_ishbekareas_areaid;
ALTER TABLE IF EXISTS ONLY public.tempaddress DROP CONSTRAINT IF EXISTS fk_addresses_cityid_ishbekcities_cityid;
ALTER TABLE IF EXISTS ONLY public.addresses DROP CONSTRAINT IF EXISTS fk_addresses_cityid_ishbekcities_cityid;
ALTER TABLE IF EXISTS ONLY public.discountproduct DROP CONSTRAINT IF EXISTS discountproduct_productid_fkey;
ALTER TABLE IF EXISTS ONLY public.discountproduct DROP CONSTRAINT IF EXISTS discountproduct_discountid_fkey;
ALTER TABLE IF EXISTS ONLY public.discountcustomers DROP CONSTRAINT IF EXISTS discountinfoid;
ALTER TABLE IF EXISTS ONLY public.discountbranch DROP CONSTRAINT IF EXISTS discountbranch_discountid_fkey;
ALTER TABLE IF EXISTS ONLY public.discountbranch DROP CONSTRAINT IF EXISTS discountbranch_branchid_fkey;
ALTER TABLE IF EXISTS ONLY public.discountattribute DROP CONSTRAINT IF EXISTS discountattribute_discountid_fkey;
ALTER TABLE IF EXISTS ONLY public.discountattribute DROP CONSTRAINT IF EXISTS discountattribute_attributeid_fkey;
ALTER TABLE IF EXISTS ONLY public.discountchannel DROP CONSTRAINT IF EXISTS discounchannal_discountid_fkey;
ALTER TABLE IF EXISTS ONLY public.statuslog DROP CONSTRAINT IF EXISTS cridstatuslog_idrescus;
ALTER TABLE IF EXISTS ONLY public.pointlog DROP CONSTRAINT IF EXISTS cridpointlog_idrecus;
ALTER TABLE IF EXISTS ONLY public.companyuser DROP CONSTRAINT IF EXISTS companyuser_companyid;
ALTER TABLE IF EXISTS ONLY public.companyservicechat DROP CONSTRAINT IF EXISTS companyservicechat_companyid_fkey;
ALTER TABLE IF EXISTS ONLY public.companyinfo DROP CONSTRAINT IF EXISTS companyinfo_companyid_fkey;
ALTER TABLE IF EXISTS ONLY public.companyfaq DROP CONSTRAINT IF EXISTS companyfaq_companyid_fkey;
ALTER TABLE IF EXISTS ONLY public.clientintegration DROP CONSTRAINT IF EXISTS clientintegration_intcompanyid_fkey;
ALTER TABLE IF EXISTS ONLY public.chatconversation DROP CONSTRAINT IF EXISTS chatconversation_companyid_fkey;
ALTER TABLE IF EXISTS ONLY public.pointlog DROP CONSTRAINT IF EXISTS channelidpointlog_idchannellookup;
ALTER TABLE IF EXISTS ONLY public.menuintegratiosync DROP CONSTRAINT IF EXISTS channelid_fk_namelookup;
ALTER TABLE IF EXISTS ONLY public.branchavailability DROP CONSTRAINT IF EXISTS branchid_fkey;
ALTER TABLE IF EXISTS ONLY public.branch DROP CONSTRAINT IF EXISTS branch_companyid_fkey;
DROP INDEX IF EXISTS public.taxcategory_updatedatx;
DROP INDEX IF EXISTS public.taxcategory_ispublishedx;
DROP INDEX IF EXISTS public.taxcategory_isdeletedx;
DROP INDEX IF EXISTS public.taxcategory_idx;
DROP INDEX IF EXISTS public.taxcategory_deletedatx;
DROP INDEX IF EXISTS public.taxcategory_createdatx;
DROP INDEX IF EXISTS public.taxcategory_companyidx;
DROP INDEX IF EXISTS public.tax_updatedatx;
DROP INDEX IF EXISTS public.tax_taxcategoryidx;
DROP INDEX IF EXISTS public.tax_ispublishedx;
DROP INDEX IF EXISTS public.tax_isdeletedx;
DROP INDEX IF EXISTS public.tax_idx;
DROP INDEX IF EXISTS public.tax_deletedatx;
DROP INDEX IF EXISTS public.tax_createdatx;
DROP INDEX IF EXISTS public.tax_countryidx;
DROP INDEX IF EXISTS public.tax_cityidx;
DROP INDEX IF EXISTS public.statuslog_restaurantid_idx;
DROP INDEX IF EXISTS public.statuslog_customerid_idx;
DROP INDEX IF EXISTS public.status_idx;
DROP INDEX IF EXISTS public.restaurantcustomer_restaurantid_idx;
DROP INDEX IF EXISTS public.restaurantcustomer_customerid_idx;
DROP INDEX IF EXISTS public.requestlog_requestbody_code_idx;
DROP INDEX IF EXISTS public.requestlog_method_idx;
DROP INDEX IF EXISTS public.relatedproduct_updatedatx;
DROP INDEX IF EXISTS public.relatedproduct_ispublishedx;
DROP INDEX IF EXISTS public.relatedproduct_isdeletedx;
DROP INDEX IF EXISTS public.relatedproduct_idx;
DROP INDEX IF EXISTS public.relatedproduct_deletedatx;
DROP INDEX IF EXISTS public.relatedproduct_createdatx;
DROP INDEX IF EXISTS public.productselectedattribute_updatedatx;
DROP INDEX IF EXISTS public.productselectedattribute_ispublishedx;
DROP INDEX IF EXISTS public.productselectedattribute_isdeletedx;
DROP INDEX IF EXISTS public.productselectedattribute_idx;
DROP INDEX IF EXISTS public.productselectedattribute_deletedatx;
DROP INDEX IF EXISTS public.productselectedattribute_createdatx;
DROP INDEX IF EXISTS public.productimages_updatedatx;
DROP INDEX IF EXISTS public.productimages_ispublishedx;
DROP INDEX IF EXISTS public.productimages_isdeletedx;
DROP INDEX IF EXISTS public.productimages_idx;
DROP INDEX IF EXISTS public.productimages_deletedatx;
DROP INDEX IF EXISTS public.productimages_createdatx;
DROP INDEX IF EXISTS public.productavailability_updatedatx;
DROP INDEX IF EXISTS public.productavailability_ispublishedx;
DROP INDEX IF EXISTS public.productavailability_isdeletedx;
DROP INDEX IF EXISTS public.productavailability_idx;
DROP INDEX IF EXISTS public.productavailability_deletedatx;
DROP INDEX IF EXISTS public.productavailability_createdatx;
DROP INDEX IF EXISTS public.productattribute_productid_idx;
DROP INDEX IF EXISTS public.productattribute_ispublished_idx;
DROP INDEX IF EXISTS public.productattribute_isdeleted_idx;
DROP INDEX IF EXISTS public.productattribute_companyid_isx;
DROP INDEX IF EXISTS public.productattribute_attributeid_idx;
DROP INDEX IF EXISTS public.product_updatedatx;
DROP INDEX IF EXISTS public.product_ispublishedx;
DROP INDEX IF EXISTS public.product_isdeletedx;
DROP INDEX IF EXISTS public.product_idx;
DROP INDEX IF EXISTS public.product_deletedatx;
DROP INDEX IF EXISTS public.product_createdatx;
DROP INDEX IF EXISTS public.pointlog_restaurantid_idx;
DROP INDEX IF EXISTS public.pointlog_customerid_idx;
DROP INDEX IF EXISTS public.pointlog_channelid_idx;
DROP INDEX IF EXISTS public.ordersreport_orderstatusid;
DROP INDEX IF EXISTS public.ordersreport_iscanceled_idx;
DROP INDEX IF EXISTS public.ordersreport_deliveryname;
DROP INDEX IF EXISTS public.ordersreport_deliveryid;
DROP INDEX IF EXISTS public.ordersreport_customerid_idx;
DROP INDEX IF EXISTS public.ordersourceid_orderprice;
DROP INDEX IF EXISTS public.orderproductattribute_orderproductid_isx;
DROP INDEX IF EXISTS public.orderproductattribute_attributeid_idx;
DROP INDEX IF EXISTS public.orderproduct_productid_idx;
DROP INDEX IF EXISTS public.orderproduct_orderid_idx;
DROP INDEX IF EXISTS public.orderid_orderprice;
DROP INDEX IF EXISTS public.orderfollowupdetailsid_idx;
DROP INDEX IF EXISTS public.order_referencenumber_talabat;
DROP INDEX IF EXISTS public.order_referencenumber_careem_idx;
DROP INDEX IF EXISTS public.order_referencenumber2_idx;
DROP INDEX IF EXISTS public.order_ordersource_idx;
DROP INDEX IF EXISTS public.order_ordersource;
DROP INDEX IF EXISTS public.order_customerid_idx;
DROP INDEX IF EXISTS public.object_channelid;
DROP INDEX IF EXISTS public.namelookup_updatedatx;
DROP INDEX IF EXISTS public.namelookup_tabletypex;
DROP INDEX IF EXISTS public.namelookup_ispublishedx;
DROP INDEX IF EXISTS public.namelookup_isdeletedx;
DROP INDEX IF EXISTS public.namelookup_idx;
DROP INDEX IF EXISTS public.namelookup_deletedatx;
DROP INDEX IF EXISTS public.namelookup_createdatx;
DROP INDEX IF EXISTS public.menuqrcode_branchid_idx;
DROP INDEX IF EXISTS public.menuproduct_updatedatx;
DROP INDEX IF EXISTS public.menuproduct_productid_idx;
DROP INDEX IF EXISTS public.menuproduct_menuidx;
DROP INDEX IF EXISTS public.menuproduct_ispublishedx;
DROP INDEX IF EXISTS public.menuproduct_isdeletedx;
DROP INDEX IF EXISTS public.menuproduct_idx;
DROP INDEX IF EXISTS public.menuproduct_deletedatx;
DROP INDEX IF EXISTS public.menuproduct_createdatx;
DROP INDEX IF EXISTS public.menuchannel_menuid_idx;
DROP INDEX IF EXISTS public.menuchannel_channelid_idx;
DROP INDEX IF EXISTS public.menuchannel_branchid_idx;
DROP INDEX IF EXISTS public.menu_updatedatx;
DROP INDEX IF EXISTS public.menu_ispublishedx;
DROP INDEX IF EXISTS public.menu_isdeletedx;
DROP INDEX IF EXISTS public.menu_idx;
DROP INDEX IF EXISTS public.menu_deletedatx;
DROP INDEX IF EXISTS public.menu_createdatx;
DROP INDEX IF EXISTS public.language_updatedatx;
DROP INDEX IF EXISTS public.language_languagecodex;
DROP INDEX IF EXISTS public.language_ispublishedx;
DROP INDEX IF EXISTS public.language_isdeletedx;
DROP INDEX IF EXISTS public.language_idx;
DROP INDEX IF EXISTS public.language_deletedatx;
DROP INDEX IF EXISTS public.language_createdatx;
DROP INDEX IF EXISTS public.idx_talabatbrandid;
DROP INDEX IF EXISTS public.idx_remoteid;
DROP INDEX IF EXISTS public.idx_phonenumber2;
DROP INDEX IF EXISTS public.idx_objectid_channelid;
DROP INDEX IF EXISTS public.idx_objectid_branchid;
DROP INDEX IF EXISTS public.idx_object;
DROP INDEX IF EXISTS public.idx_methodlogtype;
DROP INDEX IF EXISTS public.idx_ishbek_city_id;
DROP INDEX IF EXISTS public.idx_companyphone;
DROP INDEX IF EXISTS public.idx_companyid;
DROP INDEX IF EXISTS public.idx_cityid;
DROP INDEX IF EXISTS public.idx_brandid;
DROP INDEX IF EXISTS public.idx_areaid;
DROP INDEX IF EXISTS public.idx_areacode;
DROP INDEX IF EXISTS public.fki_status_substatus_fkey;
DROP INDEX IF EXISTS public.fki_status_status_fkey;
DROP INDEX IF EXISTS public.fki_orderstatuspossibilitiesid_fkey;
DROP INDEX IF EXISTS public.fki_orderfollowupcustomerid;
DROP INDEX IF EXISTS public.fki_o;
DROP INDEX IF EXISTS public.fki_menucategories_menu;
DROP INDEX IF EXISTS public.fki_m;
DROP INDEX IF EXISTS public.fki_fk_product_category_categoryid;
DROP INDEX IF EXISTS public.fki_fk_ordersettings_next;
DROP INDEX IF EXISTS public.fki_fk_online_company;
DROP INDEX IF EXISTS public.fki_fk_notificationfollowup_notificationid;
DROP INDEX IF EXISTS public.fki_fk_namelookup_referanceid;
DROP INDEX IF EXISTS public.fki_fk_menucategories_category;
DROP INDEX IF EXISTS public.fki_fk_generalcomplain_branchid;
DROP INDEX IF EXISTS public.fki_fk_deliverycompany_branchid;
DROP INDEX IF EXISTS public.fki_fk_branchdeliveyaddress_branchaddressid;
DROP INDEX IF EXISTS public.fki_fk_branchdeliveryaddress_branchdeliverycompany;
DROP INDEX IF EXISTS public.fki_fk_branchdelivery_deliverycompanyid;
DROP INDEX IF EXISTS public.fki_fk_branchaddress_branchid;
DROP INDEX IF EXISTS public.fki_customerid_fkey;
DROP INDEX IF EXISTS public.fki_branchid_fkey;
DROP INDEX IF EXISTS public.discountproduct_productid_isx;
DROP INDEX IF EXISTS public.discountproduct_discountid_isx;
DROP INDEX IF EXISTS public.discountinfo_companyid_isx;
DROP INDEX IF EXISTS public.discountchannel_discountid_idx;
DROP INDEX IF EXISTS public.discountchannel_channelid_idx;
DROP INDEX IF EXISTS public.discountbranch_discountid_idx;
DROP INDEX IF EXISTS public.discountbranch_branchid_idx;
DROP INDEX IF EXISTS public.deliverycompany_ispublishedx;
DROP INDEX IF EXISTS public.deliverycompany_isdeletedx;
DROP INDEX IF EXISTS public.deliverycompany_idx;
DROP INDEX IF EXISTS public.customerid_orderprice;
DROP INDEX IF EXISTS public.customerbillingdetails_customerid_index;
DROP INDEX IF EXISTS public.customeraddress_labeladdressid_idx;
DROP INDEX IF EXISTS public.customeraddress_customerid_idx;
DROP INDEX IF EXISTS public.customeraddress_addressid_idx;
DROP INDEX IF EXISTS public.createdat_idx;
DROP INDEX IF EXISTS public.coupon_updatedatx;
DROP INDEX IF EXISTS public.coupon_ispublishedx;
DROP INDEX IF EXISTS public.coupon_isdeletedx;
DROP INDEX IF EXISTS public.coupon_idx;
DROP INDEX IF EXISTS public.coupon_deletedatx;
DROP INDEX IF EXISTS public.coupon_createdatx;
DROP INDEX IF EXISTS public.companyinfo_updatedatx;
DROP INDEX IF EXISTS public.companyinfo_ispublishedx;
DROP INDEX IF EXISTS public.companyinfo_isdeletedx;
DROP INDEX IF EXISTS public.companyinfo_deletedatx;
DROP INDEX IF EXISTS public.companyinfo_createdatx;
DROP INDEX IF EXISTS public.companyinfo_companyidx;
DROP INDEX IF EXISTS public.company_name_idx;
DROP INDEX IF EXISTS public.company_id_idx;
DROP INDEX IF EXISTS public.category_updatedatx;
DROP INDEX IF EXISTS public.category_ispublishedx;
DROP INDEX IF EXISTS public.category_isdeletedx;
DROP INDEX IF EXISTS public.category_idx;
DROP INDEX IF EXISTS public.category_deletedatx;
DROP INDEX IF EXISTS public.category_createdatx;
DROP INDEX IF EXISTS public.careemlog_id_idx;
DROP INDEX IF EXISTS public.careemlog_eventtype_idx;
DROP INDEX IF EXISTS public.careemlog_eventid_idx;
DROP INDEX IF EXISTS public.careemlog_createdat_indx;
DROP INDEX IF EXISTS public.careemlog_branch_id_idx;
DROP INDEX IF EXISTS public.careemlog_branch_brand_id_idx;
DROP INDEX IF EXISTS public.branchid_orderprice;
DROP INDEX IF EXISTS public.branchid_idx;
DROP INDEX IF EXISTS public.branchdeliverycharge_companyid_idx;
DROP INDEX IF EXISTS public.branchdeliverycharge_branchid_idx;
DROP INDEX IF EXISTS public.branchdelivery_idx;
DROP INDEX IF EXISTS public.branchaddress_idx;
DROP INDEX IF EXISTS public.branch_updatedatx;
DROP INDEX IF EXISTS public.branch_statusx;
DROP INDEX IF EXISTS public.branch_name_idx;
DROP INDEX IF EXISTS public.branch_ispublishedx;
DROP INDEX IF EXISTS public.branch_isdeletedx;
DROP INDEX IF EXISTS public.branch_idx;
DROP INDEX IF EXISTS public.branch_id_idx;
DROP INDEX IF EXISTS public.branch_deletedatx;
DROP INDEX IF EXISTS public.branch_createdatx;
DROP INDEX IF EXISTS public.branch_companyidx;
DROP INDEX IF EXISTS public.branch_addressidx;
DROP INDEX IF EXISTS public.ashyaeeorderlog_id_idx;
DROP INDEX IF EXISTS public.ashyaeeorderlog_eventtype_idx;
DROP INDEX IF EXISTS public.ashyaeeorderlog_eventid_idx;
DROP INDEX IF EXISTS public.ashyaeeorderlog_createdat_indx;
DROP INDEX IF EXISTS public.ashyaeeorderlog_branch_id_idx;
DROP INDEX IF EXISTS public.ashyaeeorderlog_branch_brand_id_idx;
DROP INDEX IF EXISTS public.address_updatedatx;
DROP INDEX IF EXISTS public.address_ispublishedx;
DROP INDEX IF EXISTS public.address_isdeletedx;
DROP INDEX IF EXISTS public.address_idx;
DROP INDEX IF EXISTS public.address_deletedatx;
DROP INDEX IF EXISTS public.address_createdatx;
ALTER TABLE IF EXISTS ONLY public.whatsapptemplate DROP CONSTRAINT IF EXISTS whatsapptemplate_pkey;
ALTER TABLE IF EXISTS ONLY public.waapilogs DROP CONSTRAINT IF EXISTS wappilogs_pkey;
ALTER TABLE IF EXISTS ONLY public.waapiclients DROP CONSTRAINT IF EXISTS waapiclients_pkey;
ALTER TABLE IF EXISTS ONLY public.viewprinter DROP CONSTRAINT IF EXISTS viewprinter_pkey;
ALTER TABLE IF EXISTS ONLY public.viciphonenumber DROP CONSTRAINT IF EXISTS viciphonenumber_pkey;
ALTER TABLE IF EXISTS ONLY public.userauth DROP CONSTRAINT IF EXISTS username_userauth;
ALTER TABLE IF EXISTS ONLY public.userauth DROP CONSTRAINT IF EXISTS userauth_pkey;
ALTER TABLE IF EXISTS ONLY public.ashyaeemappedentities DROP CONSTRAINT IF EXISTS unique_ishbek_ashyaee;
ALTER TABLE IF EXISTS ONLY public.companysubarea DROP CONSTRAINT IF EXISTS unique_company_subarea;
ALTER TABLE IF EXISTS ONLY public.menuchannel DROP CONSTRAINT IF EXISTS unique_channel_branch;
ALTER TABLE IF EXISTS ONLY public.branchsubareafees DROP CONSTRAINT IF EXISTS unique_branch_subarea_fees;
ALTER TABLE IF EXISTS ONLY public.ishbekareas DROP CONSTRAINT IF EXISTS unique_areaid;
ALTER TABLE IF EXISTS ONLY public.transferbranch DROP CONSTRAINT IF EXISTS transferbranche_pkey;
ALTER TABLE IF EXISTS ONLY public.transaction DROP CONSTRAINT IF EXISTS transaction_pkey;
ALTER TABLE IF EXISTS ONLY public.taxcategory DROP CONSTRAINT IF EXISTS "taxCategory_pkey";
ALTER TABLE IF EXISTS ONLY public.talabatprerequestlog DROP CONSTRAINT IF EXISTS talabatprerequestlog_pkey;
ALTER TABLE IF EXISTS ONLY public.talabatmenu DROP CONSTRAINT IF EXISTS talabatmenu_pkey;
ALTER TABLE IF EXISTS ONLY public.restaurantpaymentcredentials DROP CONSTRAINT IF EXISTS restaurantpaymentcredentials_pkey;
ALTER TABLE IF EXISTS ONLY public.restaurantparams DROP CONSTRAINT IF EXISTS restaurantparams_pkey;
ALTER TABLE IF EXISTS ONLY public.restaurantcustomer DROP CONSTRAINT IF EXISTS restaurantcustomer_pkey;
ALTER TABLE IF EXISTS ONLY public.restaurantcustomer DROP CONSTRAINT IF EXISTS restaurantcustomer_customerid_restaurantid_key;
ALTER TABLE IF EXISTS ONLY public.companywaapiservicechat DROP CONSTRAINT IF EXISTS restaurantchatservices_pkey;
ALTER TABLE IF EXISTS ONLY public.requestlog DROP CONSTRAINT IF EXISTS requestlog_pkey;
ALTER TABLE IF EXISTS ONLY public.relatedproduct DROP CONSTRAINT IF EXISTS relatedproduct_pkey;
ALTER TABLE IF EXISTS ONLY public.questions DROP CONSTRAINT IF EXISTS questions_pkey;
ALTER TABLE IF EXISTS ONLY public.questionattributes DROP CONSTRAINT IF EXISTS questionattributes_pkey;
ALTER TABLE IF EXISTS ONLY public.promocodechannel DROP CONSTRAINT IF EXISTS promocodechannal_pkey;
ALTER TABLE IF EXISTS ONLY public.promocodecategory DROP CONSTRAINT IF EXISTS promocodecategory_pkey;
ALTER TABLE IF EXISTS ONLY public.promocodebranch DROP CONSTRAINT IF EXISTS promocodebranch_pkey;
ALTER TABLE IF EXISTS ONLY public.promocode DROP CONSTRAINT IF EXISTS promocode_pkey;
ALTER TABLE IF EXISTS ONLY public.producttt DROP CONSTRAINT IF EXISTS producttt_pkey;
ALTER TABLE IF EXISTS ONLY public.producttags DROP CONSTRAINT IF EXISTS producttags_pkey;
ALTER TABLE IF EXISTS ONLY public.productselectedattribute DROP CONSTRAINT IF EXISTS productselectedattribute_pkey;
ALTER TABLE IF EXISTS ONLY public.productquestions DROP CONSTRAINT IF EXISTS productquestions_pkey;
ALTER TABLE IF EXISTS ONLY public.productimages DROP CONSTRAINT IF EXISTS productimages_pkey;
ALTER TABLE IF EXISTS ONLY public.productavailability DROP CONSTRAINT IF EXISTS productavailability_pkey;
ALTER TABLE IF EXISTS ONLY public.productattribute DROP CONSTRAINT IF EXISTS productattribute_pkey;
ALTER TABLE IF EXISTS ONLY public.product DROP CONSTRAINT IF EXISTS product_pkey;
ALTER TABLE IF EXISTS ONLY public.printingorderlogs DROP CONSTRAINT IF EXISTS printingorderlogs_pkey;
ALTER TABLE IF EXISTS ONLY public.printingorderlogs DROP CONSTRAINT IF EXISTS printinglogs_orderid;
ALTER TABLE IF EXISTS ONLY public.printers DROP CONSTRAINT IF EXISTS printers_pkey;
ALTER TABLE IF EXISTS ONLY public.posintegration DROP CONSTRAINT IF EXISTS posintegration_pkey;
ALTER TABLE IF EXISTS ONLY public.pointlog DROP CONSTRAINT IF EXISTS pointlog_pkey;
ALTER TABLE IF EXISTS ONLY public.paymentrequestlog DROP CONSTRAINT IF EXISTS paymentrequestlog_pkey;
ALTER TABLE IF EXISTS ONLY public.paymentonholdorders DROP CONSTRAINT IF EXISTS paymentonholdorders_pkey;
ALTER TABLE IF EXISTS ONLY public.payment DROP CONSTRAINT IF EXISTS payment_pkey;
ALTER TABLE IF EXISTS ONLY public.ourintegration DROP CONSTRAINT IF EXISTS ourintegration_pkey;
ALTER TABLE IF EXISTS ONLY public.orderstatuspossibilities DROP CONSTRAINT IF EXISTS orderstatus_pkey;
ALTER TABLE IF EXISTS ONLY public.ordersreport DROP CONSTRAINT IF EXISTS ordersreport_pkey;
ALTER TABLE IF EXISTS ONLY public.ordersreport DROP CONSTRAINT IF EXISTS ordersreport_orderid_key;
ALTER TABLE IF EXISTS ONLY public.orderproductattribute DROP CONSTRAINT IF EXISTS orderproductattribute_pkey;
ALTER TABLE IF EXISTS ONLY public.orderproductattribute_2025 DROP CONSTRAINT IF EXISTS orderproductattribute_2025_pkey;
ALTER TABLE IF EXISTS ONLY public.orderproduct DROP CONSTRAINT IF EXISTS orderproduct_pkey;
ALTER TABLE IF EXISTS ONLY public.orderproduct_2025 DROP CONSTRAINT IF EXISTS orderproduct_2025_pkey;
ALTER TABLE IF EXISTS ONLY public.orderprint DROP CONSTRAINT IF EXISTS orderprint_pkey;
ALTER TABLE IF EXISTS ONLY public.orderpricedetails DROP CONSTRAINT IF EXISTS orderpricedetails_referencenumber_referencenumberexternalnu_key;
ALTER TABLE IF EXISTS ONLY public.orderpricedetails DROP CONSTRAINT IF EXISTS orderpricedetails_pkey;
ALTER TABLE IF EXISTS ONLY public.orderprice DROP CONSTRAINT IF EXISTS orderprice_orderid_key;
ALTER TABLE IF EXISTS ONLY public.ordernotificationsettings DROP CONSTRAINT IF EXISTS ordernotificationsettings_pkey;
ALTER TABLE IF EXISTS ONLY public.orderhistory DROP CONSTRAINT IF EXISTS orderhistory_pkey;
ALTER TABLE IF EXISTS ONLY public.orderfollowupdetails DROP CONSTRAINT IF EXISTS orderfollowupdetails_pkey;
ALTER TABLE IF EXISTS ONLY public.orderfollowup DROP CONSTRAINT IF EXISTS orderfollowup_pkey;
ALTER TABLE IF EXISTS ONLY public."order" DROP CONSTRAINT IF EXISTS order_pkey;
ALTER TABLE IF EXISTS ONLY public.order_2025 DROP CONSTRAINT IF EXISTS order_2025_pkey;
ALTER TABLE IF EXISTS ONLY public.offerimage DROP CONSTRAINT IF EXISTS offerimage_pkey;
ALTER TABLE IF EXISTS ONLY public.notificationfollowup DROP CONSTRAINT IF EXISTS notificationfollowup_pkey;
ALTER TABLE IF EXISTS ONLY public.notification DROP CONSTRAINT IF EXISTS notification_pkey;
ALTER TABLE IF EXISTS ONLY public.namelookup DROP CONSTRAINT IF EXISTS namelookup_pkey;
ALTER TABLE IF EXISTS ONLY public.mezaoutgoingdrequestlog DROP CONSTRAINT IF EXISTS mezaoutgoingdrequestlog_pkey;
ALTER TABLE IF EXISTS ONLY public.menurequestlog DROP CONSTRAINT IF EXISTS menurequestlog_pkey;
ALTER TABLE IF EXISTS ONLY public.menuqrcode DROP CONSTRAINT IF EXISTS menuqrcode_pkey;
ALTER TABLE IF EXISTS ONLY public.menuqrcode DROP CONSTRAINT IF EXISTS menuqrcode_channelid_branchid_key;
ALTER TABLE IF EXISTS ONLY public.menuproduct DROP CONSTRAINT IF EXISTS menuproduct_pkey;
ALTER TABLE IF EXISTS ONLY public.menuintegrators DROP CONSTRAINT IF EXISTS menuintegrators_pkey;
ALTER TABLE IF EXISTS ONLY public.menuintegratiosync DROP CONSTRAINT IF EXISTS menuintegratiosync_pkey;
ALTER TABLE IF EXISTS ONLY public.menuchannel DROP CONSTRAINT IF EXISTS menuchannel_pkey;
ALTER TABLE IF EXISTS ONLY public.menu DROP CONSTRAINT IF EXISTS menu_pkey;
ALTER TABLE IF EXISTS ONLY public.menucategories DROP CONSTRAINT IF EXISTS menu_categories_uniqe;
ALTER TABLE IF EXISTS ONLY public.manualprintingorder DROP CONSTRAINT IF EXISTS manualprintingorder_pkey;
ALTER TABLE IF EXISTS ONLY public.lookup DROP CONSTRAINT IF EXISTS lookup_pkey;
ALTER TABLE IF EXISTS ONLY public.linkeradditionalattributes DROP CONSTRAINT IF EXISTS linkeradditionalattributes_pkey;
ALTER TABLE IF EXISTS ONLY public.language DROP CONSTRAINT IF EXISTS language_pkey;
ALTER TABLE IF EXISTS ONLY public.ishbekmapzones DROP CONSTRAINT IF EXISTS ishbekmapzones_pkey;
ALTER TABLE IF EXISTS ONLY public.ishbekcities DROP CONSTRAINT IF EXISTS ishbekcities_pkey;
ALTER TABLE IF EXISTS ONLY public.ishbekareas DROP CONSTRAINT IF EXISTS ishbekareas_pkey;
ALTER TABLE IF EXISTS ONLY public.ishbekcities DROP CONSTRAINT IF EXISTS ishbek_city_id;
ALTER TABLE IF EXISTS ONLY public.interfaceapirequestlog DROP CONSTRAINT IF EXISTS interfaceapirequestlog_pkey;
ALTER TABLE IF EXISTS ONLY public.integrationmiddlewarerequestlog DROP CONSTRAINT IF EXISTS integrationmiddlewarerequestlog_pkey;
ALTER TABLE IF EXISTS ONLY public.integrationcompany DROP CONSTRAINT IF EXISTS integrationcompany_pkey;
ALTER TABLE IF EXISTS ONLY public.generalcomplain DROP CONSTRAINT IF EXISTS id_pk;
ALTER TABLE IF EXISTS ONLY public.elicashcustomers DROP CONSTRAINT IF EXISTS elicashcustomers_pkey;
ALTER TABLE IF EXISTS ONLY public.elicashcustomers DROP CONSTRAINT IF EXISTS elicashcustomers_customerphonenumber_key;
ALTER TABLE IF EXISTS ONLY public.elicashcredentials DROP CONSTRAINT IF EXISTS elicashcredentials_pkey;
ALTER TABLE IF EXISTS ONLY public.elicashapilogs DROP CONSTRAINT IF EXISTS elicashapilogs_pkey;
ALTER TABLE IF EXISTS ONLY public.discountproduct DROP CONSTRAINT IF EXISTS discountproduct_pk;
ALTER TABLE IF EXISTS ONLY public.discountinfo DROP CONSTRAINT IF EXISTS discountinfo_pkey;
ALTER TABLE IF EXISTS ONLY public.discountcustomers DROP CONSTRAINT IF EXISTS discountcustomers_pkey;
ALTER TABLE IF EXISTS ONLY public.discountbranch DROP CONSTRAINT IF EXISTS discountbranch_pkey;
ALTER TABLE IF EXISTS ONLY public.discountattribute DROP CONSTRAINT IF EXISTS discountattribute_pkey;
ALTER TABLE IF EXISTS ONLY public.discountchannel DROP CONSTRAINT IF EXISTS "discounchannal			_pkey";
ALTER TABLE IF EXISTS ONLY public.deliverycompany DROP CONSTRAINT IF EXISTS deliverycompany_pkey;
ALTER TABLE IF EXISTS ONLY public.delayedorders DROP CONSTRAINT IF EXISTS delayedorders_pkey;
ALTER TABLE IF EXISTS ONLY public.customer DROP CONSTRAINT IF EXISTS customerphoneno;
ALTER TABLE IF EXISTS ONLY public.customerpaymentdetail DROP CONSTRAINT IF EXISTS customerpaymentdetail_pkey;
ALTER TABLE IF EXISTS ONLY public.customerbillingdetails DROP CONSTRAINT IF EXISTS customerbillingdetails_pkey;
ALTER TABLE IF EXISTS ONLY public.customerbillingdetails DROP CONSTRAINT IF EXISTS customerbillingdetails_pk;
ALTER TABLE IF EXISTS ONLY public.customer DROP CONSTRAINT IF EXISTS customer_pkey1;
ALTER TABLE IF EXISTS ONLY public.coupon DROP CONSTRAINT IF EXISTS coupon_pkey;
ALTER TABLE IF EXISTS ONLY public.countries DROP CONSTRAINT IF EXISTS countries_pkey;
ALTER TABLE IF EXISTS ONLY public.orderconfig DROP CONSTRAINT IF EXISTS configorder_pkey;
ALTER TABLE IF EXISTS ONLY public.companyuser DROP CONSTRAINT IF EXISTS companyuser_pkey;
ALTER TABLE IF EXISTS ONLY public.companysubarea DROP CONSTRAINT IF EXISTS companysubarea_pk;
ALTER TABLE IF EXISTS ONLY public.companyservicescharge DROP CONSTRAINT IF EXISTS companyservicescharge_pkey;
ALTER TABLE IF EXISTS ONLY public.companyservicechat DROP CONSTRAINT IF EXISTS companyservicechat_pkey;
ALTER TABLE IF EXISTS ONLY public.companynotification DROP CONSTRAINT IF EXISTS companynotification_pk;
ALTER TABLE IF EXISTS ONLY public.companyinfo DROP CONSTRAINT IF EXISTS companyinfo_pkey;
ALTER TABLE IF EXISTS ONLY public.viciphonenumber DROP CONSTRAINT IF EXISTS companyid;
ALTER TABLE IF EXISTS ONLY public.companyfaq DROP CONSTRAINT IF EXISTS companyfaq_pkey;
ALTER TABLE IF EXISTS ONLY public.companyactiveintegrations DROP CONSTRAINT IF EXISTS companyactiveintegrations_pkey;
ALTER TABLE IF EXISTS ONLY public.company DROP CONSTRAINT IF EXISTS company_pkey;
ALTER TABLE IF EXISTS ONLY public.clientintegration DROP CONSTRAINT IF EXISTS clientintegration_companyidintcompanyidpkey;
ALTER TABLE IF EXISTS ONLY public.chatconversation DROP CONSTRAINT IF EXISTS chatconversation_pkey;
ALTER TABLE IF EXISTS ONLY public.channellookup DROP CONSTRAINT IF EXISTS channellookup_pkey;
ALTER TABLE IF EXISTS ONLY public.category DROP CONSTRAINT IF EXISTS category_pkey;
ALTER TABLE IF EXISTS ONLY public.careemlog DROP CONSTRAINT IF EXISTS careemlog_pkey;
ALTER TABLE IF EXISTS ONLY public.callsubmission DROP CONSTRAINT IF EXISTS callsubmission_pkey;
ALTER TABLE IF EXISTS ONLY public.calllog DROP CONSTRAINT IF EXISTS calllog_pkey;
ALTER TABLE IF EXISTS ONLY public.branchtemplate DROP CONSTRAINT IF EXISTS branchtemplate_pkey;
ALTER TABLE IF EXISTS ONLY public.branchsubareafees DROP CONSTRAINT IF EXISTS branchsubareafees_pkey;
ALTER TABLE IF EXISTS ONLY public.branchorderseq DROP CONSTRAINT IF EXISTS branchorderseq_pkey;
ALTER TABLE IF EXISTS ONLY public.branchorderconfig DROP CONSTRAINT IF EXISTS branchorderconfig_pkey;
ALTER TABLE IF EXISTS ONLY public.branchdeliveryaddress DROP CONSTRAINT IF EXISTS branchdeliveryaddress_pkey;
ALTER TABLE IF EXISTS ONLY public.branchdelivery DROP CONSTRAINT IF EXISTS branchdelivery_pkey;
ALTER TABLE IF EXISTS ONLY public.branchcalculator DROP CONSTRAINT IF EXISTS branchcalculator_pkey;
ALTER TABLE IF EXISTS ONLY public.branchavailability DROP CONSTRAINT IF EXISTS branchavailability_pkey;
ALTER TABLE IF EXISTS ONLY public.branchaddress DROP CONSTRAINT IF EXISTS branchaddress_pkey;
ALTER TABLE IF EXISTS ONLY public.branch DROP CONSTRAINT IF EXISTS branch_pkey;
ALTER TABLE IF EXISTS ONLY public.blacklist DROP CONSTRAINT IF EXISTS blacklist_pkey;
ALTER TABLE IF EXISTS ONLY public.benefeciary DROP CONSTRAINT IF EXISTS benefeciary_pkey;
ALTER TABLE IF EXISTS ONLY public.attributemapd DROP CONSTRAINT IF EXISTS attributemapd_pkey;
ALTER TABLE IF EXISTS ONLY public.attribute DROP CONSTRAINT IF EXISTS attribute_pkey;
ALTER TABLE IF EXISTS ONLY public.ashyaeeorderlog DROP CONSTRAINT IF EXISTS ashyaeeorderlog_pkey;
ALTER TABLE IF EXISTS ONLY public.ashyaeemappedentities DROP CONSTRAINT IF EXISTS ashyaeemappedentities_pkey;
ALTER TABLE IF EXISTS ONLY public.ashyaeerequestlog DROP CONSTRAINT IF EXISTS ashayaeerequestlog_pkey;
ALTER TABLE IF EXISTS ONLY public.addresses DROP CONSTRAINT IF EXISTS addresses_pkey;
ALTER TABLE IF EXISTS ONLY public.address_temp DROP CONSTRAINT IF EXISTS address_temp_pkey;
ALTER TABLE IF EXISTS ONLY public.address DROP CONSTRAINT IF EXISTS address_pkey;
ALTER TABLE IF EXISTS ONLY public.companywaapiservicechat DROP CONSTRAINT IF EXISTS "Uni_Companyid";
ALTER TABLE IF EXISTS ONLY public.tax DROP CONSTRAINT IF EXISTS "Tax_pkey";
ALTER TABLE IF EXISTS public.order_2025 ALTER COLUMN ishbekserial DROP DEFAULT;
ALTER TABLE IF EXISTS public."order" ALTER COLUMN ishbekserial DROP DEFAULT;
DROP SEQUENCE IF EXISTS public.wizoo_id_seq;
DROP TABLE IF EXISTS public.waapilogs;
DROP TABLE IF EXISTS public.waapiclients;
DROP TABLE IF EXISTS public.viewprinter;
DROP TABLE IF EXISTS public.viciphonenumber;
DROP TABLE IF EXISTS public.userauth;
DROP TABLE IF EXISTS public.transferbranch;
DROP TABLE IF EXISTS public.transaction;
DROP TABLE IF EXISTS public.tempaddress;
DROP TABLE IF EXISTS public.talabatprerequestlog;
DROP TABLE IF EXISTS public.talabatmenu;
DROP TABLE IF EXISTS public.talabatdelivery;
DROP TABLE IF EXISTS public.talabatcredential;
DROP TABLE IF EXISTS public.statuslog;
DROP TABLE IF EXISTS public.scheduledeliveryorderrequest;
DROP TABLE IF EXISTS public.rlookup;
DROP TABLE IF EXISTS public.restaurantparams;
DROP TABLE IF EXISTS public.restaurantcustomercopy2;
DROP TABLE IF EXISTS public.restaurantcustomercopy;
DROP TABLE IF EXISTS public.restaurantcustomer;
DROP TABLE IF EXISTS public.requestlog;
DROP TABLE IF EXISTS public.relatedproduct;
DROP TABLE IF EXISTS public.questions;
DROP TABLE IF EXISTS public.questionattributes;
DROP TABLE IF EXISTS public.promocodecustomers;
DROP TABLE IF EXISTS public.promocodechannel;
DROP TABLE IF EXISTS public.promocodecategory;
DROP TABLE IF EXISTS public.promocodebranch;
DROP TABLE IF EXISTS public.promocode;
DROP TABLE IF EXISTS public.producttt;
DROP TABLE IF EXISTS public.productselectedattribute;
DROP TABLE IF EXISTS public.productquestions;
DROP TABLE IF EXISTS public.productimages;
DROP TABLE IF EXISTS public.printingorderlogs;
DROP TABLE IF EXISTS public.posintegration;
DROP TABLE IF EXISTS public.pointlog;
DROP TABLE IF EXISTS public.paymentrequestlog;
DROP TABLE IF EXISTS public.paymentonholdorders;
DROP TABLE IF EXISTS public.ourintegration;
DROP TABLE IF EXISTS public.orderstatuspossibilities1;
DROP TABLE IF EXISTS public.ordersreport;
DROP TABLE IF EXISTS public.orderproductattribute_2025;
DROP TABLE IF EXISTS public.orderproductattribute;
DROP TABLE IF EXISTS public.orderproduct_2025;
DROP TABLE IF EXISTS public.orderproduct;
DROP TABLE IF EXISTS public.orderprint;
DROP TABLE IF EXISTS public.orderpricedetails;
DROP TABLE IF EXISTS public.orderprice;
DROP TABLE IF EXISTS public.orderhistoryprice;
DROP TABLE IF EXISTS public.orderfollowup;
DROP TABLE IF EXISTS public.orderconfig;
DROP VIEW IF EXISTS public.ordercomplain;
DROP SEQUENCE IF EXISTS public.order_ishbekserial_seq;
DROP SEQUENCE IF EXISTS public.order_2025_ishbekserial_seq;
DROP TABLE IF EXISTS public.order_2025;
DROP TABLE IF EXISTS public.offerimage;
DROP TABLE IF EXISTS public.notificationfollowup;
DROP TABLE IF EXISTS public.notification;
DROP TABLE IF EXISTS public.mezaoutgoingdrequestlog;
DROP TABLE IF EXISTS public.menurequestlog;
DROP TABLE IF EXISTS public.menuqrcode;
DROP TABLE IF EXISTS public.menuproduct;
DROP TABLE IF EXISTS public.menuintegrators;
DROP TABLE IF EXISTS public.menuintegratiosync;
DROP TABLE IF EXISTS public.menuchannel;
DROP TABLE IF EXISTS public.menucategories;
DROP TABLE IF EXISTS public.menu;
DROP TABLE IF EXISTS public.manualprintingorder;
DROP TABLE IF EXISTS public.lookup;
DROP SEQUENCE IF EXISTS public.lockup_id_seq;
DROP TABLE IF EXISTS public.linkeradditionalattributes;
DROP TABLE IF EXISTS public.language;
DROP TABLE IF EXISTS public.ishbekmapzonestemp;
DROP TABLE IF EXISTS public.ishbekmapzones;
DROP TABLE IF EXISTS public.ishbekcitiestemp;
DROP TABLE IF EXISTS public.ishbekcities;
DROP SEQUENCE IF EXISTS public.ishbekcities_serialid_seq;
DROP TABLE IF EXISTS public.ishbekareas;
DROP SEQUENCE IF EXISTS public.ishbekareas_serialid_seq;
DROP TABLE IF EXISTS public.interfaceapirequestlog;
DROP TABLE IF EXISTS public.integrationmiddlewarerequestlog;
DROP TABLE IF EXISTS public.generalcomplain;
DROP TABLE IF EXISTS public.elicashcustomers;
DROP TABLE IF EXISTS public.elicashcredentials;
DROP TABLE IF EXISTS public.elicashapilogs;
DROP TABLE IF EXISTS public.discountproduct;
DROP TABLE IF EXISTS public.discountcustomers;
DROP TABLE IF EXISTS public.discountchannel;
DROP TABLE IF EXISTS public.discountbranch;
DROP TABLE IF EXISTS public.discountattribute;
DROP TABLE IF EXISTS public.customerpaymentdetail;
DROP TABLE IF EXISTS public.customeraddress;
DROP TABLE IF EXISTS public.customer;
DROP TABLE IF EXISTS public.countries;
DROP TABLE IF EXISTS public.companywaapiservicechat;
DROP TABLE IF EXISTS public.companyuser;
DROP TABLE IF EXISTS public.companysubarea;
DROP TABLE IF EXISTS public.companyservicescharge;
DROP TABLE IF EXISTS public.companyservices;
DROP TABLE IF EXISTS public.companyservicechat;
DROP TABLE IF EXISTS public.companynotification;
DROP TABLE IF EXISTS public.companyinfo;
DROP TABLE IF EXISTS public.companychannels;
DROP TABLE IF EXISTS public.companyactiveintegrations;
DROP TABLE IF EXISTS public.channellookup;
DROP TABLE IF EXISTS public.category;
DROP TABLE IF EXISTS public.careemlog;
DROP TABLE IF EXISTS public.callsubmission;
DROP TABLE IF EXISTS public.calllog;
DROP TABLE IF EXISTS public.branchsubareafees;
DROP TABLE IF EXISTS public.branchorderseq;
DROP TABLE IF EXISTS public.branchorderconfig;
DROP TABLE IF EXISTS public.branchdeliverycharge;
DROP TABLE IF EXISTS public.branchdeliveryaddress;
DROP TABLE IF EXISTS public.branchdelivery;
DROP TABLE IF EXISTS public.branchcalculator;
DROP TABLE IF EXISTS public.branchavailability;
DROP TABLE IF EXISTS public.branchaddress;
DROP TABLE IF EXISTS public.blacklist;
DROP TABLE IF EXISTS public.attributemapd;
DROP TABLE IF EXISTS public.attribute;
DROP TABLE IF EXISTS public.ashyaeerequestlog;
DROP TABLE IF EXISTS public.ashyaeeorderlog;
DROP TABLE IF EXISTS public.ashyaeemappedentities;
DROP TABLE IF EXISTS public.addresses;
DROP TABLE IF EXISTS public.address_temp;
DROP TABLE IF EXISTS public.address;
DROP USER MAPPING IF EXISTS FOR postgres SERVER chatbotaiserver;
DROP SERVER IF EXISTS chatbotaiserver;
DROP FUNCTION IF EXISTS public.workingcalculator(lat1 double precision, lon1 double precision, _companyid uuid);
DROP PROCEDURE IF EXISTS public.verifycustomer_ai(IN _isverify boolean, IN _id uuid, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.verifycustomer(IN _isverify boolean, IN _id uuid, IN _updatedby public.citext);
DROP FUNCTION IF EXISTS public.validatepromocode(_promo public.citext, _branchid uuid);
DROP PROCEDURE IF EXISTS public.userphone(IN name public.citext, IN email public.citext, IN verified boolean, IN lastlogin public.citext, IN lastloginip public.citext, IN image public.citext, IN phone public.citext, IN id uuid, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.userphone(IN phone public.citext, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.upsetproduct(IN _name jsonb, IN _fulldescription jsonb, IN _shortdescription jsonb, IN _aliasname jsonb, IN _aliasdescription jsonb, IN _producttags jsonb, IN _sku public.citext, IN _isavailable boolean, IN _ispublished boolean, IN _isoffer boolean, IN _hour integer, IN _min integer, IN _categoryid uuid, IN _branchprice jsonb, IN _imagepath public.citext, IN _displaynumber integer, IN _createdby public.citext, IN _id uuid, IN _is_deleted boolean, IN _externalposid public.citext, INOUT _productid uuid);
DROP PROCEDURE IF EXISTS public.upsetattributeforintegration(IN _attribute uuid, IN _productid uuid, IN _name jsonb, IN _description jsonb, IN _isrequired boolean, IN _isalergy boolean, IN _isavailable boolean, IN _attributeid uuid, IN _controltype public.citext, IN _priority integer, IN _ispreselected boolean, IN _isglobal boolean, IN _weight public.citext, IN _price jsonb, IN _companyid uuid, IN _updatedby public.citext, IN _noofselection integer, IN _minimumcount integer, IN _maximumcount integer, IN _ischatbotqestion boolean, IN _is_deleted boolean, IN _externalposid public.citext, INOUT _id uuid);
DROP FUNCTION IF EXISTS public.upsertelicashoutgoingapilog(_id uuid, _requesturl text, _headers jsonb, _requestbody jsonb, _customername text, _customerphonenumber text, _transactiontype text, _responsehttpcode integer, _responsebody jsonb);
DROP FUNCTION IF EXISTS public.upsertelicashcustomer(_customername public.citext, _customerphonenumber public.citext, _customersource public.citext);
DROP PROCEDURE IF EXISTS public.uploadsound(IN _branchid uuid, IN _sound public.citext, IN _volume numeric, IN _loops boolean);
DROP PROCEDURE IF EXISTS public.updatewhatsapptemplatestatus(IN _status public.citext, IN _whatsapptemplateid public.citext);
DROP PROCEDURE IF EXISTS public.updatewaapilogs(IN _response jsonb, IN _sessionid uuid);
DROP PROCEDURE IF EXISTS public.updatevisibility(IN _id uuid, IN _ordercase public.citext, IN _isagent boolean, IN _isteamleader boolean, IN _isbranch boolean, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updatetransferbranch(IN _id uuid, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updatetoverifycsutomer_ai(IN _id uuid, IN _code public.citext);
DROP PROCEDURE IF EXISTS public.updatetoverifycsutomer(IN _id uuid, IN _code public.citext);
DROP PROCEDURE IF EXISTS public.updatetaxcategory(IN _id uuid, IN _name public.citext, IN _companyid uuid, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updatetax(IN _id uuid, IN _value numeric, IN _name public.citext, IN _taxcategoryid uuid, IN _countryid uuid, IN _cityid uuid, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updatetalabatorderdeliverystatus(IN _talabatorderid public.citext, IN _deliverystatus public.citext);
DROP PROCEDURE IF EXISTS public.updateservicesusebalance(IN _companyid uuid, IN _serviceid uuid, IN _value integer);
DROP PROCEDURE IF EXISTS public.updaterlookup(IN _rid uuid, IN _sid bigint, IN _rname public.citext);
DROP PROCEDURE IF EXISTS public.updaterestaurantparams(IN _companyid uuid, IN _period integer, IN _loyalityperiod integer, IN _loyalitycount integer, IN _loyalityamount numeric);
DROP PROCEDURE IF EXISTS public.updaterequestlog(IN _id uuid, IN _response public.citext);
DROP PROCEDURE IF EXISTS public.updatepromocodeuse(IN _id uuid, IN _customerid uuid);
DROP PROCEDURE IF EXISTS public.updatepromocode(IN _id uuid, IN _name public.citext, IN _type public.citext, IN _categoryids uuid[], IN _channelids uuid[], IN _branchids uuid[], IN _customerids uuid[], IN _value numeric, IN _minquantity integer, IN _maxvalue numeric, IN _minprice numeric, IN _priority integer, IN _ispercentage boolean, IN _availablefrom timestamp without time zone, IN _availableto timestamp without time zone, IN _daysofweek integer[], IN _description public.citext, IN _updatedby public.citext, IN _isdaily boolean, IN _numberofusecustomer integer, IN _numberofuse integer, IN _descriptionlanguage jsonb);
DROP PROCEDURE IF EXISTS public.updateproductprice(IN _productid uuid, IN _price jsonb);
DROP PROCEDURE IF EXISTS public.updateproductimages(IN _id uuid, IN _imagepath public.citext, IN _productid uuid, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updateproductavailability(IN _id uuid, IN _name public.citext, IN _productids uuid[], IN _categoryids uuid[], IN _channelids uuid[], IN _beneficiarycategory jsonb, IN _attributeids uuid[], IN _fromtime timestamp without time zone, IN _totime timestamp without time zone, IN _fromdate timestamp without time zone, IN _todate timestamp without time zone, IN _daysofweek integer[], IN _isavailable boolean, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updateproductattribute(IN _id uuid, IN _languagecode public.citext, IN _name public.citext, IN _controltype integer, IN _noofselection integer, IN _isrequired boolean, IN _istrackable boolean, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updateproduct(IN _id uuid, IN _languagecode public.citext, IN _categoryid uuid, IN _imagepath public.citext, IN _thumbimage public.citext, IN _name jsonb, IN _shortdescription jsonb, IN _sku public.citext, IN _producttags jsonb, IN _fulldescription jsonb, IN _isavailable boolean, IN _ispublished boolean, IN _isoffer boolean, IN _istopselling boolean, IN _hour integer, IN _min integer, IN _displaynumber integer, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updateprintingorder(IN _jobid uuid, IN _printername public.citext[], IN _old public.citext[]);
DROP PROCEDURE IF EXISTS public.updateprinters(IN _id uuid, IN _categoryids uuid[], IN _branchid uuid, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updateprinterrequestlog(IN _id uuid, IN _response public.citext, IN _printingtype public.citext, IN _template public.citext);
DROP PROCEDURE IF EXISTS public.updateprinterbranch(IN _id uuid, IN _delay jsonb, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updatepaymentrequestlog(IN _id uuid, IN _checkoutid public.citext, IN _holdorderid uuid);
DROP PROCEDURE IF EXISTS public.updatepaymentcredentials(IN _id uuid, IN _marchent public.citext, IN _username public.citext, IN _password public.citext);
DROP PROCEDURE IF EXISTS public.updateotpcode(IN _id uuid, IN _code public.citext);
DROP PROCEDURE IF EXISTS public.updateorderstatuspossibilities(IN _id uuid, IN _branchid uuid, IN _status public.citext, IN _nextstatus uuid, IN _cancancel boolean, IN _islaststatus boolean, IN _color public.citext, IN _first boolean, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updateorderreference(IN _id uuid, IN _key public.citext, IN _value public.citext);
DROP PROCEDURE IF EXISTS public.updateorderfollowupdetails(IN _orderid uuid, IN _adminnote public.citext);
DROP PROCEDURE IF EXISTS public.updateorderfollowup(IN _orderid uuid, IN _customerid uuid, IN _status public.citext, IN _complaincategory public.citext, IN _complainsubcategory public.citext, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updateorderdeliverystatus(IN _orderid uuid, IN _deliverystatus public.citext);
DROP PROCEDURE IF EXISTS public.updateordercurrentstatus(IN _id uuid, IN _status public.citext, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updateorderbytalabat(IN _id uuid, IN _talabatorderid public.citext);
DROP PROCEDURE IF EXISTS public.updateorder(IN _id uuid, IN _branchorderid public.citext, IN _ordersource uuid, IN _scheduled timestamp without time zone, IN _deliverytype uuid, IN _customerid uuid, IN _branchid uuid, IN _notes public.citext, IN _totalprice numeric, IN _deliveryprice numeric, IN _deliveryaddress public.citext, IN _subtotalprice numeric, IN _referencenumber public.citext, IN _totalpreparingtime public.citext, IN _deliverystatus public.citext, IN _paymenttype public.citext, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updateoption(IN _id uuid, IN _languagecode public.citext, IN _name public.citext, IN _suboptionid uuid, IN _attributeid uuid, IN _quantity integer, IN _price jsonb, IN _ispreselected boolean, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updateofferaction(IN _id uuid, IN _quantity integer, IN _categoryid uuid, IN _productid uuid, IN _attributes integer[], IN _offerid uuid, IN _newprice numeric, IN _ispercentage boolean, IN _discountvalue numeric, IN _maxdiscountprice numeric, IN _mindiscountprice numeric, IN _maxdiscountquantity integer, IN _mindiscountquantity integer, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updateoffer(IN _id uuid, IN _offertype integer, IN _categoryid uuid, IN _productid uuid, IN _branchids uuid[], IN _channelids uuid[], IN _fromdate timestamp without time zone, IN _todate timestamp without time zone, IN _fromtime timestamp without time zone, IN _totime timestamp without time zone, IN _daysofweek integer[], IN _priority integer, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updatenotification(IN _id uuid, IN _subject text, IN _priority integer, IN _branchid uuid[], IN _startdate timestamp without time zone, IN _starttime timestamp without time zone, IN _urgent boolean, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updatenamelookup(IN _id uuid, IN _name public.citext, IN _type public.citext, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updatemenurequestlog(IN _id uuid, IN _response public.citext);
DROP PROCEDURE IF EXISTS public.updatemenuproduct(IN _menuid uuid, IN _productid uuid, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updatemenuintegrationtalabatsync(IN _companyid uuid);
DROP PROCEDURE IF EXISTS public.updatemenuintegrationsync(IN _menuid uuid, IN _channelid uuid, IN _issync boolean, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updatemenuavailability(IN _id uuid, IN _isavailable boolean, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updatemenu(IN _id uuid, IN _productids uuid[], IN _channelids uuid[], IN _branchids uuid[], IN _name public.citext, IN _isavailable boolean, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updatelanguageresource(IN _id uuid, IN _languagecode public.citext, IN _languageid uuid, IN _key public.citext, IN _value public.citext, IN _objectid uuid, IN _type integer, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updateisseen(IN _orderid uuid);
DROP PROCEDURE IF EXISTS public.updateishbekproduct(IN _id uuid, IN _name jsonb, IN _shortdescription jsonb, IN _categoryid uuid, IN _price jsonb, IN _branchprice jsonb, IN _imagepath public.citext, IN _is_deleted boolean, IN _aliasname jsonb, IN _aliasdescription jsonb, IN _externalposid public.citext);
DROP PROCEDURE IF EXISTS public.updateishbekproduct(IN _id uuid, IN _name jsonb, IN _shortdescription jsonb, IN _categoryid uuid, IN _price jsonb);
DROP PROCEDURE IF EXISTS public.updateinterfaceapirequestlog(IN _id uuid, IN _response public.citext);
DROP PROCEDURE IF EXISTS public.updateintegrationrequest(IN _companyid uuid, IN _channelid uuid, IN _status public.citext, IN _isactive boolean, IN _reason public.citext);
DROP PROCEDURE IF EXISTS public.updateintegrationmiddlewarerequestlog(IN _id uuid, IN _response public.citext);
DROP PROCEDURE IF EXISTS public.updateintegrationcompany(IN _id uuid, IN _name public.citext, IN _logo public.citext, IN _type public.citext, IN _phone public.citext, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updateholdordertofinished(IN _paymentorderid uuid, IN _sessionid public.citext);
DROP PROCEDURE IF EXISTS public.updateenabledbranch(IN _companyid uuid, IN _enabled boolean, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updatediscount(IN _id uuid, IN _name public.citext, IN _discounttype public.citext, IN _productids uuid[], IN _attributeids uuid[], IN _categoryids uuid[], IN _channelids uuid[], IN _branchids uuid[], IN _customerids uuid[], IN _discountvalue numeric, IN _mindiscountquantity integer, IN _maxdiscountprice numeric, IN _mindiscountprice numeric, IN _priority integer, IN _ispercentage boolean, IN _availablefrom timestamp without time zone, IN _availableto timestamp without time zone, IN _daysofweek integer[], IN _promocode public.citext, IN _description public.citext, IN _updatedby public.citext, IN _level public.citext, IN _isdaily boolean, IN _noofusefrocustomer integer, IN _noofuse integer, IN _descriptionlanguage jsonb);
DROP PROCEDURE IF EXISTS public.updatedeliverycompany(INOUT _id uuid, IN _name jsonb, IN _isaggregated boolean, IN _phonenumber public.citext, IN _addressid uuid, IN _opentime timestamp without time zone, IN _closetime timestamp without time zone, IN _currency public.citext, IN _isavailable boolean, IN _logo public.citext, IN _website public.citext, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updatecustomeraddressgeo(IN _addressid uuid, IN _buildingno public.citext, IN _streetname public.citext, IN _details public.citext, IN _note public.citext, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updatecustomeraddressbydistance_ai(IN _customerid uuid, IN _addressid uuid, IN _name public.citext, IN _latitude numeric, IN _longtitude numeric, IN _details public.citext, IN _buildingno public.citext, IN _streetname public.citext, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updatecustomeraddressbydistance(IN _customerid uuid, IN _addressid uuid, IN _name public.citext, IN _latitude numeric, IN _longtitude numeric, IN _details public.citext, IN _buildingno public.citext, IN _streetname public.citext, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updatecustomeraddress_ai(IN _id uuid, IN _latitude numeric, IN _longtitude numeric, IN _buildingno public.citext, IN _details public.citext, IN _name public.citext, IN _departmentno public.citext, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updatecustomeraddress(IN _customerid uuid, IN _addressid uuid, IN _incomingaddressid uuid, IN _buildingno public.citext, IN _streetname public.citext, IN _details public.citext, IN _name public.citext, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updatecustomer_ai(IN _id uuid, IN _name public.citext, IN _email public.citext);
DROP PROCEDURE IF EXISTS public.updatecoupon(IN _id uuid, IN _offerid uuid, IN _coupontype integer, IN _minprice numeric, IN _maxprice numeric, IN _minquantity integer, IN _maxquantity integer, IN _couponvalue numeric, IN _isunlimited boolean, IN _numberofuses integer, IN _customerids uuid[], IN _code public.citext, IN _fromdate timestamp without time zone, IN _todate timestamp without time zone, IN _fromtime timestamp without time zone, IN _totime timestamp without time zone, IN _newprice numeric, IN _ispercentage boolean, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updatecompanyuser(IN _id uuid, IN _usertype public.citext, IN _username public.citext, IN _email public.citext, IN _name public.citext, IN _branchid uuid[], IN _phonenumber numeric, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updatecompanyservicesactivation(IN _companyid uuid, IN _serviceid uuid, IN _value boolean);
DROP PROCEDURE IF EXISTS public.updatecompanyprofile(IN _companyid uuid, IN _logo public.citext, IN _email public.citext, IN _name public.citext, IN _phone public.citext, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updatecompanyinfo(IN _id uuid, IN _languagecode public.citext, IN _companyid uuid, IN _type integer, IN _value public.citext, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updatecompanyfaq(IN _id uuid, IN _question public.citext, IN _answer1 public.citext, IN _answer2 public.citext, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updatecompanychannelactivation(IN _companyid uuid, IN _channelid uuid, IN _value boolean);
DROP PROCEDURE IF EXISTS public.updatecompany(IN _id uuid, IN _name public.citext, IN _logo public.citext, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updateclientintegration(IN _companyid uuid, IN _intcompanyid uuid, IN _name public.citext, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updatecategoryforintegration(IN _id uuid, IN _arname public.citext, IN _enname public.citext, IN _categorytag uuid, IN _image public.citext, IN _parentcategoryid uuid, IN _displaynumber integer, IN _updatedby public.citext, IN _is_deleted boolean, IN _externalposid public.citext);
DROP PROCEDURE IF EXISTS public.updatecategory(IN _id uuid, IN _arname public.citext, IN _enname public.citext, IN _categorytag uuid, IN _image public.citext, IN _parentcategoryid uuid, IN _displaynumber integer, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updatebranchtemplate(IN _branchid uuid, IN _type public.citext, IN _paid boolean, IN _islogo boolean, IN _isrestaurantname boolean, IN _isphonenumber boolean, IN _isbranchname boolean, IN _isorderinfo boolean, IN _isproductinfo boolean, IN _isordertype boolean, IN _isordersource boolean, IN _isscheduletime boolean, IN _iscreatetime boolean, IN _isordernote boolean, IN _isdeliveryfees boolean, IN _isorderprice boolean, IN _istaxvalue boolean, IN _istotal boolean, IN _iscustomername boolean, IN _iscustomerphone boolean, IN _iscustomeraddress boolean, IN _isdeliverynote boolean, IN _istaxnumber boolean, IN _isattribute boolean, IN _issubattribute boolean, IN _isproductnote boolean, IN _isordernumber boolean, IN _updatedby public.citext, IN _taxnumbervalue public.citext);
DROP PROCEDURE IF EXISTS public.updatebranchtemplate(IN _branchid uuid, IN _type public.citext, IN _islogo boolean, IN _isrestaurantname boolean, IN _isphonenumber boolean, IN _isbranchname boolean, IN _isorderinfo boolean, IN _isproductinfo boolean, IN _isordertype boolean, IN _isordersource boolean, IN _isscheduletime boolean, IN _iscreatetime boolean, IN _isordernote boolean, IN _isdeliveryfees boolean, IN _isorderprice boolean, IN _istaxvalue boolean, IN _istotal boolean, IN _iscustomername boolean, IN _iscustomerphone boolean, IN _iscustomeraddress boolean, IN _isdeliverynote boolean, IN _istaxnumber boolean, IN _isattribute boolean, IN _issubattribute boolean, IN _isproductnote boolean, IN _isordernumber boolean, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updatebranchstatusfromcashier(IN _branchid uuid, IN _status integer);
DROP PROCEDURE IF EXISTS public.updatebranchstatusfromcashier(IN _branchid uuid);
DROP PROCEDURE IF EXISTS public.updatebranch(IN _id uuid, IN _countryid uuid, IN _name public.citext, IN _companyid uuid, IN _addressid uuid, IN _status integer, IN _phonenumber public.citext, IN _opentime timestamp without time zone, IN _closetime timestamp without time zone, IN _address public.citext, IN _latitude numeric, IN _longtitude numeric, IN _namelanguage jsonb, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updateattributevalue(IN _id uuid, IN _languagecode public.citext, IN _name jsonb, IN _weight public.citext, IN _price jsonb, IN _priority integer, IN _ispreselected boolean, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updateattributevalue(IN _id uuid, IN _languagecode public.citext, IN _weight public.citext, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.updateattributeforintegration(IN _id uuid, IN _productid uuid, IN _name jsonb, IN _description jsonb, IN _isrequired boolean, IN _isalergy boolean, IN _isavailable boolean, IN _attributeid uuid, IN _controltype public.citext, IN _priority integer, IN _ispreselected boolean, IN _isglobal boolean, IN _weight public.citext, IN _price jsonb, IN _companyid uuid, IN _updatedby public.citext, IN _noofselection integer, IN _minimumcount integer, IN _maximumcount integer, IN _ischatbotqestion boolean, IN _is_deleted boolean, IN _externalposid public.citext);
DROP PROCEDURE IF EXISTS public.updateattribute(IN _id uuid, IN _productid uuid, IN _name jsonb, IN _description jsonb, IN _isrequired boolean, IN _isalergy boolean, IN _ischatbotquestion boolean, IN _isavailable boolean, IN _attributeid uuid, IN _controltype public.citext, IN _priority integer, IN _ispreselected boolean, IN _isglobal boolean, IN _weight public.citext, IN _price jsonb, IN _companyid uuid, IN _updatedby public.citext, IN _noofselection integer, IN _minimumcount integer, IN _maximumcount integer);
DROP PROCEDURE IF EXISTS public.updateattribute(IN _id uuid, IN _productid uuid, IN _name jsonb, IN _description jsonb, IN _isrequired boolean, IN _isalergy boolean, IN _isavailable boolean, IN _attributeid uuid, IN _controltype public.citext, IN _priority integer, IN _ispreselected boolean, IN _isglobal boolean, IN _weight public.citext, IN _price jsonb, IN _companyid uuid, IN _updatedby public.citext, IN _noofselection integer, IN _minimumcount integer, IN _maximumcount integer);
DROP FUNCTION IF EXISTS public.trackingorder_ai(_clientphone public.citext, _customerphone public.citext);
DROP PROCEDURE IF EXISTS public.toggleisavailablediscount(IN _discountid uuid, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.testdeleteduplicates(IN _customerphones public.citext[]);
DROP PROCEDURE IF EXISTS public.settopreparingstatus(IN _orderid uuid, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.setproductunavailable(IN _id uuid, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.setproductavailable(IN _id uuid, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.setordernextstatus(IN _orderid uuid, IN _updatedby public.citext, INOUT _status public.citext);
DROP PROCEDURE IF EXISTS public.setentitiesimagetonull(IN _entityids uuid[], IN _entityname public.citext, INOUT returnuuid uuid[]);
DROP PROCEDURE IF EXISTS public.setentitiesimagetonull(IN _entityids uuid[], IN _entityname public.citext);
DROP PROCEDURE IF EXISTS public.setcategoryunavailable(IN _id uuid, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.setcategoryavailable(IN _id uuid, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.setattributeunavailable(IN _id uuid, IN _branchid uuid, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.setattributeavailable(IN _id uuid, IN _branchid uuid, IN _updatedby public.citext);
DROP FUNCTION IF EXISTS public.searchaddressbyaddressid(addressid uuid);
DROP FUNCTION IF EXISTS public.resourceexist(_languagecode public.citext, _objectid uuid, _key public.citext, _type integer);
DROP FUNCTION IF EXISTS public.removequotation(_children jsonb, _orderproductid uuid);
DROP FUNCTION IF EXISTS public.removequotation();
DROP PROCEDURE IF EXISTS public.removecustomeraddress(IN _addressid uuid);
DROP PROCEDURE IF EXISTS public.registercompanylanguage(IN _companyid uuid, IN _languagename public.citext, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.registercompany(IN _name public.citext, IN _phone public.citext, IN _email public.citext, IN _address public.citext, IN _logo character varying, IN _createdby public.citext, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.promote(IN _crid uuid);
DROP PROCEDURE IF EXISTS public.printingorder(IN _orderid uuid, IN _branchid uuid);
DROP FUNCTION IF EXISTS public.posorderdata(_orderid uuid);
DROP FUNCTION IF EXISTS public.perfectemployeereport(_branchids uuid[], _fromtime timestamp without time zone, _totime timestamp without time zone);
DROP PROCEDURE IF EXISTS public.moveordertocurrent(IN _orderid uuid);
DROP PROCEDURE IF EXISTS public.modifycustomeraddress(IN _addressid uuid, IN _ishbekcityid integer, IN _ishbekareaid bigint, IN _preferedsubarea public.citext, IN _name public.citext, IN _lat double precision, IN _lng double precision, IN _street public.citext, IN _buildingnumber public.citext, IN _otherdetails public.citext, IN _notes public.citext);
DROP PROCEDURE IF EXISTS public.markorderasready(IN _orderid uuid);
DROP FUNCTION IF EXISTS public.log_notice(text);
DROP FUNCTION IF EXISTS public.jsonupdateproperties(json jsonb, key_to_set text, value_to_set anyelement);
DROP FUNCTION IF EXISTS public.jsonupdateproperties(json json, key_to_set character varying, value_to_set character varying);
DROP FUNCTION IF EXISTS public.jsonsetpropertiesnumeric(json json, key_to_set character varying, value_to_set numeric);
DROP FUNCTION IF EXISTS public.jsonsetpropertiesany(json json, key_to_set character varying, value_to_set anyelement);
DROP FUNCTION IF EXISTS public.jsonbupdateproperties(json jsonb, key_to_set text, value_to_set anyelement);
DROP FUNCTION IF EXISTS public.isattributeashyaeelevel3(_attributeid uuid);
DROP FUNCTION IF EXISTS public.integrationcomapnystatuscareem(_id uuid);
DROP FUNCTION IF EXISTS public.integrationcomapnystatus(_id uuid);
DROP FUNCTION IF EXISTS public.integrationactive(_companyid uuid, _channelid uuid);
DROP PROCEDURE IF EXISTS public.insertrlookup(IN _rid uuid, IN _sid bigint, IN _rname public.citext);
DROP PROCEDURE IF EXISTS public.insertqrintomenuqrcode(IN _id uuid, IN _qrcode public.citext);
DROP PROCEDURE IF EXISTS public.insertpointlog(IN _crid uuid, IN _amount double precision, IN _channelid uuid, IN _orderid uuid);
DROP PROCEDURE IF EXISTS public.insertpaymentonoholdorders(IN _sessionid public.citext, IN _result public.citext, IN _response public.citext, IN _order jsonb, IN _customerid uuid, IN _branchid uuid, IN _ordersource uuid, IN _totalprice numeric, IN _paymenttype public.citext, IN _subtotalprice numeric, IN _price jsonb, IN _scheduled timestamp without time zone, IN _notes public.citext, IN _deliveryprice numeric, IN _deliveryaddress uuid, IN _deliverytype uuid, IN _referencenumber jsonb, IN _referencenumber2 public.citext, IN _createdby public.citext, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.insertlogstatus(IN _crid uuid, IN _status integer, IN _previousstatus integer, IN _customerid uuid, IN _restaurantid uuid);
DROP PROCEDURE IF EXISTS public.insertishbekmapzones(IN _cityname public.citext, IN _cityid integer, IN _areaname public.citext, IN _areaid integer, IN _coordinates jsonb, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.insertintomenuqrcode(IN _menuid uuid, IN _channelid uuid, IN _branchid uuid, IN _createdby public.citext, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.insertdeliveryorderrequest(IN _orderid uuid, IN _deliverycompanyid uuid, IN _name public.citext, IN _baseurl public.citext, IN _apiurl public.citext, IN _body jsonb, IN _response jsonb, IN _executiontime timestamp without time zone);
DROP PROCEDURE IF EXISTS public.insertcustomerdetails(IN _customerid uuid, IN _name public.citext, IN _phoneno public.citext);
DROP PROCEDURE IF EXISTS public.insertcheckorderprint(IN _id uuid);
DROP PROCEDURE IF EXISTS public.insertbranchdeliverycharge(IN _id uuid, IN _branchid uuid, IN _city public.citext, IN _area public.citext, IN _subarea public.citext, IN _fees numeric, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.insertbranchdeliverycalculator(IN _branchid uuid, IN _startperiod numeric, IN _endperiod numeric, IN _price numeric, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.insertashyaeemappedentities(IN _ishbekid uuid, IN _ashyaeeid integer);
DROP PROCEDURE IF EXISTS public.handlepreferedsubarea(IN _deliveryaddressid uuid, IN _preferedsubarea public.citext);
DROP FUNCTION IF EXISTS public.getwaapiclientinstances(_companyid uuid);
DROP FUNCTION IF EXISTS public.getvaluelocalization(_languagecode public.citext, _key public.citext, _objectid uuid, _type integer);
DROP FUNCTION IF EXISTS public.getvalue(_languagecode public.citext, _key public.citext, _objectid uuid, _type integer);
DROP FUNCTION IF EXISTS public.getuserauth(_username public.citext, _password public.citext);
DROP FUNCTION IF EXISTS public.getunavailableproductofcategory(_companyid uuid);
DROP FUNCTION IF EXISTS public.gettopsellingitemsreport(_branchids uuid[], _channels uuid[], _from timestamp without time zone, _to timestamp without time zone);
DROP FUNCTION IF EXISTS public.gettopsellingitem_ai(_companyid uuid);
DROP FUNCTION IF EXISTS public.gettaxescategories(pagenumber integer, pagesize integer);
DROP FUNCTION IF EXISTS public.gettaxes(pagenumber integer, pagesize integer);
DROP FUNCTION IF EXISTS public.gettaxcategorybyid(_id uuid);
DROP TABLE IF EXISTS public.taxcategory;
DROP FUNCTION IF EXISTS public.gettaxbyid(_id uuid);
DROP TABLE IF EXISTS public.tax;
DROP FUNCTION IF EXISTS public.gettalabatreferencenumber(_ishbekorderid uuid, _talabatordersource uuid);
DROP FUNCTION IF EXISTS public.gettalabatorderid(_orderid uuid);
DROP FUNCTION IF EXISTS public.gettalabatorderbodyrequest(_deliveryplatformid public.citext);
DROP FUNCTION IF EXISTS public.gettalabatmenurequestlogbycompanyid(_companyid uuid);
DROP FUNCTION IF EXISTS public.gettalabatmenu(_companyid uuid);
DROP FUNCTION IF EXISTS public.gettalabatid(_id uuid);
DROP FUNCTION IF EXISTS public.gettalabatexistanceorder(_referencenumber public.citext, _talabatordersource uuid);
DROP FUNCTION IF EXISTS public.gettalabatbranchids(_companyid uuid);
DROP FUNCTION IF EXISTS public.gettablecellproductbranchsalesvalues(_branchid uuid, _productid uuid, _fromtime timestamp without time zone, _totime timestamp without time zone);
DROP FUNCTION IF EXISTS public.gettablecellproductbranchsalescounts(_branchid uuid, _productid uuid, _fromtime timestamp without time zone, _totime timestamp without time zone);
DROP FUNCTION IF EXISTS public.gettablecellproductbranchsales(_branchid uuid, _productid uuid, _fromtime timestamp without time zone, _totime timestamp without time zone);
DROP FUNCTION IF EXISTS public.getsubattributevalues(_attributeid uuid[], _menuid uuid);
DROP FUNCTION IF EXISTS public.getstatuslookup(_companyid uuid);
DROP FUNCTION IF EXISTS public.getstatuscolor(_id uuid);
DROP FUNCTION IF EXISTS public.getstandardbranch_ai(_branchid uuid, _latitude double precision, _longtitude double precision);
DROP FUNCTION IF EXISTS public.getstandardbranch(_branchid uuid, _latitude double precision, _longtitude double precision);
DROP FUNCTION IF EXISTS public.getservices(_companyid uuid);
DROP FUNCTION IF EXISTS public.getselectedproductattribute(_id uuid);
DROP FUNCTION IF EXISTS public.getschedueledorders(_branchid uuid[]);
DROP FUNCTION IF EXISTS public.getrestaurntmenuwithbrandid(_companyid uuid, _brandid public.citext, _istaxable boolean);
DROP FUNCTION IF EXISTS public.getrestaurantparams(_companyid uuid);
DROP FUNCTION IF EXISTS public.getrestaurantintegrationrequestfortalabat(_companyid uuid);
DROP FUNCTION IF EXISTS public.getrestaurantentityid(_companyid uuid);
DROP FUNCTION IF EXISTS public.getrestaurantcustomerbycompnyid(_companyid uuid);
DROP FUNCTION IF EXISTS public.getrelatedproductsforproduct(_id uuid, _languagecode public.citext);
DROP FUNCTION IF EXISTS public.getqrcodesbycompanyandchannel(_companyid uuid, _channelid uuid);
DROP FUNCTION IF EXISTS public.getpromocodebyname(_promocode public.citext, _branchid uuid, _customerid uuid, _channel public.citext);
DROP FUNCTION IF EXISTS public.getpromocodebyid(_id uuid);
DROP FUNCTION IF EXISTS public.getproductunnestattributeidanswer(_id uuid, _menuid uuid, _channel public.citext);
DROP FUNCTION IF EXISTS public.getproductstax(_id uuid[], _sourceid uuid);
DROP FUNCTION IF EXISTS public.getproductstagsbyid(_productid uuid);
DROP TABLE IF EXISTS public.producttags;
DROP FUNCTION IF EXISTS public.getproductscategoryfordiscount(_categoryid uuid[]);
DROP FUNCTION IF EXISTS public.getproductsavailability(_id uuid[]);
DROP FUNCTION IF EXISTS public.getproductsattributes();
DROP FUNCTION IF EXISTS public.getproductsattribute(_productids uuid[]);
DROP FUNCTION IF EXISTS public.getproductsalesreport(_companyid uuid, _fromtime timestamp without time zone, _totime timestamp without time zone);
DROP FUNCTION IF EXISTS public.getproducts(_languagecode public.citext, _pagenumber integer, _pagesize integer);
DROP FUNCTION IF EXISTS public.getproductreports1();
DROP FUNCTION IF EXISTS public.getproductreports(_branchids uuid[], _source uuid[], _products uuid[], _fromtime timestamp without time zone, _totime timestamp without time zone);
DROP FUNCTION IF EXISTS public.getproductofcategorydto(_companyid uuid);
DROP FUNCTION IF EXISTS public.getproductofcategory(_companyid uuid);
DROP FUNCTION IF EXISTS public.getproductnotavailable(_id uuid);
DROP FUNCTION IF EXISTS public.getproductnamebyid(_id uuid);
DROP FUNCTION IF EXISTS public.getproductimages(_pagenumber integer, _pagesize integer);
DROP FUNCTION IF EXISTS public.getproductimage(_id uuid);
DROP FUNCTION IF EXISTS public.getproductidofcategory(_companyid uuid);
DROP FUNCTION IF EXISTS public.getproductdiscountishbekinterface(_productid uuid, _channel public.citext);
DROP FUNCTION IF EXISTS public.getproductdiscount(_productid uuid, _branchid uuid);
DROP FUNCTION IF EXISTS public.getproductbyids(_productids uuid[]);
DROP FUNCTION IF EXISTS public.getproductbycategorys(_id uuid, _languagecode public.citext);
DROP FUNCTION IF EXISTS public.getproductbycategoryandchanneltest(_categoryid uuid, _menuid uuid, _channel public.citext);
DROP FUNCTION IF EXISTS public.getproductbycategoryandchannelinterface(_categoryid uuid[], _menuid uuid, _channel public.citext);
DROP FUNCTION IF EXISTS public.getproductbycategoryandchannel(_categoryid uuid[], _menuid uuid, _channel public.citext);
DROP FUNCTION IF EXISTS public.getproductbycategory(_id uuid, _languagecode public.citext, _menuid uuid);
DROP FUNCTION IF EXISTS public.getproductbyarraycategory(_id uuid[]);
DROP FUNCTION IF EXISTS public.getproductbranchesreports(_companyid uuid, _fromtime timestamp without time zone, _totime timestamp without time zone);
DROP FUNCTION IF EXISTS public.getproductbranchavailable(_id uuid, _branchid uuid);
DROP FUNCTION IF EXISTS public.getproductbranchavailability(_productid uuid, _companyid uuid);
DROP FUNCTION IF EXISTS public.getproductavailabilitybyproductid(_id uuid);
DROP FUNCTION IF EXISTS public.getproductavailabilitybyid(_id uuid);
DROP FUNCTION IF EXISTS public.getproductavailabilities(_companyid uuid, _pagenumber integer, _pagesize integer);
DROP TABLE IF EXISTS public.productavailability;
DROP FUNCTION IF EXISTS public.getproductattributestreetest(_productid uuid, _branchid uuid);
DROP FUNCTION IF EXISTS public.getproductattributestreeforonline(_productid uuid, _branchid uuid, _channelname public.citext);
DROP FUNCTION IF EXISTS public.getproductattributestree(_productid uuid, _branchid uuid, _channelname public.citext);
DROP FUNCTION IF EXISTS public.getproductattributestree(_productid uuid);
DROP FUNCTION IF EXISTS public.getproductattributesastreetest(_productid uuid, _branchid uuid);
DROP FUNCTION IF EXISTS public.getproductattributesastreesave(_productid uuid);
DROP FUNCTION IF EXISTS public.getproductattributesastreeforonline(_productid uuid, _branchid uuid, _channelname public.citext);
DROP FUNCTION IF EXISTS public.getproductattributesastree2(_productid uuid);
DROP FUNCTION IF EXISTS public.getproductattributesastree1(_productid uuid);
DROP FUNCTION IF EXISTS public.getproductattributesastree(_productid uuid, _branchid uuid, _channelname public.citext);
DROP FUNCTION IF EXISTS public.getproductattributes(_productid uuid, _companyid uuid);
DROP FUNCTION IF EXISTS public.getproductattributenotavailablebyid(_id uuid);
DROP FUNCTION IF EXISTS public.getproductattributename(_childid uuid);
DROP FUNCTION IF EXISTS public.getproductattributelv(_id uuid, _branchid uuid);
DROP FUNCTION IF EXISTS public.getproductattributelevelx(_id uuid, _menuid uuid, _channel public.citext);
DROP FUNCTION IF EXISTS public.getproductattributelevel(_id uuid[], _menuid uuid, _channel public.citext);
DROP FUNCTION IF EXISTS public.getproductattributeishbekinterface(_productid uuid[], _menuid uuid, _channel public.citext);
DROP FUNCTION IF EXISTS public.getproductattributeidanswer(_id uuid, _menuid uuid, _channel public.citext);
DROP FUNCTION IF EXISTS public.getproductattributeanswer(_id uuid[], _menuid uuid, _channel public.citext);
DROP FUNCTION IF EXISTS public.getproductattribute(_productid uuid);
DROP FUNCTION IF EXISTS public.getproduct(_id uuid, _languagecode public.citext);
DROP FUNCTION IF EXISTS public.getpriceforproduct(_id uuid);
DROP FUNCTION IF EXISTS public.getposorderdata(_orderid uuid);
DROP FUNCTION IF EXISTS public.getposintegratoinid(_companyid uuid);
DROP FUNCTION IF EXISTS public.getpopupcompanyphone(_companyid uuid);
DROP FUNCTION IF EXISTS public.getpayments();
DROP TABLE IF EXISTS public.payment;
DROP FUNCTION IF EXISTS public.getpaymentonholdordersid(_id uuid);
DROP FUNCTION IF EXISTS public.getpaymentcredentialsid(_id uuid);
DROP FUNCTION IF EXISTS public.getpaymentbyidinterfaceishbek(_id uuid);
DROP FUNCTION IF EXISTS public.getpaymentbyid(_id uuid);
DROP FUNCTION IF EXISTS public.getorderviewfordelivery(_orderid uuid);
DROP FUNCTION IF EXISTS public.getorderview(_orderid uuid);
DROP FUNCTION IF EXISTS public.getorderstatussequence(_orderid uuid);
DROP FUNCTION IF EXISTS public.getorderstatuspossibilitiesbyid(_id uuid);
DROP FUNCTION IF EXISTS public.getorderstatuspossibilitiesbybranchidarray(_id uuid[]);
DROP FUNCTION IF EXISTS public.getorderstatuspossibilitiesbybranchid(_id uuid);
DROP TABLE IF EXISTS public.orderstatuspossibilities;
DROP FUNCTION IF EXISTS public.getorderstatushistory(_orderid uuid);
DROP FUNCTION IF EXISTS public.getorderstatuscolor(_id uuid);
DROP FUNCTION IF EXISTS public.getorderstatus(_id uuid);
DROP FUNCTION IF EXISTS public.getordersources(_id uuid);
DROP FUNCTION IF EXISTS public.getordersourcereport(_companyid uuid, _fromtime timestamp without time zone, _totime timestamp without time zone);
DROP FUNCTION IF EXISTS public.getordersource(_companyid uuid);
DROP FUNCTION IF EXISTS public.getordersource();
DROP FUNCTION IF EXISTS public.getordersound(_branchid uuid[]);
DROP TABLE IF EXISTS public.ordernotificationsettings;
DROP FUNCTION IF EXISTS public.getorderseq(_branchid uuid);
DROP FUNCTION IF EXISTS public.getordersbycustomer(_customerid uuid, _branchid uuid);
DROP FUNCTION IF EXISTS public.getordersbybranchid(_branchid uuid[]);
DROP FUNCTION IF EXISTS public.getordersbeforethreehours_ai(_customerid uuid, _companyid uuid);
DROP FUNCTION IF EXISTS public.getorderreportsjs(_branchids uuid[], _source uuid[], _fromtime timestamp without time zone, _totime timestamp without time zone, _customerphone public.citext);
DROP FUNCTION IF EXISTS public.getorderreports(_branchids uuid[], _source uuid[], _fromtime timestamp without time zone, _totime timestamp without time zone, _customerphone public.citext);
DROP FUNCTION IF EXISTS public.getorderproduct(_id uuid);
DROP FUNCTION IF EXISTS public.getorderprinters(_id uuid);
DROP FUNCTION IF EXISTS public.getordermethod(_id uuid);
DROP FUNCTION IF EXISTS public.getordermanaulprintersdefaultv2(_id uuid);
DROP FUNCTION IF EXISTS public.getordermanaulprinters2(_id uuid);
DROP FUNCTION IF EXISTS public.getorderinvoice(_orderid uuid);
DROP FUNCTION IF EXISTS public.getorderhistoryreportforoperation(_branchids uuid[], _fromtime timestamp without time zone, _totime timestamp without time zone, _customerphone public.citext);
DROP FUNCTION IF EXISTS public.getorderhistoryreport(_branchids uuid[], _fromtime timestamp without time zone, _totime timestamp without time zone, _customerphone public.citext, _pagenumber integer, _pagesize integer, _reference public.citext, _channelids uuid[]);
DROP FUNCTION IF EXISTS public.getorderhistoryid(_id uuid);
DROP TABLE IF EXISTS public.orderhistory;
DROP FUNCTION IF EXISTS public.getorderhistory(_branchids uuid[], _fromtime timestamp without time zone, _totime timestamp without time zone, _customerphone public.citext);
DROP FUNCTION IF EXISTS public.getorderfollowupviewbyorderid(_orderid uuid);
DROP FUNCTION IF EXISTS public.getorderfollowupviewbyid(_id uuid);
DROP FUNCTION IF EXISTS public.getorderfollowupviewbycustomerid2(_companyid uuid, _customerid uuid);
DROP FUNCTION IF EXISTS public.getorderfollowupviewbycustomerid(_companyid uuid, _pagenumber integer, _pagesize integer, _fromtime timestamp without time zone, _totime timestamp without time zone, _customerphone public.citext, _customerid uuid);
DROP FUNCTION IF EXISTS public.getorderfollowupviewbybranch(_id uuid);
DROP FUNCTION IF EXISTS public.getorderfollowupdetailsbyuser(_usertype public.citext);
DROP FUNCTION IF EXISTS public.getorderfollowupdetailsbyid(_id uuid);
DROP TABLE IF EXISTS public.orderfollowupdetails;
DROP FUNCTION IF EXISTS public.getorderdeliverycost(_addressid uuid, _branchid uuid);
DROP FUNCTION IF EXISTS public.getordercustomerinfobyphone(_phonenumber public.citext, _companyid uuid);
DROP FUNCTION IF EXISTS public.getordercurretnstatus(_orderid uuid);
DROP FUNCTION IF EXISTS public.getordercurrentstatus(_id uuid);
DROP FUNCTION IF EXISTS public.getorderconfigbycompanyid(_companyid uuid);
DROP FUNCTION IF EXISTS public.getorderbybranchid(_branchid uuid[]);
DROP FUNCTION IF EXISTS public.getorderbybranchandstatus(_branchid uuid, _status public.citext);
DROP FUNCTION IF EXISTS public.getoptionsforcareemdto(_productids uuid[]);
DROP FUNCTION IF EXISTS public.getoptions_careem(_productids uuid[], _branchid uuid);
DROP FUNCTION IF EXISTS public.getoptions(_pagenumber integer, _pagesize integer, _languagecode public.citext);
DROP FUNCTION IF EXISTS public.getoptions(_productids uuid[]);
DROP FUNCTION IF EXISTS public.getoptionchildrenidanswer(_menuid uuid, _channel public.citext, _attributeid uuid);
DROP FUNCTION IF EXISTS public.getoptionchildrenanswer(_menuid uuid, _channel public.citext, _attributeid uuid);
DROP FUNCTION IF EXISTS public.getoptionchildren_careem(_attributeid uuid);
DROP FUNCTION IF EXISTS public.getoptionchildren(_attributeid uuid);
DROP FUNCTION IF EXISTS public.getoption(_id uuid, _languagecode public.citext);
DROP FUNCTION IF EXISTS public.getoperationalhoursforbranch_careem(_branchid uuid);
DROP FUNCTION IF EXISTS public.getoperationalhoursforbranch(_branchid uuid);
DROP FUNCTION IF EXISTS public.getonlineusersbyphone(_phone public.citext, _companyid uuid);
DROP FUNCTION IF EXISTS public.getonlineusers(_id uuid);
DROP FUNCTION IF EXISTS public.getonlineuserotpbyid(_id uuid);
DROP FUNCTION IF EXISTS public.getoldprinter(_jobid uuid);
DROP FUNCTION IF EXISTS public.getoffersimages(_companyid uuid);
DROP FUNCTION IF EXISTS public.getofferlogo(_companyid uuid);
DROP FUNCTION IF EXISTS public.getnowpromocode(_promocode public.citext, _branchid uuid, _customerid uuid, _channelid uuid);
DROP FUNCTION IF EXISTS public.getnowdisountsforagent(_productid uuid, _branchid uuid);
DROP FUNCTION IF EXISTS public.getnowdiscountsinfo(_timestamp timestamp without time zone);
DROP TABLE IF EXISTS public.discountinfo;
DROP FUNCTION IF EXISTS public.getnowdiscountsfortotalbybranchid(_branchid uuid, _channelid uuid);
DROP FUNCTION IF EXISTS public.getnowdiscountsforproducts(_productid uuid, _branchid uuid, _channelid uuid);
DROP FUNCTION IF EXISTS public.getnowdiscountsfordeliverybybranchid(_branchid uuid, _channelid uuid);
DROP FUNCTION IF EXISTS public.getnowdiscountsforattribute(_attributeid uuid, _branchid uuid, _channelid uuid);
DROP FUNCTION IF EXISTS public.getnowdiscountsbytypeonline(_branchid uuid, _channelid uuid, _discounttype public.citext);
DROP FUNCTION IF EXISTS public.getnowcartdiscountsonline(_branchid uuid, _isonline boolean);
DROP FUNCTION IF EXISTS public.getnotificationforcompany(_companyid uuid);
DROP FUNCTION IF EXISTS public.getnotificationforbranch(_branchid uuid);
DROP FUNCTION IF EXISTS public.getnotification(_companyid uuid);
DROP FUNCTION IF EXISTS public.getnextstatus(_id uuid);
DROP FUNCTION IF EXISTS public.getnewcompanycities(_companyid uuid);
DROP FUNCTION IF EXISTS public.getmenuviews(_companyid uuid);
DROP FUNCTION IF EXISTS public.getmenujson(_menuid uuid);
DROP FUNCTION IF EXISTS public.getmenucategoryids_careem(_menuid uuid);
DROP FUNCTION IF EXISTS public.getmenucategoryids(_menuid uuid);
DROP FUNCTION IF EXISTS public.getmenuai(_menuid uuid);
DROP FUNCTION IF EXISTS public.getmenu(_id uuid);
DROP FUNCTION IF EXISTS public.getmarketperformancereport(_companyid uuid, _fromtime timestamp without time zone, _totime timestamp without time zone);
DROP FUNCTION IF EXISTS public.getmanualattributevaluesforproudct(_id uuid, _branchid uuid);
DROP FUNCTION IF EXISTS public.getlookupsbytype(_type public.citext);
DROP FUNCTION IF EXISTS public.getlookupname(_id uuid);
DROP FUNCTION IF EXISTS public.getlocalizationvalue(_languagecode public.citext, _key public.citext, _objectid uuid, _type integer);
DROP FUNCTION IF EXISTS public.getlocalizationvalue(_languagecode public.citext, _objectid uuid);
DROP FUNCTION IF EXISTS public.getlocaldeliveryname(_branchid uuid);
DROP FUNCTION IF EXISTS public.getlatestbranch(_companyid uuid);
DROP FUNCTION IF EXISTS public.getlastpromocodeaddedbycompanyid(_companyid uuid);
DROP FUNCTION IF EXISTS public.getlastaddeddiscountbycompanyid(_companyid uuid);
DROP FUNCTION IF EXISTS public.getlanguageid(_languagecode public.citext);
DROP FUNCTION IF EXISTS public.getjsonproductreport(_companyid uuid, _fromtime timestamp without time zone, _totime timestamp without time zone);
DROP FUNCTION IF EXISTS public.getjsonhourlyreportfordashboard(_branchids uuid[], _channels uuid[], _from timestamp without time zone, _to timestamp without time zone);
DROP FUNCTION IF EXISTS public.getjsondailyreportfordashboard(_branchids uuid[], _channels uuid[], _from timestamp without time zone, _to timestamp without time zone);
DROP FUNCTION IF EXISTS public.getjobid(_id uuid);
DROP FUNCTION IF EXISTS public.getitemsforcareemdto(_categoryids uuid[], _branchid uuid);
DROP FUNCTION IF EXISTS public.getitems_careem(_categoryids uuid[], _branchid uuid);
DROP FUNCTION IF EXISTS public.getitems(_categoryids uuid[], _menuid uuid);
DROP FUNCTION IF EXISTS public.getishbekorderid(_talabatorderid public.citext);
DROP FUNCTION IF EXISTS public.getishbekcities();
DROP FUNCTION IF EXISTS public.getishbekareas(_cityid integer);
DROP FUNCTION IF EXISTS public.getisfirststatus(_id uuid);
DROP FUNCTION IF EXISTS public.getintegrationrequest(_companyid uuid);
DROP FUNCTION IF EXISTS public.getintegrationorders(_branchid uuid);
DROP FUNCTION IF EXISTS public.getintegrationcompanybyid(_id uuid);
DROP FUNCTION IF EXISTS public.getintegrationcompany();
DROP TABLE IF EXISTS public.integrationcompany;
DROP FUNCTION IF EXISTS public.getimagepathurl(_image public.citext);
DROP FUNCTION IF EXISTS public.getimagepath_careem(_image public.citext);
DROP FUNCTION IF EXISTS public.getimagepath(_image public.citext);
DROP FUNCTION IF EXISTS public.gethourlyreportfordashboard(_branchids uuid[], _channels uuid[], _from timestamp without time zone, _to timestamp without time zone);
DROP FUNCTION IF EXISTS public.getgroupsforcareemdto(_productids uuid[]);
DROP FUNCTION IF EXISTS public.getgroups_careem(_productids uuid[]);
DROP FUNCTION IF EXISTS public.getgroups(_productids uuid[]);
DROP FUNCTION IF EXISTS public.getglobalattributestree(_companyid uuid);
DROP FUNCTION IF EXISTS public.getglobalattributes(_companyid uuid);
DROP FUNCTION IF EXISTS public.getfulldashboardview(_reporttype public.citext, _branchids uuid[], _channelids uuid[], _from timestamp without time zone, _to timestamp without time zone);
DROP FUNCTION IF EXISTS public.getfoodaggsintegrations(_companyid uuid);
DROP FUNCTION IF EXISTS public.getfirststatusforbranch(_branchid uuid);
DROP FUNCTION IF EXISTS public.getfeesbylabelpagination(_companyid uuid, _pagenumber integer, _pagesize integer);
DROP FUNCTION IF EXISTS public.getfeesbylabel(_companyid uuid);
DROP FUNCTION IF EXISTS public.getelicashcredentials(_companyid uuid);
DROP FUNCTION IF EXISTS public.getdistance(_customerid uuid, _lat1 double precision, _lon1 double precision);
DROP FUNCTION IF EXISTS public.getdiscountproductbybranch_ai(_branchid uuid);
DROP FUNCTION IF EXISTS public.getdiscountiteminfo(_tbalename public.citext, _id uuid, _branchid uuid, _channel public.citext);
DROP FUNCTION IF EXISTS public.getdiscountinfobyid(_discountid uuid);
DROP FUNCTION IF EXISTS public.getdiscountinfo(_branchid uuid, _channel public.citext);
DROP FUNCTION IF EXISTS public.getdiscountinfo(_branchid uuid, _channelid uuid);
DROP FUNCTION IF EXISTS public.getdiscountdelivery(_branchid uuid, _channel public.citext);
DROP FUNCTION IF EXISTS public.getdiscountcarttotal(_branchid uuid, _channel public.citext);
DROP FUNCTION IF EXISTS public.getdiscountbyid(_id uuid);
DROP FUNCTION IF EXISTS public.getdeliveryname(_id uuid);
DROP FUNCTION IF EXISTS public.getdeliverydashboartreportpie(_branchids uuid[], _channels uuid[], _from timestamp without time zone, _to timestamp without time zone);
DROP FUNCTION IF EXISTS public.getdeliverycompanyreport(_companyid uuid, _fromtime timestamp without time zone, _totime timestamp without time zone);
DROP FUNCTION IF EXISTS public.getdeliverycompanynameforreport(_id uuid);
DROP FUNCTION IF EXISTS public.getdeliverycompanynameforpos(_id uuid);
DROP FUNCTION IF EXISTS public.getdeliverycompanyname(_id uuid);
DROP FUNCTION IF EXISTS public.getdeliverycompanyid(_id uuid);
DROP FUNCTION IF EXISTS public.getdeliverycompanyforbranch(_branchid uuid);
DROP FUNCTION IF EXISTS public.getdeliverycompanybyid(_id uuid);
DROP TABLE IF EXISTS public.deliverycompany;
DROP FUNCTION IF EXISTS public.getdeliverycompaniesfordeliveryservice();
DROP FUNCTION IF EXISTS public.getdeliverycompanies();
DROP FUNCTION IF EXISTS public.getdeletedimages();
DROP FUNCTION IF EXISTS public.getdelayedordersbybranchid(_branchid uuid);
DROP FUNCTION IF EXISTS public.getdelayedorders();
DROP TABLE IF EXISTS public.delayedorders;
DROP FUNCTION IF EXISTS public.getdashboardlinechart(_reporttype public.citext, _branchids uuid[], _from timestamp without time zone, _to timestamp without time zone);
DROP FUNCTION IF EXISTS public.getdashboardchart(_reporttype public.citext, _branchids uuid[], _from timestamp without time zone, _to timestamp without time zone);
DROP FUNCTION IF EXISTS public.getdailyreportfordashboard(_branchids uuid[], _channels uuid[], _from timestamp without time zone, _to timestamp without time zone);
DROP FUNCTION IF EXISTS public.getcustomrdetailsbycompanyidandcustomerid(_customerid uuid, _companyid uuid);
DROP FUNCTION IF EXISTS public.getcustomerstatuslog(_customerid uuid, _companyid uuid);
DROP FUNCTION IF EXISTS public.getcustomerscompanydetailsbyid(_id uuid);
DROP FUNCTION IF EXISTS public.getcustomersbycompanyid(_id uuid, _pagesize integer, _pagenumber integer);
DROP FUNCTION IF EXISTS public.getcustomers(_companyid uuid, _status integer, _pagenumber integer, _pagesize integer, _searchterm public.citext);
DROP FUNCTION IF EXISTS public.getcustomers(_companyid uuid, _status integer, _pagenumber integer, _pagesize integer);
DROP FUNCTION IF EXISTS public.getcustomerregistrationids(_companyid uuid, _customerid uuid);
DROP FUNCTION IF EXISTS public.getcustomerpointlog(_customerid uuid, _companyid uuid);
DROP FUNCTION IF EXISTS public.getcustomerorderscompanybychannel(_customerid uuid, _channel public.citext, _companyid uuid);
DROP FUNCTION IF EXISTS public.getcustomerorderscompanyallchannel(_customerid uuid, _companyid uuid);
DROP FUNCTION IF EXISTS public.getcustomerorders(_customerid uuid, _branchid uuid);
DROP FUNCTION IF EXISTS public.getcustomerorderreport(_companyid uuid, _fromtime timestamp without time zone, _totime timestamp without time zone);
DROP FUNCTION IF EXISTS public.getcustomerlastorder(_customerid uuid);
DROP TABLE IF EXISTS public."order";
DROP FUNCTION IF EXISTS public.getcustomerinfobyidinterfaceapi(_id uuid);
DROP FUNCTION IF EXISTS public.getcustomerinfobyid_ai(_id uuid);
DROP FUNCTION IF EXISTS public.getcustomerinfobyid(_id uuid);
DROP FUNCTION IF EXISTS public.getcustomeridsbyphonenumbers(_phonenumbers public.citext[]);
DROP FUNCTION IF EXISTS public.getcustomerheaderstatus(_companyid uuid);
DROP FUNCTION IF EXISTS public.getcustomerdetailscompany(_customerid uuid[]);
DROP FUNCTION IF EXISTS public.getcustomerdetailsbyphone_ai(_phonenumber public.citext);
DROP FUNCTION IF EXISTS public.getcustomerdetails(_phonenumber public.citext);
DROP FUNCTION IF EXISTS public.getcustomerconversation(_phonenumber public.citext);
DROP TABLE IF EXISTS public.chatconversation;
DROP FUNCTION IF EXISTS public.getcustomercompanyordersforonline(_customerid uuid, _companyid uuid);
DROP FUNCTION IF EXISTS public.getcustomercompanyorders_ai(_customerid uuid, _companyid uuid);
DROP FUNCTION IF EXISTS public.getcustomercompanyorders(_customerid uuid, _companyid uuid);
DROP FUNCTION IF EXISTS public.getcustomercompanydetails(_phonenumber public.citext, _companyid uuid);
DROP FUNCTION IF EXISTS public.getcustomercompanycheck(_phonenumber public.citext, _companyid uuid);
DROP FUNCTION IF EXISTS public.getcustomercheck(_phonenumber public.citext);
DROP FUNCTION IF EXISTS public.getcustomerbyid(_id uuid);
DROP FUNCTION IF EXISTS public.getcustomerbycategory(_companyid uuid, _id integer[]);
DROP FUNCTION IF EXISTS public.getcustomerbillingdetail(_customerid uuid);
DROP TABLE IF EXISTS public.customerbillingdetails;
DROP FUNCTION IF EXISTS public.getcustomeraddressreports(_companyid uuid, _fromtime timestamp without time zone, _totime timestamp without time zone);
DROP FUNCTION IF EXISTS public.getcustomeraddressreports(_fromtime timestamp without time zone, _totime timestamp without time zone);
DROP FUNCTION IF EXISTS public.getcustomeraddressgeo();
DROP FUNCTION IF EXISTS public.getcustomeraddressforonlineorder(_customerid uuid);
DROP FUNCTION IF EXISTS public.getcustomeraddressesandinfobyphone(_phonenumber public.citext, _companyid uuid, _channelid uuid);
DROP FUNCTION IF EXISTS public.getcustomeraddresses(_customerid uuid, _companyid uuid, _channelid uuid);
DROP FUNCTION IF EXISTS public.getcustomeraddressbyphonenumber(_phonenumber public.citext);
DROP FUNCTION IF EXISTS public.getcustomeraddressbycoords(_customerid uuid, _lat numeric, _long numeric);
DROP FUNCTION IF EXISTS public.getcustomeraddressbycompany(_companyid uuid, _addressid uuid, _customerid uuid);
DROP FUNCTION IF EXISTS public.getcustomeraddress(_customerid uuid);
DROP FUNCTION IF EXISTS public.getcurrentstatus(_orderid uuid);
DROP FUNCTION IF EXISTS public.getcoupons(_pagenumber integer, _pagesize integer);
DROP FUNCTION IF EXISTS public.getcouponbyid(_id uuid);
DROP TABLE IF EXISTS public.coupon;
DROP FUNCTION IF EXISTS public.getcomplainsubcategorybyid(_referenceid uuid);
DROP FUNCTION IF EXISTS public.getcomplainsubcategories(_categoryid uuid);
DROP FUNCTION IF EXISTS public.getcomplainsubcategories();
DROP FUNCTION IF EXISTS public.getcomplaincategoriestree();
DROP FUNCTION IF EXISTS public.getcomplaincategories();
DROP TABLE IF EXISTS public.namelookup;
DROP FUNCTION IF EXISTS public.getcomplainbyid(_customerid uuid);
DROP FUNCTION IF EXISTS public.getcompanywhatsapptemplatemessage(_id uuid);
DROP FUNCTION IF EXISTS public.getcompanywhatsapptemplate(_id uuid);
DROP FUNCTION IF EXISTS public.getcompanywaapitemplate(_tempname public.citext);
DROP TABLE IF EXISTS public.whatsapptemplate;
DROP FUNCTION IF EXISTS public.getcompanyuserview(_companyid uuid);
DROP FUNCTION IF EXISTS public.getcompanysubarea(_companyid uuid, _areaid bigint);
DROP FUNCTION IF EXISTS public.getcompanysubandareasexceltemplatedata(_branchid uuid);
DROP FUNCTION IF EXISTS public.getcompanyservices(_companyid uuid);
DROP FUNCTION IF EXISTS public.getcompanyserviceid(_companyid uuid, _serviceid uuid);
DROP FUNCTION IF EXISTS public.getcompanyreportsbycompanyid(_id uuid);
DROP TABLE IF EXISTS public.companyreports;
DROP FUNCTION IF EXISTS public.getcompanyproductswithoutvalidation(_companyid uuid);
DROP TABLE IF EXISTS public.product;
DROP FUNCTION IF EXISTS public.getcompanyposintegrationbycompanyid(_companyid uuid);
DROP FUNCTION IF EXISTS public.getcompanyposintegration(_companyid uuid);
DROP FUNCTION IF EXISTS public.getcompanypohneidserivce(_id uuid);
DROP FUNCTION IF EXISTS public.getcompanypayment(_companyid uuid, _paymenttype public.citext);
DROP FUNCTION IF EXISTS public.getcompanyofferimage(_companyid uuid);
DROP FUNCTION IF EXISTS public.getcompanynewaddress(keyword public.citext, cityid public.citext, _companyid uuid);
DROP FUNCTION IF EXISTS public.getcompanynamefortalabat(_id uuid);
DROP FUNCTION IF EXISTS public.getcompanyname(_id uuid);
DROP FUNCTION IF EXISTS public.getcompanymenuurl_ai(_companyid uuid);
DROP FUNCTION IF EXISTS public.getcompanymenuurl(_companyid uuid);
DROP FUNCTION IF EXISTS public.getcompanymenu_ai(_companyid uuid);
DROP FUNCTION IF EXISTS public.getcompanylogo(_id uuid);
DROP FUNCTION IF EXISTS public.getcompanylastorder(_companyid uuid, _ordersource uuid);
DROP FUNCTION IF EXISTS public.getcompanylanguages(_companyid uuid);
DROP FUNCTION IF EXISTS public.getcompanyinformationbyid(_companyid uuid, _languagecode public.citext);
DROP FUNCTION IF EXISTS public.getcompanyinfobyid(_id uuid, _languagecode public.citext);
DROP FUNCTION IF EXISTS public.getcompanyidbyphonenumber(_phonenumber public.citext);
DROP FUNCTION IF EXISTS public.getcompanyidbyphone(_phonenumber public.citext);
DROP FUNCTION IF EXISTS public.getcompanyidbyinstanceid(_instanceid integer);
DROP FUNCTION IF EXISTS public.getcompanyidbybranchid(_branchid uuid);
DROP FUNCTION IF EXISTS public.getcompanyid(_companyname public.citext);
DROP FUNCTION IF EXISTS public.getcompanyfirstorder(_companyid uuid, _ordersource uuid);
DROP FUNCTION IF EXISTS public.getcompanyfaq_ai(_companyid uuid);
DROP FUNCTION IF EXISTS public.getcompanyfaq(_companyid uuid);
DROP FUNCTION IF EXISTS public.getcompanydeletedbranches(_companyid uuid);
DROP FUNCTION IF EXISTS public.getcompanycutomersbycompanyforddl(_companyid uuid);
DROP FUNCTION IF EXISTS public.getcompanycustomerorders(_customerid uuid, _companyid uuid);
DROP FUNCTION IF EXISTS public.getcompanycredentailsbyid(_id uuid);
DROP TABLE IF EXISTS public.restaurantpaymentcredentials;
DROP FUNCTION IF EXISTS public.getcompanycities(_companyid uuid);
DROP FUNCTION IF EXISTS public.getcompanychatservice(_companyid uuid);
DROP FUNCTION IF EXISTS public.getcompanychannels(_companyid uuid);
DROP FUNCTION IF EXISTS public.getcompanychannelnotification(_id uuid);
DROP FUNCTION IF EXISTS public.getcompanycategorybyid(_id uuid, _languagecode public.citext);
DROP FUNCTION IF EXISTS public.getcompanycategories(_companyid uuid);
DROP FUNCTION IF EXISTS public.getcompanybyphone_ai(_phone public.citext);
DROP FUNCTION IF EXISTS public.getcompanybyid(_id uuid);
DROP FUNCTION IF EXISTS public.getcompanybycategoryid(_id uuid);
DROP FUNCTION IF EXISTS public.getcompanyaddress(keyword public.citext, cityid uuid, _companyid uuid);
DROP FUNCTION IF EXISTS public.getcompaniesinfo(_languagecode public.citext, _pagenumber integer, _pagesize integer);
DROP FUNCTION IF EXISTS public.getcompaniesbranchs();
DROP FUNCTION IF EXISTS public.getcompaniesbasedondeliverycompanyid(delivery_company_id uuid);
DROP FUNCTION IF EXISTS public.getcompanies_ai();
DROP FUNCTION IF EXISTS public.getcompanies(pagenumber integer, pagesize integer);
DROP TABLE IF EXISTS public.company;
DROP FUNCTION IF EXISTS public.getclientintegrationbyintcompanyid(_id uuid);
DROP FUNCTION IF EXISTS public.getclientintegrationbycompanyid(_id uuid);
DROP FUNCTION IF EXISTS public.getcitiesandareasexceltemplatedata(_cityid integer, _companyid uuid);
DROP FUNCTION IF EXISTS public.getcities(_languagecode public.citext, pagenumber integer, pagesize integer);
DROP FUNCTION IF EXISTS public.getcheckauthcustomer(_id uuid, _companyid uuid);
DROP FUNCTION IF EXISTS public.getchanneltopsellingitem(_companyid uuid, _channel public.citext);
DROP FUNCTION IF EXISTS public.getchannelsformenu(_companyid uuid);
DROP FUNCTION IF EXISTS public.getchannelsfordiscount();
DROP FUNCTION IF EXISTS public.getchannelproductname(_id uuid);
DROP FUNCTION IF EXISTS public.getchannelproductishbekidbyposid(_id public.citext);
DROP FUNCTION IF EXISTS public.getchannelorderview(_orderid uuid);
DROP FUNCTION IF EXISTS public.getchannelmenuviews(_companyid uuid, _channel public.citext);
DROP FUNCTION IF EXISTS public.getchannelmenucategory(_branchid uuid, _channel public.citext);
DROP FUNCTION IF EXISTS public.getchannelchart(_branchids uuid[], _channels uuid[], _from timestamp without time zone, _to timestamp without time zone);
DROP FUNCTION IF EXISTS public.getchannelbyname(_channel public.citext);
DROP FUNCTION IF EXISTS public.getcategorytag();
DROP FUNCTION IF EXISTS public.getcategoryproducts(_categoryids uuid[]);
DROP FUNCTION IF EXISTS public.getcategoryname(_id uuid);
DROP FUNCTION IF EXISTS public.getcategorycustomer();
DROP FUNCTION IF EXISTS public.getcategorybymenuidishbekinterface(_id uuid, _channel public.citext);
DROP FUNCTION IF EXISTS public.getcategorybymenuid(_id uuid, _languagecode public.citext);
DROP FUNCTION IF EXISTS public.getcategorybyid(_id uuid);
DROP FUNCTION IF EXISTS public.getcategoryavailableitemsfrommenunew(_categoryid uuid, _branchid uuid);
DROP FUNCTION IF EXISTS public.getcategoryavailableitemsfrommenuforagent(_categoryid uuid, _branchid uuid, _channelid public.citext);
DROP FUNCTION IF EXISTS public.getcategoryavailableitemsfrommenu6(_categoryid uuid);
DROP FUNCTION IF EXISTS public.getcategoryavailableitemsfrommenu1(_categoryid uuid);
DROP FUNCTION IF EXISTS public.getcategoryavailableitemsfrommenu(_categoryid uuid, _branchid uuid);
DROP FUNCTION IF EXISTS public.getcategoryavailableitemsfrommenu(_categoryid uuid);
DROP FUNCTION IF EXISTS public.getcategory(_id uuid);
DROP FUNCTION IF EXISTS public.getcategoriesname(_ids uuid[]);
DROP FUNCTION IF EXISTS public.getcategoriesforcareemdto(_menuid uuid);
DROP FUNCTION IF EXISTS public.getcategories_careem(_menuid uuid);
DROP FUNCTION IF EXISTS public.getcategories(_menuid uuid);
DROP FUNCTION IF EXISTS public.getcatalogforcareemdto(_branchid uuid);
DROP FUNCTION IF EXISTS public.getcatalog_careem(_branchid uuid);
DROP FUNCTION IF EXISTS public.getcatalog(_menuid uuid);
DROP FUNCTION IF EXISTS public.getcallsubstatuses(_parentstatus public.citext);
DROP FUNCTION IF EXISTS public.getcallreport(_id uuid, _from timestamp without time zone, _to timestamp without time zone);
DROP FUNCTION IF EXISTS public.getcallparentstatuses();
DROP FUNCTION IF EXISTS public.getbrandsmenus(_companyid uuid);
DROP FUNCTION IF EXISTS public.getbrandsid(_companyid uuid);
DROP FUNCTION IF EXISTS public.getbranchtemplateforpiad(_id uuid);
DROP FUNCTION IF EXISTS public.getbranchtemplatebyid(_id uuid, _type public.citext);
DROP FUNCTION IF EXISTS public.getbranchsalesexcelreport(_companyid uuid, _fromtime timestamp without time zone, _totime timestamp without time zone);
DROP FUNCTION IF EXISTS public.getbranchprintertemplate(_branchid uuid, _type public.citext);
DROP TABLE IF EXISTS public.branchtemplate;
DROP FUNCTION IF EXISTS public.getbranchprintersettings(_id uuid);
DROP FUNCTION IF EXISTS public.getbranchprinterscategory(_branchid uuid);
DROP FUNCTION IF EXISTS public.getbranchprinters(_branchid uuid);
DROP FUNCTION IF EXISTS public.getbranchprintercategory(_id uuid);
DROP FUNCTION IF EXISTS public.getbranchprinter(_branchid uuid);
DROP FUNCTION IF EXISTS public.getbranchorderhistory(_branchids uuid[], _pagenumber integer, _pagesize integer);
DROP FUNCTION IF EXISTS public.getbranchorderhistory(_branchids uuid[]);
DROP FUNCTION IF EXISTS public.getbranchnamethathavedeliverycompany();
DROP FUNCTION IF EXISTS public.getbranchname(_id uuid);
DROP FUNCTION IF EXISTS public.getbranchmenuintegrationbycompanyid(_id uuid);
DROP FUNCTION IF EXISTS public.getbranchmenuforcareemobject_careem(_branchid uuid);
DROP FUNCTION IF EXISTS public.getbranchmenuforcareemobject(_branchid uuid);
DROP FUNCTION IF EXISTS public.getbranchmenuforcareemjson_careem(_branchid uuid);
DROP FUNCTION IF EXISTS public.getbranchmenuforcareemjson(_branchid uuid);
DROP FUNCTION IF EXISTS public.getbranchinfoformobile(branchids uuid[]);
DROP FUNCTION IF EXISTS public.getbranchidorderid(_orderid uuid);
DROP FUNCTION IF EXISTS public.getbranchidbytalabatorderid(_talabatorderid public.citext);
DROP FUNCTION IF EXISTS public.getbranchforspecificcompanies(_companyids uuid[]);
DROP FUNCTION IF EXISTS public.getbranchfordistancemainbybranch(_branchid uuid, _latitude double precision, _longtitude double precision);
DROP FUNCTION IF EXISTS public.getbranchfordistancemain_ai(_companyid uuid, _latitude double precision, _longtitude double precision);
DROP FUNCTION IF EXISTS public.getbranchfordistancemain(_companyid uuid, _latitude double precision, _longtitude double precision);
DROP FUNCTION IF EXISTS public.getbranchfordistance_ai(_companyid uuid, _latitude double precision, _longtitude double precision);
DROP FUNCTION IF EXISTS public.getbranchfordistance(_companyid uuid, _latitude double precision, _longtitude double precision);
DROP FUNCTION IF EXISTS public.getbranchforcategorybymenuidandchannel(_id uuid, _callid uuid, _channel public.citext);
DROP FUNCTION IF EXISTS public.getbranchforcategorybymenuid(_id uuid, _callid uuid);
DROP FUNCTION IF EXISTS public.getbranchforcalculater(_companyid uuid, _latitude double precision, _longtitude double precision);
DROP FUNCTION IF EXISTS public.getbranchforaddressbylabel(_addressid uuid, _companyid uuid);
DROP FUNCTION IF EXISTS public.getbranchforaddress(_addressid uuid, _companyid uuid);
DROP FUNCTION IF EXISTS public.getbranchesname(_id uuid[]);
DROP FUNCTION IF EXISTS public.getbranchesmappedtoashyaeebymenuid(_menuid uuid);
DROP FUNCTION IF EXISTS public.getbranchesids(_menuid uuid, _channelid uuid);
DROP FUNCTION IF EXISTS public.getbranchesforcompanyoperation(_companyid uuid[]);
DROP FUNCTION IF EXISTS public.getbranchesforcompanynew(_companyid uuid);
DROP FUNCTION IF EXISTS public.getbranchesforcompany(_companyid uuid);
DROP FUNCTION IF EXISTS public.getbranchesbylabeladdresses(_companyid uuid, _areacodeid integer, _cityid integer, _areaid integer);
DROP FUNCTION IF EXISTS public.getbranches(pagenumber integer, pagesize integer);
DROP FUNCTION IF EXISTS public.getbranchebranchid(_branchid uuid);
DROP FUNCTION IF EXISTS public.getbranchdeliveryview(_companyid uuid);
DROP FUNCTION IF EXISTS public.getbranchdeliverymethodsforonlineordering(_id uuid);
DROP FUNCTION IF EXISTS public.getbranchdeliverymethods(_id uuid);
DROP FUNCTION IF EXISTS public.getbranchdeliveryforview(_branchid uuid, _companyid uuid);
DROP FUNCTION IF EXISTS public.getbranchdeliveryfeesbylabel(_companyid uuid);
DROP FUNCTION IF EXISTS public.getbranchdeliverycompany(_companyid uuid);
DROP FUNCTION IF EXISTS public.getbranchdeliverychargenew(_id uuid);
DROP FUNCTION IF EXISTS public.getbranchdeliverychargelabel(_companyid uuid, _pagenumber integer, _pagesize integer);
DROP FUNCTION IF EXISTS public.getbranchdeliverycharge(_branchid uuid);
DROP FUNCTION IF EXISTS public.getbranchdeliverycalculatorpriceforonlineordering(_branchid uuid, _distance numeric);
DROP FUNCTION IF EXISTS public.getbranchdeliverycalculatorprice_ai(_branchid uuid, _distance numeric);
DROP FUNCTION IF EXISTS public.getbranchdeliverycalculatorprice(_branchid uuid, _distance numeric);
DROP FUNCTION IF EXISTS public.getbranchchartdashboardreport(_branchids uuid[], _channels uuid[], _from timestamp without time zone, _to timestamp without time zone);
DROP FUNCTION IF EXISTS public.getbranchcategoriesfrommenuforagent(_branchid uuid, _channelid public.citext);
DROP FUNCTION IF EXISTS public.getbranchcategoriesfrommenu4(_branchid uuid);
DROP FUNCTION IF EXISTS public.getbranchcategoriesfrommenu(_branchid uuid);
DROP FUNCTION IF EXISTS public.getbranchcategories(_branchid uuid[]);
DROP FUNCTION IF EXISTS public.getbranchcashiername(_ids uuid[]);
DROP FUNCTION IF EXISTS public.getbranchbyname(_name public.citext);
DROP FUNCTION IF EXISTS public.getbranchbyid(_id uuid);
DROP FUNCTION IF EXISTS public.getbranchbybranchid(_branchid uuid);
DROP TABLE IF EXISTS public.branch;
DROP FUNCTION IF EXISTS public.getbranchbyarrayproduct(_id uuid[]);
DROP FUNCTION IF EXISTS public.getbranchavailabilitybycatgeory(_id uuid, _callid uuid, _channel public.citext);
DROP FUNCTION IF EXISTS public.getbranchavailability(_menuid uuid, _objectid uuid);
DROP FUNCTION IF EXISTS public.getbranchandpricebasedoncoordinatesaddress(_companyid uuid, _latitude double precision, _longitude double precision, _iscalc boolean, _isintegration boolean);
DROP FUNCTION IF EXISTS public.getbranchactive(_addressid uuid);
DROP FUNCTION IF EXISTS public.getblackliststatuses();
DROP FUNCTION IF EXISTS public.getblacklistcustomers(_id uuid);
DROP FUNCTION IF EXISTS public.getblacklistcustomer(_companyid uuid, _pagenumber integer, _pagesize integer, _fromtime timestamp without time zone, _totime timestamp without time zone, _customerphone public.citext);
DROP FUNCTION IF EXISTS public.getbenefeciaries();
DROP TABLE IF EXISTS public.benefeciary;
DROP FUNCTION IF EXISTS public.getattributevaluesforproudct(_id uuid);
DROP FUNCTION IF EXISTS public.getattributevalues(_attributeid uuid[]);
DROP FUNCTION IF EXISTS public.getattributequestionposinfo(_id public.citext, _productid uuid);
DROP FUNCTION IF EXISTS public.getattributepricebyid(_id uuid, _channel public.citext, _tbalename public.citext);
DROP FUNCTION IF EXISTS public.getattributeposinfo(_id public.citext, _attributeid uuid);
DROP FUNCTION IF EXISTS public.getattributeposinfo(_id public.citext);
DROP FUNCTION IF EXISTS public.getattributeparent(_id uuid);
DROP FUNCTION IF EXISTS public.getattributeoptionids_careem(_attributeid uuid);
DROP FUNCTION IF EXISTS public.getattributeoptionids(_attributeid uuid);
DROP FUNCTION IF EXISTS public.getattributename(_id uuid);
DROP FUNCTION IF EXISTS public.getattributebyid(_id uuid);
DROP TABLE IF EXISTS public.productattribute;
DROP FUNCTION IF EXISTS public.getattrbiuteiscountishbekinterface(_id uuid, _channel public.citext);
DROP FUNCTION IF EXISTS public.getashyaeestatusmenubycompanyid(_companyid uuid);
DROP FUNCTION IF EXISTS public.getashyaeeorderproductattributejson(_attributeid uuid, _quantity integer, _price numeric);
DROP FUNCTION IF EXISTS public.getashyaeeorderproductattribute(_attributeid uuid, _quantity integer, _price numeric);
DROP FUNCTION IF EXISTS public.getallpromocodebycompanyid(_companyid uuid);
DROP FUNCTION IF EXISTS public.getallprinters();
DROP TABLE IF EXISTS public.printers;
DROP FUNCTION IF EXISTS public.getallsources();
DROP FUNCTION IF EXISTS public.getallpopupcompanyphone();
DROP FUNCTION IF EXISTS public.getallmenu(_pagenumber integer, _pagesize integer);
DROP FUNCTION IF EXISTS public.getallishbekmapzones();
DROP FUNCTION IF EXISTS public.getallishbekareas();
DROP FUNCTION IF EXISTS public.getalldiscountsbycompanyid(_companyid uuid);
DROP FUNCTION IF EXISTS public.getallcompanysubarea(_companyid uuid);
DROP FUNCTION IF EXISTS public.getallcompanyfaqbyid(_id uuid);
DROP FUNCTION IF EXISTS public.getallcompanyfaq(_companyid uuid);
DROP TABLE IF EXISTS public.companyfaq;
DROP FUNCTION IF EXISTS public.getallcompany();
DROP FUNCTION IF EXISTS public.getallcompanies();
DROP FUNCTION IF EXISTS public.getallclientintegration();
DROP TABLE IF EXISTS public.clientintegration;
DROP FUNCTION IF EXISTS public.getallblockedcustomer();
DROP FUNCTION IF EXISTS public.getalabatordertoken(_deliveryplatformid public.citext);
DROP FUNCTION IF EXISTS public.getaddressname(addressid uuid);
DROP FUNCTION IF EXISTS public.getaddressddl(keyword public.citext);
DROP FUNCTION IF EXISTS public.getaddressddl();
DROP FUNCTION IF EXISTS public.getaddressbylocation(_areaid uuid, _subareaid uuid);
DROP FUNCTION IF EXISTS public.getaddressbyid(_addressid uuid, _customerid uuid, _languagecode public.citext);
DROP FUNCTION IF EXISTS public.getaddressbranchbyid(_companyid uuid, _addressid uuid, _customerid uuid, _languagecode public.citext);
DROP FUNCTION IF EXISTS public.get_all_now();
DROP FUNCTION IF EXISTS public.doeshavechildren_careem(_attributeid uuid);
DROP FUNCTION IF EXISTS public.doeshavechildren(_attributeid uuid);
DROP FUNCTION IF EXISTS public.distancesforcompany(lat1 double precision, lon1 double precision, _companyid uuid);
DROP FUNCTION IF EXISTS public.distances(lat1 double precision, lon1 double precision);
DROP FUNCTION IF EXISTS public.distance_ai(lat1 double precision, lon1 double precision, lat2 double precision, lon2 double precision);
DROP FUNCTION IF EXISTS public.distance(lat1 double precision, lon1 double precision, lat2 double precision, lon2 double precision);
DROP FUNCTION IF EXISTS public.discountvalidfromcomapnyid(_companyphone public.citext);
DROP PROCEDURE IF EXISTS public.deletewhatsapptemplate(IN _companyid uuid, IN _name public.citext);
DROP PROCEDURE IF EXISTS public.deletewhatsappchatbotnumber(IN _companyid uuid, IN _type public.citext);
DROP PROCEDURE IF EXISTS public.deletetaxcategory(IN _id uuid, IN _deletedby public.citext);
DROP PROCEDURE IF EXISTS public.deletetax(IN _id uuid, IN _deletedby public.citext);
DROP PROCEDURE IF EXISTS public.deletesinglebranchsubareafee(IN _id uuid);
DROP PROCEDURE IF EXISTS public.deletescheduledeliveryorderrequest(IN _orderid uuid);
DROP PROCEDURE IF EXISTS public.deleterelatedproduct(IN _productid uuid, IN _relatedproductid uuid, IN _deletedby public.citext);
DROP PROCEDURE IF EXISTS public.deletepromocode(IN _id uuid, IN _deletedby public.citext);
DROP PROCEDURE IF EXISTS public.deleteproductselectedattribute(IN _productid uuid, IN _attributeid public.citext, IN _deletedby public.citext);
DROP PROCEDURE IF EXISTS public.deleteproductselectedattribute(IN _productid uuid, IN _attributeid uuid, IN _deletedby public.citext);
DROP PROCEDURE IF EXISTS public.deleteproductimages(IN _id uuid, IN _deletedby public.citext);
DROP PROCEDURE IF EXISTS public.deleteproductavailability(IN _id uuid, IN _deletedby public.citext);
DROP PROCEDURE IF EXISTS public.deleteproductattribute(IN _id uuid, IN _deletedby public.citext);
DROP PROCEDURE IF EXISTS public.deleteproductattreibutebycomapnyid(IN _companyid uuid);
DROP PROCEDURE IF EXISTS public.deleteproduct(IN _id uuid, IN _deletedby public.citext);
DROP PROCEDURE IF EXISTS public.deleteprinter(IN _printerid uuid);
DROP PROCEDURE IF EXISTS public.deleteposintegration(IN _id uuid);
DROP FUNCTION IF EXISTS public.deletepopupcompanyphone(_companyid uuid);
DROP PROCEDURE IF EXISTS public.deletepaymentonholdorders(IN _sessionid uuid, IN _paymentorderid uuid);
DROP PROCEDURE IF EXISTS public.deletepaymentcompany(IN _id uuid[], IN _companyid uuid, IN _deletedby public.citext);
DROP PROCEDURE IF EXISTS public.deleteorderstatuspossibilities(IN _id uuid, IN _deletedby public.citext);
DROP PROCEDURE IF EXISTS public.deleteorderfollowupdetailsbyorder(IN _orderid uuid);
DROP PROCEDURE IF EXISTS public.deleteorderfollowupdetails(IN _id uuid, IN _deletedby public.citext);
DROP PROCEDURE IF EXISTS public.deleteorderfollowup(IN _id uuid, IN _deletedby public.citext);
DROP PROCEDURE IF EXISTS public.deleteorderconfig(IN _companyid uuid);
DROP PROCEDURE IF EXISTS public.deleteoption(IN _id uuid, IN _deletedby public.citext);
DROP PROCEDURE IF EXISTS public.deleteonlinecustomeraddress(IN _customerid uuid, IN _addressid uuid);
DROP PROCEDURE IF EXISTS public.deleteofferimage(IN _imagepath public.citext, IN _companyid uuid);
DROP PROCEDURE IF EXISTS public.deleteofferaction(IN _id uuid, IN _deletedby public.citext);
DROP PROCEDURE IF EXISTS public.deleteoffer(IN _id uuid, IN _deletedby public.citext);
DROP PROCEDURE IF EXISTS public.deletenotification(IN _id uuid, IN _deletedby public.citext);
DROP PROCEDURE IF EXISTS public.deletenamelookup(IN _id uuid, IN _deletedby public.citext);
DROP PROCEDURE IF EXISTS public.deletemenuintegrationsyncbymenuid(IN _menuid uuid);
DROP PROCEDURE IF EXISTS public.deletemenuintegrationsync(IN _menuid uuid, IN _channelid uuid);
DROP PROCEDURE IF EXISTS public.deletemenu(IN _id uuid, IN _deletedby public.citext);
DROP PROCEDURE IF EXISTS public.deletelookup(IN _rid uuid, IN _sid bigint);
DROP PROCEDURE IF EXISTS public.deleteintegrationcompany(IN _id uuid, IN _deletedby public.citext);
DROP PROCEDURE IF EXISTS public.deletehyperpaycredentialsbycompany(IN _companyid uuid, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.deletegeneralcomplain(IN _id uuid, IN _deletedby public.citext);
DROP PROCEDURE IF EXISTS public.deletefollowup(IN _id uuid, IN _ordercase public.citext, IN _deletedby public.citext);
DROP PROCEDURE IF EXISTS public.deletefeesbylabel(IN _branchid uuid, IN _addressid uuid);
DROP PROCEDURE IF EXISTS public.deletediscountphysical(IN _id uuid);
DROP PROCEDURE IF EXISTS public.deletediscountbydiscountid(IN _discountid uuid, IN _deletedby public.citext);
DROP PROCEDURE IF EXISTS public.deletedeliverycostfordeliveryservice(IN _addressdeliverycompanyid uuid);
DROP PROCEDURE IF EXISTS public.deletedeliverycompany(IN _id uuid, IN _deletedby public.citext);
DROP PROCEDURE IF EXISTS public.deletedcustomeraddress_ai(IN _id uuid, IN _deletedby public.citext);
DROP PROCEDURE IF EXISTS public.deletedcustomeraccount(IN _id uuid, IN _companyid uuid);
DROP PROCEDURE IF EXISTS public.deletecustomerfromblacklist(IN _customerid uuid, IN _companyid uuid, IN _actionby public.citext);
DROP PROCEDURE IF EXISTS public.deletecustomeraddress(IN _customerid uuid, IN _deletedby public.citext);
DROP PROCEDURE IF EXISTS public.deletecoupon(IN _id uuid, IN _deletedby public.citext);
DROP PROCEDURE IF EXISTS public.deletecompanyuser(IN _id uuid, IN _deletedby public.citext);
DROP PROCEDURE IF EXISTS public.deletecompanyinfo(IN _id uuid, IN _deletedby public.citext);
DROP PROCEDURE IF EXISTS public.deletecompanyfaq(IN _id uuid, IN _deletedby public.citext);
DROP PROCEDURE IF EXISTS public.deletecompany(IN _id uuid, IN _deletedby public.citext);
DROP PROCEDURE IF EXISTS public.deletecomapnymenu(IN _companyid uuid);
DROP PROCEDURE IF EXISTS public.deleteclientintegration(IN _id uuid, IN _deletedby public.citext);
DROP PROCEDURE IF EXISTS public.deletecategory(IN _id uuid, IN _deletedby public.citext);
DROP PROCEDURE IF EXISTS public.deletebranchdeliverycompany(IN _branchid uuid, IN _deliverycompanyid uuid, IN _deletedby public.citext);
DROP PROCEDURE IF EXISTS public.deletebranchdeliverychargelabel(IN _id uuid);
DROP PROCEDURE IF EXISTS public.deletebranchdeliverycalculator(IN _branchid uuid);
DROP PROCEDURE IF EXISTS public.deletebranch(IN _id uuid, IN _deletedby public.citext);
DROP PROCEDURE IF EXISTS public.deleteallordersforacompany(IN _companyid uuid);
DROP PROCEDURE IF EXISTS public.deleteallishbekmapzones();
DROP PROCEDURE IF EXISTS public.deleteallcompanyfaq(IN _companyid uuid);
DROP PROCEDURE IF EXISTS public.deleteallbranchdeliverychargebycompanyid(IN _companyid uuid);
DROP PROCEDURE IF EXISTS public.deleteaddressbyid(IN _id uuid);
DROP PROCEDURE IF EXISTS public.declineorder(IN _orderid uuid, IN _updatedby public.citext, INOUT _status public.citext);
DROP PROCEDURE IF EXISTS public.declineadminblacklistrequest(IN _customerid uuid, IN _companyid uuid, IN _actionby public.citext);
DROP FUNCTION IF EXISTS public.daycount(_dayname public.citext, _from timestamp without time zone, _to timestamp without time zone);
DROP FUNCTION IF EXISTS public.customerdistances(_customerid uuid, lat1 double precision, lon1 double precision);
DROP PROCEDURE IF EXISTS public.creatwhatsappchatbotnumber(IN _companyid uuid, IN _number text, IN _type public.citext, IN _languagecode public.citext, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createwhatsapptemplate(IN _companyid uuid, IN _name public.citext, IN _category public.citext, IN _tlanguage public.citext, IN _status public.citext, IN _whatsapptemplateid public.citext, IN _components jsonb, IN _servicename public.citext);
DROP PROCEDURE IF EXISTS public.createwaapilogs(IN _endpoint public.citext, IN _request jsonb, IN _response jsonb, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createtransferbranch(IN _branchidselected uuid, IN _transfertobranchid uuid, IN _fromdate timestamp without time zone, IN _todate timestamp without time zone, IN _createdby public.citext, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createtransaction(IN _hyperpayid public.citext, IN _customerid uuid, IN _companyid uuid, IN _amount public.citext, IN _descriptor public.citext, IN _description public.citext, IN _extendeddescription public.citext, IN _transactionid public.citext, IN _orderid public.citext, IN _paymenttype public.citext, IN _ip public.citext, IN _timestamp public.citext, IN _alldetails jsonb);
DROP PROCEDURE IF EXISTS public.createtaxcategory(IN _companyid uuid, IN _name public.citext, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createtax(IN _name public.citext, IN _countryid uuid, IN _cityid uuid, IN _taxcategoryid uuid, IN _value numeric, IN _createdby public.citext);
DROP FUNCTION IF EXISTS public.createtalabatdeliveryorder(_id uuid);
DROP PROCEDURE IF EXISTS public.createtalabatdelivery(IN _orderid uuid, IN _talabatorderid public.citext, IN _request jsonb, IN _response jsonb, IN _requesttype public.citext);
DROP PROCEDURE IF EXISTS public.createtalabatcredentials(IN _branchid uuid, IN _talabatbrandid public.citext, IN _talabatbranchid public.citext, IN _companyid uuid, IN _istaxable boolean);
DROP PROCEDURE IF EXISTS public.createrestaurntmenuwithbrandid(IN _companyid uuid, IN _brandid public.citext, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createrestaurantparams(IN _restaurantid uuid, IN _period integer, IN _createdby public.citext, IN _restaurantname public.citext, IN _loyalpoint integer, IN _loyalcount integer, IN _loyalamount numeric);
DROP PROCEDURE IF EXISTS public.createrestaurantcustomer(IN _customerid uuid, IN _restaurantid uuid, IN _name public.citext, IN _phonenumber public.citext, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createrequestlog(IN _url public.citext, IN _method public.citext, IN _headers public.citext, IN _requestbody public.citext, IN _remoteid uuid, IN _talabatbrandid public.citext, IN _deliveryplatformid public.citext, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createreminderorder(IN _orderid uuid, IN _reminder timestamp without time zone);
DROP PROCEDURE IF EXISTS public.createrelatedproduct(IN _productid uuid, IN _relatedproductid uuid, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createpromocodecustomers(IN _promocodeid uuid, IN _customerid uuid, IN _numberofuse integer, IN _lastusetime timestamp without time zone, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createpromocode(IN _companyid uuid, IN _name public.citext, IN _type public.citext, IN _value numeric, IN _description public.citext, IN _priority integer, IN _numberofuse integer, IN _descriptionlanguage jsonb, IN _numberofusecustomer integer, IN _isdaily boolean, IN _daysofweek integer[], IN _availablefrom timestamp without time zone, IN _availableto timestamp without time zone, IN _ispercentage boolean, IN _maxvalue numeric, IN _minprice numeric, IN _minquantity integer, IN _createdby public.citext, IN _categoryids uuid[], IN _branchids uuid[], IN _channelids uuid[], IN _customerids uuid[], INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createproducttags(IN _productid uuid, IN _nametags public.citext[], IN _sizetags public.citext[], IN _ingredienttags public.citext[]);
DROP PROCEDURE IF EXISTS public.createproductselectedattribute(IN _productid uuid, IN _attribute jsonb, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createproductimages(IN _imagepath public.citext, IN _productid uuid, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createproductavailability(IN _name public.citext, IN _companyid uuid, IN _productids uuid[], IN _categoryids uuid[], IN _channelids uuid[], IN _branchids uuid[], IN _daysofweek integer[], IN _attributeids uuid[], IN _fromtime timestamp without time zone, IN _totime timestamp without time zone, IN _fromdate timestamp without time zone, IN _todate timestamp without time zone, IN _isavailable boolean, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createproductattribute(IN _productid uuid, IN _name jsonb, IN _description jsonb, IN _priority integer, IN _attributeid uuid, IN _controltype public.citext, IN _isrequired boolean, IN _isalergy boolean, IN _isavailable boolean, IN _noofselection integer, IN _ispreselected boolean, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createproduct(IN _name jsonb, IN _fulldescription jsonb, IN _shortdescription jsonb, IN _producttags jsonb, IN _sku public.citext, IN _isavailable boolean, IN _ispublished boolean, IN _isoffer boolean, IN _istopselling boolean, IN _hour integer, IN _min integer, IN _categoryid uuid, IN _imagepath public.citext, IN _thumbimage public.citext, IN _displaynumber integer, IN _createdby public.citext, INOUT _productid uuid);
DROP PROCEDURE IF EXISTS public.createprodcutavailability(IN _companyid uuid, IN _productids uuid[], IN _categoryids uuid[], IN _channelids uuid[], IN _attributeids uuid[], IN _fromtime timestamp without time zone, IN _totime timestamp without time zone, IN _fromdate timestamp without time zone, IN _todate timestamp without time zone, IN _daysofweek integer[], IN _isavailable boolean, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createprintingorder(IN _id uuid, IN _branchid uuid);
DROP PROCEDURE IF EXISTS public.createprinterview(IN _name public.citext, IN _branchid uuid, IN _companyid uuid);
DROP PROCEDURE IF EXISTS public.createprinter(IN _name public.citext, IN _type public.citext, IN _branchid uuid, IN _printerid uuid, IN _types public.citext[], IN _auto boolean, IN _copies integer, IN _channels uuid[], IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createposintegration(IN _companyid uuid, IN _integrationcompany uuid, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createpaymentrequestlog(IN _companyid uuid, IN _customerid uuid, IN _merchanttransactionid public.citext, IN _entityid public.citext, IN _amount public.citext, IN _request public.citext, IN _method public.citext, IN _url public.citext, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createpaymentcompanyinfocompany(IN _companyid uuid, IN _type public.citext, IN _values public.citext[], IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createpaymentcompanyinfo(IN _companyid uuid, IN _type public.citext, IN _value text, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createorupdatecustomerbillingdetails(IN _customerid uuid, IN _firstname public.citext, IN _lastname public.citext, IN _email public.citext, IN _postalcode public.citext, IN _country public.citext, IN _provinance public.citext, IN _city public.citext, IN _street public.citext, IN _buildingnumber public.citext, IN _ipaddress public.citext, INOUT _id uuid);
DROP FUNCTION IF EXISTS public.createorupdateashyaeelog(_id uuid, _eventid public.citext, _occurredat timestamp without time zone, _eventtype public.citext, _details jsonb, _createdat timestamp without time zone, _branchid uuid);
DROP PROCEDURE IF EXISTS public.createorderstatuspossibilities(IN _branchid uuid, IN _status public.citext, IN _companyid uuid, IN _nextstatus uuid, IN _cancancel boolean, IN _isfirststatus boolean, IN _islaststatus boolean, IN _color public.citext, IN _createdby public.citext, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createorderproductattribute(IN _orderproductid uuid, IN _attributeid uuid, IN _pricesubtotal numeric, IN _pricetaxvalue numeric, IN _pricetaxpercentage numeric, IN _notes public.citext, IN _attributevalues jsonb, IN _createdby public.citext, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createorderproduct(IN _orderid uuid, IN _productid uuid, IN _pricesubtotal numeric, IN _pricetaxvalue numeric, IN _pricetaxpercentage numeric, IN _notes public.citext, IN _itemcount integer, IN _createdby public.citext, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createorderprint(IN _jobid uuid, IN _restaurantname public.citext, IN _copies integer, IN _branchname public.citext, IN _branchid uuid, IN _branchphone public.citext, IN _printer public.citext, IN _template public.citext, IN _printerid uuid, IN _taxnumber public.citext);
DROP PROCEDURE IF EXISTS public.createorderhistory(IN _id uuid, IN _status public.citext, IN _notes public.citext, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createorderfollowupdetails(IN _orderid uuid, IN _notes public.citext, IN _usertype public.citext, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createorderfollowup(IN _id uuid, IN _case public.citext, IN _isagent boolean, IN _isteamleader boolean, IN _isbranch boolean, IN _complaincategory public.citext, IN _complainsubcategory public.citext, IN _customerid uuid, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createorder(IN _customerid uuid, IN _branchid uuid, IN _ordersource uuid, IN _totalprice numeric, IN _paymenttype public.citext, IN _subtotalprice numeric, IN _price jsonb, IN _scheduled timestamp without time zone, IN _notes public.citext, IN _deliveryprice numeric, IN _deliveryaddress uuid, IN _deliverytype uuid, IN _referencenumber jsonb, IN _referencenumber2 public.citext, IN _createdby public.citext, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createoption(IN _languagecode public.citext, IN _name public.citext, IN _suboptionid uuid, IN _attributeid uuid, IN _quantity integer, IN _price jsonb, IN _ispreselected boolean, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createonlineordertheme(IN _companyid uuid, IN _themecolor public.citext, IN _buttoncolor public.citext, IN _restaurantdomain public.citext, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createonlineorderingdeliveryaddress(IN _customerid uuid, IN _name public.citext, IN _details public.citext, IN _createdby public.citext, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createonlineorderingcustomeraddress(IN _customerid uuid, IN _name public.citext, IN _latitude numeric, IN _longtitude numeric, IN _details public.citext, IN _labeladdressid uuid, IN _buildingno public.citext, IN _streetname public.citext, IN _createdby public.citext, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createonlineorderinfo(IN _companyid uuid, IN _restaurantdomain public.citext, IN _aboutus public.citext, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createonlineorderimages(IN _companyid uuid, IN _logo public.citext, IN _registrationphoto public.citext, IN _offerlogo public.citext, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createonlineorderconfignew(IN _companyid uuid, IN _selectedservices uuid[], IN _pickupbranchids uuid[], IN _dineinbranchids uuid[], IN _deliverybranchids uuid[], IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createonlineorderconfig(IN _companyid uuid, IN _bio public.citext, IN _language public.citext, IN _selectedservices uuid[], IN _logo public.citext, IN _registrationphoto public.citext, IN _themecolor public.citext, IN _buttoncolor public.citext, IN _reservationtime timestamp without time zone, IN _ordertime timestamp without time zone, IN _preparetime timestamp without time zone, IN _restaurantdomain public.citext, IN _issms boolean, IN _istrackorder boolean, IN _pickupbranchids uuid[], IN _dineinbranchids uuid[], IN _deliverybranchids uuid[], IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createonlineaddress(IN _customerid uuid, IN _latitude numeric, IN _longtitude numeric, IN _name public.citext, IN _details public.citext);
DROP PROCEDURE IF EXISTS public.createofferimages(IN _imagepath public.citext, IN _companyid uuid, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createofferaction(IN _quantity integer, IN _categoryid uuid, IN _productid uuid, IN _attributes integer[], IN _offerid uuid, IN _newprice numeric, IN _ispercentage boolean, IN _discountvalue numeric, IN _maxdiscountprice numeric, IN _mindiscountprice numeric, IN _maxdiscountquantity integer, IN _mindiscountquantity integer, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createoffer(IN _offertype public.citext, IN _productids jsonb, IN _productactions jsonb, IN _ispercentage integer, IN _offeraction integer, IN _branchids uuid[], IN _channelids uuid[], IN _fromdate timestamp without time zone, IN _todate timestamp without time zone, IN _fromtime timestamp without time zone, IN _totime timestamp without time zone, IN _daysofweek integer[], IN _priority integer, IN _discounvalue integer, IN _discounpercent integer, IN _maxpercent integer, IN _maxofferquantity integer, IN _minofferquantity integer, IN _maxofferprice numeric, IN _minofferprice numeric, IN _newprice integer, IN _percentvalue integer, IN _valuepercent integer, IN _createdby public.citext, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createnotification(IN _subject text, IN _type integer, IN _companyid uuid, IN _priority integer, IN _branchid uuid[], IN _startdate timestamp without time zone, IN _starttime timestamp without time zone, IN _urgent boolean, IN _createdby public.citext, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createnotification(IN _subject public.citext, IN _companyid uuid, IN _category integer[], IN _customer uuid[], IN _title public.citext, IN _createdby public.citext, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createnewonlineordering(IN _customerid uuid, IN _branchid uuid, IN _totalprice numeric, IN _paymenttype public.citext, IN _numberofpeople public.citext, IN _subtotalprice numeric, IN _price jsonb, IN _scheduled timestamp without time zone, IN _notes public.citext, IN _deliveryprice numeric, IN _deliveryaddress uuid, IN _deliverytype uuid, IN _createdby public.citext, IN _ordersource public.citext, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createnewonlineordering(IN _customerid uuid, IN _branchid uuid, IN _totalprice numeric, IN _paymenttype public.citext, IN _numberofpeople public.citext, IN _subtotalprice numeric, IN _price jsonb, IN _scheduled timestamp without time zone, IN _notes public.citext, IN _deliveryprice numeric, IN _deliveryaddress uuid, IN _deliverytype uuid, IN _createdby public.citext, IN _chatbotsource boolean, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createnewonlineordering(IN _customerid uuid, IN _branchid uuid, IN _totalprice numeric, IN _paymenttype public.citext, IN _subtotalprice numeric, IN _price jsonb, IN _scheduled timestamp without time zone, IN _notes public.citext, IN _deliveryprice numeric, IN _deliveryaddress uuid, IN _deliverytype uuid, IN _createdby public.citext, IN _chatbotsource boolean, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createnewonlineordercustomeraddress(IN _customerid uuid, IN _name public.citext, IN _latitude numeric, IN _longtitude numeric, IN _details public.citext, IN _createdby public.citext, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createnamelookup(IN _name public.citext, IN _type public.citext, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createmenurequestlog(IN _url public.citext, IN _method public.citext, IN _headers public.citext, IN _requestbody public.citext, IN _brandid public.citext, IN _companyid uuid, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createmenuproduct(IN _menuid uuid, IN _productid uuid, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createmenuintegrationsync(IN _menuid uuid, IN _channelid uuid, IN _issync boolean, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createmenuchannel(IN _name public.citext, IN _companyid uuid, IN _channel public.citext, IN _branchids uuid[], IN _productids uuid[], INOUT _menuid uuid, IN _isavailable boolean, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createmenu(IN _name public.citext, IN _companyid uuid, IN _branchids uuid[], IN _productids uuid[], IN _channelids uuid[], INOUT _menuid uuid, IN _isavailable boolean, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createmenu(IN _name public.citext, IN _companyid uuid, IN _branchids uuid[], IN _productids uuid[], INOUT _menuid uuid, IN _isavailable boolean, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createlanguageresource(IN _key public.citext, IN _value public.citext, IN _objectid uuid, IN _languagecode public.citext, IN _type integer, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createinterfaceapirequestlog(IN _url public.citext, IN _method public.citext, IN _headers public.citext, IN _requestbody public.citext, IN _requestby public.citext, IN _companyid uuid, IN _authuserid uuid, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createintegrationmiddlewarerequestlog(IN _url public.citext, IN _method public.citext, IN _headers public.citext, IN _requestbody public.citext, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createintegrationcompany(IN _name public.citext, IN _type public.citext, IN _phone public.citext, IN _logo public.citext, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createhyperpaycredentials(IN _restauranid uuid, IN _merchantid public.citext, IN _authid public.citext, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createelicashuser(IN _refid public.citext, IN _customerid uuid);
DROP PROCEDURE IF EXISTS public.createelicashcredentials(IN _brandrefid public.citext, IN _companyid uuid);
DROP PROCEDURE IF EXISTS public.creatediscountproducts(IN _productid uuid, IN _discountid uuid);
DROP PROCEDURE IF EXISTS public.creatediscountinfo(IN _companyid uuid, IN _name public.citext, IN _discounttype public.citext, IN _discountvalue numeric, IN _description public.citext, IN _promocode public.citext, IN _priority integer, IN _noofuse integer, IN _noofusefrocustomer integer, IN _isdaily boolean, IN _level public.citext, IN _daysofweek integer[], IN _availablefrom timestamp without time zone, IN _availableto timestamp without time zone, IN _ispercentage boolean, IN _maxdiscountprice numeric, IN _mindiscountprice numeric, IN _mindiscountquantity integer, IN _createdby public.citext, IN _productids uuid[], IN _attributeids uuid[], IN _categoryids uuid[], IN _branchids uuid[], IN _channelids uuid[], IN _customerids uuid[], IN _descriptionlanguage jsonb, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.creatediscountinfo(IN _companyid uuid, IN _name public.citext, IN _discounttype public.citext, IN _discountvalue numeric, IN _description public.citext, IN _promocode public.citext, IN _priority integer, IN _noofuse integer, IN _noofusefrocustomer integer, IN _isdaily boolean, IN _level public.citext, IN _daysofweek integer[], IN _availablefrom timestamp without time zone, IN _availableto timestamp without time zone, IN _ispercentage boolean, IN _maxdiscountprice numeric, IN _mindiscountprice numeric, IN _mindiscountquantity integer, IN _createdby public.citext, IN _productids uuid[], IN _attributeids uuid[], IN _categoryids uuid[], IN _branchids uuid[], IN _channelids uuid[], IN _customerids uuid[], INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.creatediscountchannelids(IN _channelid uuid, IN _discountid uuid);
DROP PROCEDURE IF EXISTS public.creatediscountattribute(IN _attributeid uuid, IN _discountid uuid);
DROP PROCEDURE IF EXISTS public.creatediscount(IN _companyid uuid, IN _name public.citext, IN _discounttype public.citext, IN _productids uuid[], IN _attributeids uuid[], IN _categoryids uuid[], IN _channelids uuid[], IN _branchids uuid[], IN _customerids uuid[], IN _discountvalue numeric, IN _maxdiscountquantity integer, IN _mindiscountquantity integer, IN _maxdiscountprice numeric, IN _mindiscountprice numeric, IN _priority integer, IN _ispercentage boolean, IN _discountpercent integer, IN _newprice integer, IN _percentvalue integer, IN _valuepercent integer, IN _fromtime timestamp without time zone, IN _totime timestamp without time zone, IN _fromdate timestamp without time zone, IN _todate timestamp without time zone, IN _daysofweek integer[], IN _promocode public.citext, IN _description public.citext, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createdeliverycompany(IN _name jsonb, IN _isaggregated boolean, IN _phonenumber public.citext, IN _addressid uuid, IN _opentime timestamp without time zone, IN _closetime timestamp without time zone, IN _currency public.citext, IN _isavailable boolean, IN _logo public.citext, IN _website public.citext, INOUT _id uuid, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createdelayedorders(INOUT _orderid uuid, IN _actiontime timestamp without time zone);
DROP PROCEDURE IF EXISTS public.createcustomerpaymentdetail(IN _hyperpayid public.citext, IN _customerid uuid, IN _companyid uuid, IN _registrationid public.citext, IN _paymentbrand public.citext, IN _description public.citext, IN _bin public.citext, IN _bincountry public.citext, IN _lastfourdigit public.citext, IN _holder public.citext, IN _expirymonth public.citext, IN _expiryyear public.citext, IN _bank public.citext, IN _cardtype public.citext, IN _level public.citext);
DROP PROCEDURE IF EXISTS public.createcustomeraddress_ai(IN _customerid uuid, IN _name public.citext, IN _latitude numeric, IN _longtitude numeric, IN _details public.citext, IN _buildingno public.citext, IN _streetname public.citext, IN _createdby public.citext, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createcustomeraddress_ai(IN _customerid uuid, IN _latitude numeric, IN _longtitude numeric, IN _buildingno public.citext, IN _details public.citext, IN _name public.citext, IN _departmentno public.citext, IN _createdby public.citext, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createcustomeraddress(IN _customerid uuid, IN _addressid uuid, IN _buildingno public.citext, IN _streetname public.citext, IN _details public.citext, IN _name public.citext, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createcustomer_ai(IN _name public.citext, IN _phoneno public.citext, IN _email public.citext, IN _code public.citext, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createcustomer(IN _name public.citext, IN _dateofbirth date, IN _phoneno public.citext, IN _phoneno2 public.citext, IN _countrycode public.citext, IN _fullphonenumber public.citext, IN _email public.citext, IN _image public.citext, IN _channel uuid, IN _loyalitypoints numeric, IN _fb public.citext, IN _twitter public.citext, IN _instagram public.citext, IN _lastorderdate date, IN _blockdate jsonb, IN _notes public.citext, IN _isblocked boolean, IN _createdby public.citext, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createcoupon(IN _offerid uuid, IN _coupontype integer, IN _minprice numeric, IN _maxprice numeric, IN _minquantity integer, IN _maxquantity integer, IN _couponvalue numeric, IN _isunlimited boolean, IN _numberofuses integer, IN _customerids uuid[], IN _code public.citext, IN _fromdate timestamp without time zone, IN _todate timestamp without time zone, IN _fromtime timestamp without time zone, IN _totime timestamp without time zone, IN _newprice numeric, IN _ispercentage boolean, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createcopies(IN _branchid uuid, IN _copies integer);
DROP PROCEDURE IF EXISTS public.createcomplain(IN _customerid uuid, IN _branchid uuid, IN _orderstatuspossibilitiesid uuid, IN _category public.citext, IN _subcategory public.citext, IN _details public.citext, IN _createdby public.citext, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createcompanywithinfo(IN name public.citext, IN logo character varying, IN type public.citext, IN createdby public.citext);
DROP PROCEDURE IF EXISTS public.createcompanyuser(IN _usertype public.citext, IN _username public.citext, IN _email public.citext, IN _name public.citext, IN _phonenumber public.citext, IN _branchid uuid[], IN _companyid uuid, IN _keycloakid uuid, IN _createdby public.citext, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createcompanyservicechargebalance(IN _companyid uuid, IN _serviceid uuid, IN _companyphoneid public.citext, IN _countrycode public.citext, IN _phonenumber public.citext, IN _whatsappphoneid public.citext, IN _chargebalance integer, IN _charlengthar integer, IN _charlengthen integer);
DROP PROCEDURE IF EXISTS public.createcompanyreport(IN _companyid uuid, IN _reporttype public.citext, IN _link public.citext, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createcompanyinfonew(IN _companyid uuid, IN _type public.citext, IN _value text, IN _languagecode public.citext, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createcompanyinfo(IN _companyid uuid, IN _type public.citext, IN _value text, IN _languagecode public.citext, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createcompanyfaq(IN _id uuid, IN _companyid uuid, IN _question public.citext, IN _answer1 public.citext, IN _answer2 public.citext, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createcompanychannels(IN _companyid uuid, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createclientintegration(IN _companyid uuid, IN _intcompanyid uuid, IN _name public.citext, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createchatconversation(IN _companyid uuid, IN _phonenumberfrom public.citext, IN _phonenumberto public.citext, IN _textbody public.citext, IN _chattype public.citext, IN _chatsource public.citext, IN _serialized public.citext, IN _chatbotsource public.citext, IN _isviewed boolean, IN _isdelivered boolean);
DROP PROCEDURE IF EXISTS public.createchannelmenu(IN _menuid uuid, IN _channel public.citext, IN _issync boolean, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createcategoryreturningidforintegration(IN _arname public.citext, IN _enname public.citext, IN _categorytag uuid, IN _image public.citext, IN _companyid uuid, IN _parentcategoryid uuid, IN _displaynumber integer, IN _createdby public.citext, IN _is_deleted boolean, IN _externalposid public.citext, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createcategoryreturningid(IN _arname public.citext, IN _enname public.citext, IN _categorytag uuid, IN _image public.citext, IN _companyid uuid, IN _parentcategoryid uuid, IN _displaynumber integer, IN _createdby public.citext, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createcategory(IN _arname public.citext, IN _enname public.citext, IN _categorytag uuid, IN _image public.citext, IN _companyid uuid, IN _parentcategoryid uuid, IN _displaynumber integer, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createcareemcustomeraddress(IN _customerid uuid, IN _addressname public.citext, IN _latitude numeric, IN _longtitude numeric, IN _buildingno public.citext, IN _street public.citext, IN _details public.citext, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createcalllog(IN _companyid uuid, IN _status public.citext, IN _substatus public.citext, IN _notes public.citext, IN _customerphone public.citext, IN _createdby public.citext, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createcallcenterorder(IN _customerid uuid, IN _branchid uuid, IN _ordersource uuid, IN _totalprice numeric, IN _paymenttype public.citext, IN _subtotalprice numeric, IN _price jsonb, IN _scheduled timestamp without time zone, IN _notes public.citext, IN _deliveryprice numeric, IN _deliveryaddress uuid, IN _deliverytype uuid, IN _referencenumber public.citext, IN _createdby public.citext, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createbranchtemplate(IN _branchid uuid, IN _type public.citext, IN _islogo boolean, IN _isrestaurantname boolean, IN _isphonenumber boolean, IN _isbranchname boolean, IN _isorderinfo boolean, IN _isproductinfo boolean, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createbranchdeliverycost(IN _branchaddressid uuid, IN _addressdeliverycompanyid uuid, IN _deliverycost numeric, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createbranchdeliverycompany(IN _branchid uuid, IN _deliverycompanyid uuid, IN _maxdistance integer, IN _priority integer);
DROP PROCEDURE IF EXISTS public.createbranchconfig(IN _type public.citext, IN _companyid uuid, IN _branchids uuid[], IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createbranchavailability(IN _objectid uuid, IN _objecttype public.citext, IN _branchid uuid, IN _channelid uuid, IN _isavailable boolean, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createbranchaddress(IN _branchid uuid, IN _addressid uuid);
DROP PROCEDURE IF EXISTS public.createbranch(IN _name public.citext, IN _companyid uuid, IN _status integer, IN _countryid uuid, IN _phonenumber public.citext, IN _addressid uuid, IN _opentime timestamp without time zone, IN _closetime timestamp without time zone, IN _addressname public.citext, IN _latitude numeric, IN _longtitude numeric, IN _namelanguage jsonb, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createbasiccompanyinfo(IN _companyid uuid, IN _type public.citext, IN _value text, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createautoprint(IN _branchid uuid, IN _isautoprint boolean);
DROP PROCEDURE IF EXISTS public.createautoaccept(IN _branchid uuid, IN _isautoaccept boolean);
DROP PROCEDURE IF EXISTS public.createattributevalue(IN _attributeid uuid, IN _name jsonb, IN _priority integer, IN _price public.citext, IN _description jsonb, IN _isavailable boolean, IN _isalergy boolean, IN _weight public.citext, IN _ispreselected boolean, IN _noofselection integer, IN _minimumcount integer, IN _maximumcount integer, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.createattributeforintegration(IN _name jsonb, IN _isglobal boolean, IN _desc jsonb, IN _price jsonb, IN _attributeid uuid, IN _productid uuid, IN _isrequired boolean, IN _isalergy boolean, IN _controltype public.citext, IN _companyid uuid, IN _noofselection integer, IN _priority integer, IN _minimumcount integer, IN _maximumcount integer, IN _createdby public.citext, IN _is_deleted boolean, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createattribute(IN _name jsonb, IN _isglobal boolean, IN _desc jsonb, IN _price jsonb, IN _attributeid uuid, IN _productid uuid, IN _isrequired boolean, IN _isalergy boolean, IN _ischatbotquestion boolean, IN _controltype public.citext, IN _companyid uuid, IN _noofselection integer, IN _priority integer, IN _minimumcount integer, IN _maximumcount integer, IN _createdby public.citext, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createattribute(IN _name jsonb, IN _isglobal boolean, IN _desc jsonb, IN _price jsonb, IN _attributeid uuid, IN _productid uuid, IN _isrequired boolean, IN _isalergy boolean, IN _controltype public.citext, IN _companyid uuid, IN _noofselection integer, IN _priority integer, IN _minimumcount integer, IN _maximumcount integer, IN _createdby public.citext, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createashyaeerequestlog(IN _url public.citext, IN _headers public.citext, IN _requestbody public.citext, IN _response public.citext, IN _method public.citext, IN _ishbekid uuid, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.createagentblacklistrequest(IN _customerid uuid, IN _companyid uuid, IN _status public.citext, IN _createdby public.citext, IN _notes public.citext);
DROP PROCEDURE IF EXISTS public.createadminblacklist(IN _phonenumber public.citext, IN _companyid uuid, IN _status public.citext, IN _actionby public.citext, IN _createdby public.citext, IN _notes public.citext);
DROP FUNCTION IF EXISTS public.checkverison(_companyid uuid, _brandid public.citext);
DROP FUNCTION IF EXISTS public.checkproductexists(_productid uuid);
DROP FUNCTION IF EXISTS public.checkproductattributeexists(_productattribute uuid);
DROP FUNCTION IF EXISTS public.checkorders(_branchid uuid);
DROP FUNCTION IF EXISTS public.checkmessagefromwaapi_ai(_sessionid uuid);
DROP FUNCTION IF EXISTS public.checkifcustomerhasdata(_companyid uuid, _customerid uuid);
DROP FUNCTION IF EXISTS public.checkifcustomercomplainedorder(_orderid uuid, _customerid uuid);
DROP FUNCTION IF EXISTS public.checkcompanypohneidserivce(_companyphoneid public.citext, _whatsappphoneid public.citext);
DROP FUNCTION IF EXISTS public.checkbranchexists(_branchid uuid);
DROP FUNCTION IF EXISTS public.check_modifire_branch_availability(_productarrtibuteid uuid, _productsubarrtibuteid uuid, _branchid uuid, _channelid uuid, _default_availability boolean);
DROP FUNCTION IF EXISTS public.check_branch_availability(_productid uuid, _categoryid uuid, _branchid uuid, _channelid uuid, _default_availability boolean);
DROP PROCEDURE IF EXISTS public.canceltalabatorder(IN _remoteorderid public.citext, IN _updatedby public.citext, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.cancelorder(IN _orderid uuid, IN _updatedby public.citext);
DROP FUNCTION IF EXISTS public.calculatedistance(lat1 double precision, lon1 double precision, lat2 double precision, lon2 double precision, units character varying);
DROP FUNCTION IF EXISTS public.branchaddressfordelivery(_branchids uuid[]);
DROP PROCEDURE IF EXISTS public.blockcustomer(IN _id uuid, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.availablepromocode(IN _id uuid, IN _updatedby public.citext);
DROP PROCEDURE IF EXISTS public.addwaapiclient(IN _companyid uuid, IN _instanceid integer, IN _owner public.citext, IN _name public.citext, IN _webhooks public.citext[], IN _phonenumber public.citext, IN _integrationtype public.citext);
DROP PROCEDURE IF EXISTS public.addpopupcompanyphone(IN _companyname public.citext, IN _companyphone public.citext, IN _companyid uuid, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.addpoint(IN _customerid uuid, IN _restaurantid uuid, IN _amount double precision, IN _channelid uuid, IN _orderid uuid);
DROP PROCEDURE IF EXISTS public.addorderproduct(IN _price jsonb, IN _orderid uuid, IN _productid uuid, IN _pricesubtotal numeric, IN _pricetaxvalue numeric, IN _pricetaxpercentage numeric, IN _notes public.citext, IN _itemcount integer, IN _createdby public.citext, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.addorderprice(IN _orderid uuid, IN _branchid uuid, IN _ordersourceid uuid, IN _customerid uuid, IN _ordertotal numeric, IN _ordertotalwithouttax numeric, IN _deliveryprice numeric, IN _orderdiscount numeric, IN _deliverydiscount numeric, IN _ordertax numeric, IN _grandtotal numeric, IN _servicefee numeric, IN _orderprice jsonb, IN _ordertaxing jsonb, IN _discountnames public.citext, IN _discounttype jsonb);
DROP PROCEDURE IF EXISTS public.addintegrationrequest(IN _companyid uuid, IN _channelid uuid, IN _status public.citext, IN _isactive boolean, IN _reason public.citext, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.addhistoryprice(IN _itemid uuid, IN _itemtype public.citext, IN _price jsonb, IN _tax numeric, IN _taxedprice jsonb, IN _createdby public.citext);
DROP PROCEDURE IF EXISTS public.addcustomeraddress(IN _companyid uuid, IN _customerid uuid, IN _ishbekcityid integer, IN _ishbekareaid bigint, IN _preferedsubarea public.citext, IN _name public.citext, IN _lat double precision, IN _lng double precision, IN _street public.citext, IN _buildingnumber public.citext, IN _otherdetails public.citext, IN _notes public.citext, IN _creationsource uuid, IN _subareaid uuid, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.addcompanysubarea(IN _companyid uuid, IN _cityid integer, IN _areaid bigint, IN _name public.citext, IN _areacode integer, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.addbranchsubareafees(IN _cityid integer, IN _areaid integer, IN _areacodeid integer, IN _branchid uuid, IN _fees numeric, INOUT _id uuid);
DROP PROCEDURE IF EXISTS public.activecustomeraccount_ai(IN _id uuid, IN _companyid uuid);
DROP PROCEDURE IF EXISTS public.activecustomeraccount(IN _id uuid, IN _companyid uuid);
DROP PROCEDURE IF EXISTS public.acceptadminblacklistrequest(IN _customerid uuid, IN _companyid uuid, IN _actionby public.citext);
DROP TYPE IF EXISTS public.customerdistance;
DROP TYPE IF EXISTS public.calculateddistance;
DROP TYPE IF EXISTS public.branchdistance;
DROP EXTENSION IF EXISTS "uuid-ossp";
DROP EXTENSION IF EXISTS postgres_fdw;
DROP EXTENSION IF EXISTS pldbgapi;
DROP EXTENSION IF EXISTS earthdistance;
DROP EXTENSION IF EXISTS cube;
DROP EXTENSION IF EXISTS citext;
-- *not* dropping schema, since initdb creates it
--
-- Name: public; Type: SCHEMA; Schema: -; Owner: -
--

-- *not* creating schema, since initdb creates it


--
-- Name: citext; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS citext WITH SCHEMA public;


--
-- Name: EXTENSION citext; Type: COMMENT; Schema: -; Owner: -
--

COMMENT ON EXTENSION citext IS 'data type for case-insensitive character strings';


--
-- Name: cube; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS cube WITH SCHEMA public;


--
-- Name: EXTENSION cube; Type: COMMENT; Schema: -; Owner: -
--

COMMENT ON EXTENSION cube IS 'data type for multidimensional cubes';


--
-- Name: earthdistance; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS earthdistance WITH SCHEMA public;


--
-- Name: EXTENSION earthdistance; Type: COMMENT; Schema: -; Owner: -
--

COMMENT ON EXTENSION earthdistance IS 'calculate great-circle distances on the surface of the Earth';


--
-- Name: pldbgapi; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS pldbgapi WITH SCHEMA public;


--
-- Name: EXTENSION pldbgapi; Type: COMMENT; Schema: -; Owner: -
--

COMMENT ON EXTENSION pldbgapi IS 'server-side support for debugging PL/pgSQL functions';


--
-- Name: postgres_fdw; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS postgres_fdw WITH SCHEMA public;


--
-- Name: EXTENSION postgres_fdw; Type: COMMENT; Schema: -; Owner: -
--

COMMENT ON EXTENSION postgres_fdw IS 'foreign-data wrapper for remote PostgreSQL servers';


--
-- Name: uuid-ossp; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA public;


--
-- Name: EXTENSION "uuid-ossp"; Type: COMMENT; Schema: -; Owner: -
--

COMMENT ON EXTENSION "uuid-ossp" IS 'generate universally unique identifiers (UUIDs)';


--
-- Name: branchdistance; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.branchdistance AS (
	id uuid,
	name public.citext,
	latitude numeric(20,0),
	longtitude numeric(20,0)
);


--
-- Name: calculateddistance; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.calculateddistance AS (
	id uuid,
	name public.citext,
	distance double precision
);


--
-- Name: customerdistance; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE public.customerdistance AS (
	id uuid,
	name public.citext,
	latitude numeric(20,0),
	longtitude numeric(20,0)
);


--
-- Name: acceptadminblacklistrequest(uuid, uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.acceptadminblacklistrequest(IN _customerid uuid, IN _companyid uuid, IN _actionby public.citext)
    LANGUAGE plpgsql
    AS $$
begin
    update blacklist
    set isapproved = true,
    actiontime = now(),
    actionby = _actionby
    where customerid = _customerid and companyid = _companyid;
END;
$$;


--
-- Name: activecustomeraccount(uuid, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.activecustomeraccount(IN _id uuid, IN _companyid uuid)
    LANGUAGE plpgsql
    AS $$
begin 
update restaurantcustomer set isactive = true where restaurantid = _companyid and customerid = _id;
end;
$$;


--
-- Name: activecustomeraccount_ai(uuid, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.activecustomeraccount_ai(IN _id uuid, IN _companyid uuid)
    LANGUAGE plpgsql
    AS $$
begin 
update restaurantcustomer set isactive = true where restaurantid = _companyid and customerid = _id;
end;
$$;


--
-- Name: addbranchsubareafees(integer, integer, integer, uuid, numeric, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.addbranchsubareafees(IN _cityid integer, IN _areaid integer, IN _areacodeid integer, IN _branchid uuid, IN _fees numeric, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO branchsubareafees (cityid , areaid, areacodeid, branchid, fees)
    VALUES (_cityid,_areaid, _areacodeid, _branchid, _fees)
     on conflict(cityid, areaid,   branchid,areacodeid)
        do update set fees = _fees
    returning id into _id;
END;
$$;


--
-- Name: addcompanysubarea(uuid, integer, bigint, public.citext, integer, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.addcompanysubarea(IN _companyid uuid, IN _cityid integer, IN _areaid bigint, IN _name public.citext, IN _areacode integer, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
begin
    insert into companysubarea (companyid, cityid, areaid, name, areacode)
    values (_companyid, _cityid, _areaid, _name,_areacode)
    on conflict(companyid, cityid, areaid,areacode)
        do update set name =_name
    returning id into _id;

end;
$$;


--
-- Name: addcustomeraddress(uuid, uuid, integer, bigint, public.citext, public.citext, double precision, double precision, public.citext, public.citext, public.citext, public.citext, uuid, uuid, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.addcustomeraddress(IN _companyid uuid, IN _customerid uuid, IN _ishbekcityid integer, IN _ishbekareaid bigint, IN _preferedsubarea public.citext, IN _name public.citext, IN _lat double precision, IN _lng double precision, IN _street public.citext, IN _buildingnumber public.citext, IN _otherdetails public.citext, IN _notes public.citext, IN _creationsource uuid, IN _subareaid uuid, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO addresses (id , companyid, customerid, ishbekcityid, ishbekareaid, preferedsubarea, name, lat, lng, street,
                           buildingnumber, otherdetails, notes,creationsource, subareaid)

    VALUES (COALESCE(_id, uuid_generate_v4()),_companyid, _customerid, _ishbekcityid, _ishbekareaid, _preferedsubarea, _name, _lat, _lng, _street,
            _buildingnumber, _otherdetails, _notes,_creationsource, _subareaid)
 on conflict (id) do update
 set ishbekcityid = _ishbekcityid , ishbekareaid = _ishbekareaid ,  preferedsubarea =_preferedsubarea , name = _name , lat= _lat , lng = _lng , street = _street , buildingnumber = _buildingnumber,
 otherdetails = _otherdetails , notes = _notes , subareaid = _subareaid , updatedat = now(), updatedby = 'system'
    returning id into _id;
END;
$$;


--
-- Name: addhistoryprice(uuid, public.citext, jsonb, numeric, jsonb, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.addhistoryprice(IN _itemid uuid, IN _itemtype public.citext, IN _price jsonb, IN _tax numeric, IN _taxedprice jsonb, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin
 INSERT INTO orderhistoryprice ( itemid, itemtype, price, tax, taxedprice, createdby)
			  VALUES (_itemid, _itemtype, _price, _tax, _taxedprice, _createdby);
END;
$$;


--
-- Name: addintegrationrequest(uuid, uuid, public.citext, boolean, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.addintegrationrequest(IN _companyid uuid, IN _channelid uuid, IN _status public.citext, IN _isactive boolean, IN _reason public.citext, IN _createdby public.citext)
    LANGUAGE plpgsql
    AS $$
begin
       insert into companyactiveintegrations as cai (companyid, channelid, status, isactive, reason, createdby)
                                                    values (_companyid,_channelid,_status,_isactive,_reason,_createdby)
        on conflict (companyid, channelid)
            do update set isactive = false where cai.isactive = false;
end
$$;


--
-- Name: addorderprice(uuid, uuid, uuid, uuid, numeric, numeric, numeric, numeric, numeric, numeric, numeric, numeric, jsonb, jsonb, public.citext, jsonb); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.addorderprice(IN _orderid uuid, IN _branchid uuid, IN _ordersourceid uuid, IN _customerid uuid, IN _ordertotal numeric, IN _ordertotalwithouttax numeric, IN _deliveryprice numeric, IN _orderdiscount numeric, IN _deliverydiscount numeric, IN _ordertax numeric, IN _grandtotal numeric, IN _servicefee numeric, IN _orderprice jsonb, IN _ordertaxing jsonb, IN _discountnames public.citext, IN _discounttype jsonb DEFAULT NULL::jsonb)
    LANGUAGE plpgsql
    AS $$

begin
   insert into orderprice
       (orderid, branchid, ordersourceid, customerid, ordertotal, ordertotalwithouttax, deliveryprice, orderdiscount,          deliverydiscount, ordertax, grandtotal,   servicefee,   discounttype, orderprice,tax,discountnames)
    values
        (_orderid, _branchid, _ordersourceid, _customerid, _ordertotal, _ordertotalwithouttax, _deliveryprice, _orderdiscount, _deliverydiscount, _ordertax, _grandtotal, _servicefee, _discounttype, _orderprice,_ordertaxing,_discountnames);
END;
$$;


--
-- Name: addorderproduct(jsonb, uuid, uuid, numeric, numeric, numeric, public.citext, integer, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.addorderproduct(IN _price jsonb, IN _orderid uuid, IN _productid uuid, IN _pricesubtotal numeric, IN _pricetaxvalue numeric, IN _pricetaxpercentage numeric, IN _notes public.citext, IN _itemcount integer DEFAULT 1, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
begin 
 INSERT INTO orderproduct (price,orderid, productid ,pricesubtotal,pricetaxvalue,pricetaxpercentage,notes,itemcount,createdby)
			  VALUES (_price,_orderid,_productid,_pricesubtotal,_pricetaxvalue,_pricetaxpercentage,_notes,_itemcount,_createdby)
	returning id into _id;
			

END;
$$;


--
-- Name: addpoint(uuid, uuid, double precision, uuid, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.addpoint(IN _customerid uuid, IN _restaurantid uuid, IN _amount double precision, IN _channelid uuid, IN _orderid uuid)
    LANGUAGE plpgsql
    AS $$
declare
    _cr restaurantcustomer= (select rc from restaurantcustomer rc where customerid = _customerid and restaurantid = _restaurantid);
    --
begin

IF((SELECT COUNT(rc.id) from restaurantcustomer rc where rc.customerid = _customerid and rc.restaurantid = _restaurantid ) > 0) THEN
    update restaurantcustomer
    set currentpoints = (_cr.currentpoints + 1) , lastpointdate = now()
    where id = _cr.id;
    call promote(_cr.id);
    call insertpointlog(_cr.id,_amount,_channelid, _orderid);
END IF;
end;
$$;


--
-- Name: addpopupcompanyphone(public.citext, public.citext, uuid, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.addpopupcompanyphone(IN _companyname public.citext, IN _companyphone public.citext, IN _companyid uuid, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$

begin
 INSERT INTO viciphonenumber(companyname, companyid, companyphone)
    values (_companyname,_companyid,_companyphone)
      ON CONFLICT (companyid)
   DO UPDATE
        SET
            companyphone = _companyphone
    RETURNING id INTO _id;
END;
$$;


--
-- Name: addwaapiclient(uuid, integer, public.citext, public.citext, public.citext[], public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.addwaapiclient(IN _companyid uuid, IN _instanceid integer, IN _owner public.citext, IN _name public.citext, IN _webhooks public.citext[], IN _phonenumber public.citext, IN _integrationtype public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
    insert into waapiclients (companyid, instanceid, owner, name, webhooks, phonenumber, integrationtype) VALUES (_companyid, _instanceid, _owner, _name, _webhooks, _phonenumber, _integrationtype);
END;
$$;


--
-- Name: availablepromocode(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.availablepromocode(IN _id uuid, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 

if((select isavailable from promocode where id = _id) = true) then
    update promocode set isavailable = false,updatedby=_updatedby,updatedat=now() where id = _id;
    else
    update promocode set isavailable = true,updatedby=_updatedby,updatedat=now() where id = _id;
end if;

end;
$$;


--
-- Name: blockcustomer(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.blockcustomer(IN _id uuid, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin
update "customer" SET isblocked = true , updatedat = now(), updatedby = _updatedby where id = _id;
end;
$$;


--
-- Name: branchaddressfordelivery(uuid[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.branchaddressfordelivery(_branchids uuid[] DEFAULT NULL::uuid[]) RETURNS TABLE(branch public.citext, branchaddressid uuid, city public.citext, area public.citext, subarea public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY

select branch.name ,branchaddress.id , city.value,area.value,subarea.value from branch inner join branchaddress on branchaddress.branchid = branch.id 
inner join address on address.id = branchaddress.addressid 
left join languageresourcee city on address.cityname = city.objectid
left join languageresourcee area on address.areaname = area.objectid
left join languageresourcee subarea on address.subareaname = subarea.objectid
where branchaddress.branchid = any(_branchids);
END;
$$;


--
-- Name: calculatedistance(double precision, double precision, double precision, double precision, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.calculatedistance(lat1 double precision, lon1 double precision, lat2 double precision, lon2 double precision, units character varying) RETURNS double precision
    LANGUAGE plpgsql
    AS $$
    DECLARE
        dist float = 0;
        radlat1 float;
        radlat2 float;
        theta float;
        radtheta float;
    BEGIN
        IF lat1 = lat2 OR lon1 = lon2
            THEN RETURN dist;
        ELSE
            radlat1 = pi() * lat1 / 180;
            radlat2 = pi() * lat2 / 180;
            theta = lon1 - lon2;
            radtheta = pi() * theta / 180;
            dist = sin(radlat1) * sin(radlat2) + cos(radlat1) * cos(radlat2) * cos(radtheta);

            IF dist > 1 THEN dist = 1; END IF;

            dist = acos(dist);
            dist = dist * 180 / pi();
            dist = dist * 60 * 1.1515;

            IF units = 'K' THEN dist = dist * 1.609344; END IF;
            IF units = 'N' THEN dist = dist * 0.8684; END IF;

            RETURN dist;
        END IF;
    END;
$$;


--
-- Name: cancelorder(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.cancelorder(IN _orderid uuid, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin
if ((select iscanceled from "order" where id = _orderid) = false) then
update "order" SET iscanceled = true, updatedat = now(), updatedby = _updatedby where id = _orderid;
end if;
end;
$$;


--
-- Name: canceltalabatorder(public.citext, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.canceltalabatorder(IN _remoteorderid public.citext, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
begin
    update "order" o
    set iscanceled = true,
        updatedby = _updatedby,
        updatedat = now()
    where referencenumber2 =  _remoteorderid
    returning o.id into _id;

end;
$$;


--
-- Name: check_branch_availability(uuid, uuid, uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_branch_availability(_productid uuid, _categoryid uuid, _branchid uuid, _channelid uuid, _default_availability boolean) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    --RAISE NOTICE 'Checking branch availability: branch=%, product=%, category=%, channel=%',        _branchid, _productid, _categoryid, _channelid;

    IF EXISTS (
        SELECT 1 FROM branchavailability
        WHERE objecttype = 'category' AND objectid = _categoryid
          AND branchid = _branchid AND channelid = _channelid
    ) THEN
        RETURN FALSE;
    ELSIF EXISTS (
        SELECT 1 FROM branchavailability
        WHERE objecttype = 'product' AND objectid = _productid
          AND branchid = _branchid AND channelid = _channelid
    ) THEN
        RETURN FALSE;
    END IF;

    RETURN _default_availability;
END;
$$;


--
-- Name: check_modifire_branch_availability(uuid, uuid, uuid, uuid, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.check_modifire_branch_availability(_productarrtibuteid uuid, _productsubarrtibuteid uuid, _branchid uuid, _channelid uuid, _default_availability boolean) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF EXISTS (SELECT 1
               FROM branchavailability
               WHERE objecttype = 'attribute'
                 AND objectid = _productarrtibuteid
                 AND branchid = _branchid
                 AND channelid = _channelid) THEN
        --RAISE NOTICE 'Checking branch availability IN check_modifire_branch_availability : branch=%, productarrtibute=%, productsubarrtibute=%, channel=% , RESULT=%', _branchid, _productarrtibuteid, _productsubarrtibuteid, _channelid, FALSE;
        RETURN FALSE;
    ELSIF EXISTS (SELECT 1
                  FROM branchavailability
                  WHERE objecttype = 'attribute'
                    AND objectid = _productsubarrtibuteid
                    AND branchid = _branchid
                    AND channelid = _channelid) THEN
        --RAISE NOTICE 'Checking branch availability IN check_modifire_branch_availability : branch=%, productarrtibute=%, productsubarrtibute=%, channel=% , RESULT=%', _branchid, _productarrtibuteid, _productsubarrtibuteid, _channelid, FALSE;
        RETURN FALSE;
    END IF;
    --RAISE NOTICE 'Checking branch availability IN check_modifire_branch_availability : branch=%, productarrtibute=%, productsubarrtibute=%, channel=% , RESULT=%', _branchid, _productarrtibuteid, _productsubarrtibuteid, _channelid, _default_availability;
    RETURN _default_availability;
END;
$$;


--
-- Name: checkbranchexists(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.checkbranchexists(_branchid uuid) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1
        FROM public.ashyaeemappedentities
        WHERE ashyaeemappedentities.ishbekid = _branchid
    );
END;
$$;


--
-- Name: checkcompanypohneidserivce(public.citext, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.checkcompanypohneidserivce(_companyphoneid public.citext DEFAULT NULL::public.citext, _whatsappphoneid public.citext DEFAULT NULL::public.citext) RETURNS SETOF public.citext
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select c.name
from companyservices cs
inner join company c on c.id = cs.companyid
where cs.whatsappid = _whatsappphoneid and cs.whatsappcompanyid = _companyphoneid limit 1;

END;
$$;


--
-- Name: checkifcustomercomplainedorder(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.checkifcustomercomplainedorder(_orderid uuid DEFAULT NULL::uuid, _customerid uuid DEFAULT NULL::uuid) RETURNS SETOF boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 SELECT EXISTS (SELECT id from orderfollowup where id =_orderid and customerid = _customerid and isdeleted=false and ispublished=true) from orderfollowup;

END;
$$;


--
-- Name: checkifcustomerhasdata(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.checkifcustomerhasdata(_companyid uuid, _customerid uuid) RETURNS TABLE(id uuid)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select rc.id from restaurantcustomer rc where rc.restaurantid = _companyid and rc.customerid = _customerid;
END
$$;


--
-- Name: checkmessagefromwaapi_ai(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.checkmessagefromwaapi_ai(_sessionid uuid) RETURNS TABLE(instanceid public.citext, chatid public.citext, phonenumberto public.citext, serialized public.citext, companyid uuid)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY

select (request->>'instanceId')::citext,(CONCAT('00',((request->>'data')::json->>'message')::json->>'from'))::citext,(CONCAT('00',((request->>'data')::json->>'message')::json->>'to'))::citext,((((request->>'data')::json->>'message')::json->>'id')::json->>'_serialized')::citext,(select wc.companyid from waapiclients wc where wc.instanceid = (request->>'instanceId')::integer) from waapilogs where id = _sessionid; 
END;
$$;


--
-- Name: checkorders(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.checkorders(_branchid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select ord.id from "order" ord
left join orderprint ordp on ordp.jobid = ord.id
where ord.branchid = _branchid and (EXTRACT(EPOCH FROM ((now() AT TIME ZONE 'Asia/Amman'::text) - ord.createdat)))::bigint < (90)::bigint and ordp.jobid IS NULL; 
END;
$$;


--
-- Name: checkproductattributeexists(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.checkproductattributeexists(_productattribute uuid) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1
        FROM public.productattribute
        WHERE productattribute.id = _productattribute
          AND productattribute.isdeleted = false
    );
END;
$$;


--
-- Name: checkproductexists(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.checkproductexists(_productid uuid) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1
        FROM public.product
        WHERE product.id = _productid
          AND product.isdeleted = false
    );
END;
$$;


--
-- Name: checkverison(uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.checkverison(_companyid uuid, _brandid public.citext) RETURNS SETOF integer
    LANGUAGE plpgsql
    AS $$
BEGIN

return query
select (CASE WHEN ((select Count(tm.id) from talabatmenu tm where tm.brandid = _brandid and tm.companyid = _companyid)) > 0 THEN
        ((select max(tm1.menuversionnumber) from talabatmenu tm1 where tm1.brandid = _brandid and tm1.companyid = _companyid)+1)::integer
        ELSE 1::integer END)::integer;
END;
$$;


--
-- Name: createadminblacklist(public.citext, uuid, public.citext, public.citext, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createadminblacklist(IN _phonenumber public.citext, IN _companyid uuid, IN _status public.citext, IN _actionby public.citext, IN _createdby public.citext, IN _notes public.citext)
    LANGUAGE plpgsql
    AS $$
declare
    custid uuid;
begin
    select id into custid from customer where phoneno = _phonenumber;

    insert into blacklist (customerid, companyid, status, isapproved, actiontime, actionby, createdby, createdat, notes)
    values (custid, _companyid, _status, true, now(), _actionby, _createdby, now(), _notes)
    on conflict (companyid, customerid)
    do update set
        status = EXCLUDED.status,
        notes = EXCLUDED.notes,
        actiontime = now(),
        actionby = EXCLUDED.actionby,
        createdby = EXCLUDED.createdby,
        createdat = now()
    where blacklist.companyid = EXCLUDED.companyid and blacklist.customerid = EXCLUDED.customerid;

END;
$$;


--
-- Name: createagentblacklistrequest(uuid, uuid, public.citext, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createagentblacklistrequest(IN _customerid uuid, IN _companyid uuid, IN _status public.citext, IN _createdby public.citext, IN _notes public.citext)
    LANGUAGE plpgsql
    AS $$
begin
    if
        ((select count(*) from blacklist where companyid = _companyid and customerid = _customerid ) < 1 )
    then
    insert into blacklist (customerid, companyid, status, createdby,createdat,notes)
    values
    (_customerid, _companyid, _status, _createdby, now(),_notes);
    else
        update blacklist set isapproved = null, actionby = null, actiontime = null,createdat = now(), createdby = _createdby, status = _status, notes = _notes where companyid = _companyid and customerid = _customerid;
        end if;

END;
$$;


--
-- Name: createashyaeerequestlog(public.citext, public.citext, public.citext, public.citext, public.citext, uuid, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createashyaeerequestlog(IN _url public.citext, IN _headers public.citext, IN _requestbody public.citext, IN _response public.citext, IN _method public.citext, IN _ishbekid uuid, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
begin
    insert into ashyaeerequestlog( url, headers, requestbody, response, method, ishbekid) values (_url,_headers,_requestbody,_response,_method,_ishbekid)
    returning id into _id;
END;
$$;


--
-- Name: createattribute(jsonb, boolean, jsonb, jsonb, uuid, uuid, boolean, boolean, public.citext, uuid, integer, integer, integer, integer, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createattribute(IN _name jsonb, IN _isglobal boolean, IN _desc jsonb DEFAULT NULL::jsonb, IN _price jsonb DEFAULT NULL::jsonb, IN _attributeid uuid DEFAULT NULL::uuid, IN _productid uuid DEFAULT NULL::uuid, IN _isrequired boolean DEFAULT false, IN _isalergy boolean DEFAULT NULL::boolean, IN _controltype public.citext DEFAULT 'checkbox'::public.citext, IN _companyid uuid DEFAULT NULL::uuid, IN _noofselection integer DEFAULT NULL::integer, IN _priority integer DEFAULT NULL::integer, IN _minimumcount integer DEFAULT NULL::integer, IN _maximumcount integer DEFAULT NULL::integer, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
begin
 INSERT INTO productattribute(price,attributeid,name,description,productid,isrequired,isalergy,isglobal,controltype,companyid,noofselection,priority,minimumcount,maximumcount,createdby)
                       VALUES(_price,_attributeid,_name,_desc,_productid,_isrequired,_isalergy,_isglobal,_controltype,_companyid,_noofselection,_priority,_minimumcount,_maximumcount,_createdby)
                        returning  id into _id;
END;
$$;


--
-- Name: createattribute(jsonb, boolean, jsonb, jsonb, uuid, uuid, boolean, boolean, boolean, public.citext, uuid, integer, integer, integer, integer, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createattribute(IN _name jsonb, IN _isglobal boolean, IN _desc jsonb DEFAULT NULL::jsonb, IN _price jsonb DEFAULT NULL::jsonb, IN _attributeid uuid DEFAULT NULL::uuid, IN _productid uuid DEFAULT NULL::uuid, IN _isrequired boolean DEFAULT false, IN _isalergy boolean DEFAULT NULL::boolean, IN _ischatbotquestion boolean DEFAULT NULL::boolean, IN _controltype public.citext DEFAULT 'checkbox'::public.citext, IN _companyid uuid DEFAULT NULL::uuid, IN _noofselection integer DEFAULT NULL::integer, IN _priority integer DEFAULT NULL::integer, IN _minimumcount integer DEFAULT NULL::integer, IN _maximumcount integer DEFAULT NULL::integer, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
begin
 INSERT INTO productattribute(price,attributeid,name,description,productid,isrequired,isalergy,ischatbotquestion,isglobal,controltype,companyid,noofselection,priority,minimumcount,maximumcount,createdby)
                       VALUES(_price,_attributeid,_name,_desc,_productid,_isrequired,_isalergy,_ischatbotquestion,_isglobal,_controltype,_companyid,_noofselection,_priority,_minimumcount,_maximumcount,_createdby)
                        returning  id into _id;
END;
$$;


--
-- Name: createattributeforintegration(jsonb, boolean, jsonb, jsonb, uuid, uuid, boolean, boolean, public.citext, uuid, integer, integer, integer, integer, public.citext, boolean, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createattributeforintegration(IN _name jsonb, IN _isglobal boolean, IN _desc jsonb DEFAULT NULL::jsonb, IN _price jsonb DEFAULT NULL::jsonb, IN _attributeid uuid DEFAULT NULL::uuid, IN _productid uuid DEFAULT NULL::uuid, IN _isrequired boolean DEFAULT false, IN _isalergy boolean DEFAULT NULL::boolean, IN _controltype public.citext DEFAULT 'checkbox'::public.citext, IN _companyid uuid DEFAULT NULL::uuid, IN _noofselection integer DEFAULT NULL::integer, IN _priority integer DEFAULT NULL::integer, IN _minimumcount integer DEFAULT NULL::integer, IN _maximumcount integer DEFAULT NULL::integer, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext, IN _is_deleted boolean DEFAULT NULL::boolean, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
begin
 INSERT INTO productattribute(price,attributeid,name,description,productid,isrequired,isalergy,isglobal,controltype,companyid,noofselection,priority,minimumcount,maximumcount,createdby,isdeleted)
                       VALUES(_price,_attributeid,_name,_desc,_productid,_isrequired,_isalergy,_isglobal,_controltype,_companyid,_noofselection,_priority,_minimumcount,_maximumcount,_createdby,_is_deleted)
                        returning  id into _id;
END;
$$;


--
-- Name: createattributevalue(uuid, jsonb, integer, public.citext, jsonb, boolean, boolean, public.citext, boolean, integer, integer, integer, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createattributevalue(IN _attributeid uuid, IN _name jsonb, IN _priority integer, IN _price public.citext, IN _description jsonb DEFAULT NULL::jsonb, IN _isavailable boolean DEFAULT true, IN _isalergy boolean DEFAULT NULL::boolean, IN _weight public.citext DEFAULT NULL::public.citext, IN _ispreselected boolean DEFAULT false, IN _noofselection integer DEFAULT NULL::integer, IN _minimumcount integer DEFAULT NULL::integer, IN _maximumcount integer DEFAULT NULL::integer, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
INSERT INTO productattribute(
	attributeid,name, description, isavailable, isalergy, priority, ispreselected, price, weight,noofselection,minimumcount,maximumcount, createdby)
	VALUES (_attributeid,_name, _description, _isavailable,_isalergy, _priority, _ispreselected, _price, _weight,_noofselection,_minimumcount,_maximumcount,_createdby);END;
$$;


--
-- Name: createautoaccept(uuid, boolean); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createautoaccept(IN _branchid uuid, IN _isautoaccept boolean)
    LANGUAGE plpgsql
    AS $$
begin 

--use
update branch set isautoaccept = _isautoaccept,isautoprint = _isautoaccept where branch.id = _branchid;
END;
$$;


--
-- Name: createautoprint(uuid, boolean); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createautoprint(IN _branchid uuid, IN _isautoprint boolean)
    LANGUAGE plpgsql
    AS $$
begin 
--use
update branch set isautoprint = _isautoprint where branch.id = _branchid;
END;
$$;


--
-- Name: createbasiccompanyinfo(uuid, public.citext, text, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createbasiccompanyinfo(IN _companyid uuid, IN _type public.citext, IN _value text, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
INSERT INTO companyinfo(
	 companyid, type, value,createdby)
	VALUES (_companyid ,_type, _value,_createdby);
--call createlanguageresource('companyInfo',_keys,comapnyinfoid,_languagecode,1,_createdby);
END;
$$;


--
-- Name: createbranch(public.citext, uuid, integer, uuid, public.citext, uuid, timestamp without time zone, timestamp without time zone, public.citext, numeric, numeric, jsonb, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createbranch(IN _name public.citext, IN _companyid uuid, IN _status integer, IN _countryid uuid, IN _phonenumber public.citext, IN _addressid uuid, IN _opentime timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _closetime timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _addressname public.citext DEFAULT NULL::public.citext, IN _latitude numeric DEFAULT NULL::numeric, IN _longtitude numeric DEFAULT NULL::numeric, IN _namelanguage jsonb DEFAULT NULL::jsonb, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin
 INSERT INTO branch(name,companyid,status,countryid,phonenumber,addressid,opentime,closetime,addressname,latitude,longtitude, namelanguage,createdby)
            VALUES(_name,_companyid,_status,_countryid,_phonenumber,_addressid,_opentime,_closetime,_addressname,_latitude,_longtitude,_namelanguage ,_createdby);
END;
$$;


--
-- Name: createbranchaddress(uuid, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createbranchaddress(IN _branchid uuid DEFAULT NULL::uuid, IN _addressid uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
begin 
INSERT INTO public.branchaddress(branchid, addressid)
    VALUES(_branchid, _addressid);
END;
$$;


--
-- Name: createbranchavailability(uuid, public.citext, uuid, uuid, boolean, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createbranchavailability(IN _objectid uuid DEFAULT NULL::uuid, IN _objecttype public.citext DEFAULT NULL::public.citext, IN _branchid uuid DEFAULT NULL::uuid, IN _channelid uuid DEFAULT NULL::uuid, IN _isavailable boolean DEFAULT NULL::boolean, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin

    if (_isavailable = false) then
        INSERT INTO public.branchavailability(objectid, objecttype, branchid, channelid, createdby)
        VALUES (_objectid, _objecttype, _branchid, _channelid, _createdby);
    else
        DELETE
        FROM public.branchavailability
        where objectid = _objectid
          and objecttype = _objecttype
          and branchid = _branchid
          and channelid = _channelid;
    end if;
END;
$$;


--
-- Name: createbranchconfig(public.citext, uuid, uuid[], public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createbranchconfig(IN _type public.citext, IN _companyid uuid, IN _branchids uuid[], IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
 INSERT INTO branchorderconfig (type,companyid,branchids,createdby)
			  VALUES (_type,_companyid,_branchids,_createdby);
			

END;
$$;


--
-- Name: createbranchdeliverycompany(uuid, uuid, integer, integer); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createbranchdeliverycompany(IN _branchid uuid DEFAULT NULL::uuid, IN _deliverycompanyid uuid DEFAULT NULL::uuid, IN _maxdistance integer DEFAULT 10, IN _priority integer DEFAULT 1)
    LANGUAGE plpgsql
    AS $$
declare
branchid uuid = (select branchid from branchdelivery where branchid = _branchid limit 1)  ;
deliverycompanyid uuid = (select deliverycompanyid from branchdelivery where branchdelivery.deliverycompanyid = _deliverycompanyid limit 1) ;
begin 
if((select count(branchdelivery.id) from branchdelivery where branchdelivery.branchid = _branchid and branchdelivery.deliverycompanyid = _deliverycompanyid) > 0 ) THEN 
    if _branchid = branchid then update branchdelivery SET maxdistance = _maxdistance where branchdelivery.branchid = _branchid and branchdelivery.deliverycompanyid = _deliverycompanyid ; end if;
    if _branchid = branchid then update branchdelivery SET priority = _priority where branchdelivery.branchid = _branchid and branchdelivery.deliverycompanyid = _deliverycompanyid ; end if;

ELSE
 INSERT INTO public.branchdelivery(branchid, deliverycompanyid ,maxdistance,priority)
    VALUES(_branchid, _deliverycompanyid,_maxdistance,_priority);
END IF;
END;
$$;


--
-- Name: createbranchdeliverycost(uuid, uuid, numeric, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createbranchdeliverycost(IN _branchaddressid uuid, IN _addressdeliverycompanyid uuid, IN _deliverycost numeric, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
begin 
 INSERT INTO branchdeliveryaddress (branchaddress, branchdeliverycompany, deliverycost)
			  VALUES (_branchaddressid, _addressdeliverycompanyid, _deliverycost)
			  returning id into _id;
END;
$$;


--
-- Name: createbranchtemplate(uuid, public.citext, boolean, boolean, boolean, boolean, boolean, boolean, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createbranchtemplate(IN _branchid uuid, IN _type public.citext, IN _islogo boolean, IN _isrestaurantname boolean, IN _isphonenumber boolean, IN _isbranchname boolean, IN _isorderinfo boolean, IN _isproductinfo boolean, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 

--use
INSERT INTO public.branchtemplate(branchid ,type,islogo ,isrestaurantname ,isphonenumber ,isbranchname ,isorderinfo ,isproductinfo ,createdby) 
VALUES (_branchid,_type,_islogo,_isrestaurantname,_isphonenumber,_isbranchname,_isorderinfo,_isproductinfo,_createdby);
END;
$$;


--
-- Name: createcallcenterorder(uuid, uuid, uuid, numeric, public.citext, numeric, jsonb, timestamp without time zone, public.citext, numeric, uuid, uuid, public.citext, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createcallcenterorder(IN _customerid uuid, IN _branchid uuid, IN _ordersource uuid, IN _totalprice numeric, IN _paymenttype public.citext, IN _subtotalprice numeric, IN _price jsonb DEFAULT NULL::jsonb, IN _scheduled timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _notes public.citext DEFAULT NULL::public.citext, IN _deliveryprice numeric DEFAULT NULL::numeric, IN _deliveryaddress uuid DEFAULT NULL::uuid, IN _deliverytype uuid DEFAULT NULL::uuid, IN _referencenumber public.citext DEFAULT NULL::public.citext, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
declare  newstatus citext = '';
declare pr uuid;
begin 
 INSERT INTO public."order"
     (
      branchorderid,
      ordersource,
      scheduled,
      deliverytype,
      customerid,
      branchid,
      notes,
      totalprice,
      price,
      deliveryprice,
      deliveryaddress,
      subtotalprice,
      paymenttype,
      currentstatus,
      referencenumber,
      createdby)
              VALUES(
                     getorderseq(_branchid),
                     _ordersource,
                     _scheduled,
                     _deliverytype,
                     _customerid,
                     _branchid,
                     _notes,
                     _totalprice,
                     _price,
                     _deliveryprice,
                     _deliveryaddress,
                     _subtotalprice,
                     _paymenttype,
                     (select getfirststatusforbranch(_branchid)),
                     (json_build_object((select name from namelookup where id = _ordersource),_referencenumber))::jsonb,
                     _createdby)
			  returning id into _id;
              if((select isautoprint from branch where id = _branchid) = true)
              then
                INSERT INTO printingorder (id,branchid, orderid,printing)
                      VALUES(_id,_branchid,_id,false);
                INSERT INTO printingorderlogs (id,branchid, orderid,printing)
                      VALUES(_id,_branchid,_id,false);
                FOR pr IN (SELECT id from printers where branchid= _branchid) LOOP
                        INSERT INTO newprinter (orderid,companyid,branchid,printerid)
                             VALUES(_id,(select companyid from branch where id=_branchid),_branchid,pr);
                  END LOOP;
              end if;
               if((select coalesce(isautoaccept and  delay ='{"Min": 0, "Hour": 0}',false) from branch where id = _branchid))
              then
                 call setordernextstatus(_id,'AutoAccept',newstatus);
              end if;
END;
$$;


--
-- Name: createcalllog(uuid, public.citext, public.citext, public.citext, public.citext, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createcalllog(IN _companyid uuid, IN _status public.citext, IN _substatus public.citext, IN _notes public.citext, IN _customerphone public.citext, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
begin
 INSERT INTO calllog (companyid ,status,substatus,notes,customerphone,createdby)
			  VALUES (_companyid,_status,_substatus,_notes,_customerphone,_createdby)
			  returning id into _id;
END;
$$;


--
-- Name: createcareemcustomeraddress(uuid, public.citext, numeric, numeric, public.citext, public.citext, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createcareemcustomeraddress(IN _customerid uuid, IN _addressname public.citext, IN _latitude numeric, IN _longtitude numeric, IN _buildingno public.citext DEFAULT NULL::public.citext, IN _street public.citext DEFAULT NULL::public.citext, IN _details public.citext DEFAULT NULL::public.citext, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
declare aid uuid;
begin 
Insert INTO address(name , latitude , longtitude,buildingno , buildingno,streetno,address1,createdby ) 
values (concat (_addressname ,' - ',  (select name from customer where id = _customerid)),_latitude,_longtitude,_buildingno,_street,_details,'careem') 
returning id into aid;
INSERT INTO customeraddress (customerid,name,latitude,longtitude,details,addressid , createdby , streetname , buildingno)
VALUES(_customerid,_addressname,_latitude,_longtitude, _details,aid, 'careem',_street,_buildingno)
returning aid into _id;		
END;
$$;


--
-- Name: createcategory(public.citext, public.citext, uuid, public.citext, uuid, uuid, integer, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createcategory(IN _arname public.citext, IN _enname public.citext, IN _categorytag uuid, IN _image public.citext, IN _companyid uuid, IN _parentcategoryid uuid DEFAULT NULL::uuid, IN _displaynumber integer DEFAULT 1, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
declare categoryid uuid;
begin 

INSERT INTO category(name,categorytag,image,displaynumber, parentcategoryid,companyid,createdby)
	VALUES ((json_build_object('en' ,_enname, 'ar' , _arname)::jsonb),_categorytag,_image,_displaynumber,_parentcategoryid,_companyid,_createdby)
	returning id into categoryid;
	END;
$$;


--
-- Name: createcategoryreturningid(public.citext, public.citext, uuid, public.citext, uuid, uuid, integer, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createcategoryreturningid(IN _arname public.citext, IN _enname public.citext, IN _categorytag uuid, IN _image public.citext, IN _companyid uuid, IN _parentcategoryid uuid DEFAULT NULL::uuid, IN _displaynumber integer DEFAULT 1, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
begin

INSERT INTO category(name,categorytag,image,displaynumber, parentcategoryid,companyid,createdby)
	VALUES ((json_build_object('en' ,_enname, 'ar' , _arname)::jsonb),_categorytag,_image,_displaynumber,_parentcategoryid,_companyid,_createdby)
	returning id into _id;
	END;
$$;


--
-- Name: createcategoryreturningidforintegration(public.citext, public.citext, uuid, public.citext, uuid, uuid, integer, public.citext, boolean, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createcategoryreturningidforintegration(IN _arname public.citext, IN _enname public.citext, IN _categorytag uuid, IN _image public.citext, IN _companyid uuid, IN _parentcategoryid uuid DEFAULT NULL::uuid, IN _displaynumber integer DEFAULT 1, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext, IN _is_deleted boolean DEFAULT false, IN _externalposid public.citext DEFAULT NULL::public.citext, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
begin

INSERT INTO category(name,categorytag,image,displaynumber, parentcategoryid,companyid,createdby,isdeleted,external_pos_id)
	VALUES ((json_build_object('en' ,_enname, 'ar' , _arname)::jsonb),_categorytag,_image,_displaynumber,_parentcategoryid,_companyid,_createdby,_is_deleted,_externalposid)
	returning id into _id;
	END;
$$;


--
-- Name: createchannelmenu(uuid, public.citext, boolean, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createchannelmenu(IN _menuid uuid, IN _channel public.citext, IN _issync boolean, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin

DELETE FROM menuintegratiosync WHERE menuid =_menuid and channelid =(select nlp.id from namelookup nlp where nlp.name =_channel);
IF((Select nlk.name from namelookup nlk WHERE nlk.id = (select nlp.id from namelookup nlp where nlp.name =_channel) and nlk.tabletype ='ordersource') != 'callcenter')
THEN
INSERT INTO menuintegratiosync (menuid, channelid, issync, createdat, createdby)
			  VALUES (_menuid,(select nlp.id from namelookup nlp where nlp.name =_channel),_issync,now(),_createdby);
END IF;
END;
$$;


--
-- Name: createchatconversation(uuid, public.citext, public.citext, public.citext, public.citext, public.citext, public.citext, public.citext, boolean, boolean); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createchatconversation(IN _companyid uuid, IN _phonenumberfrom public.citext, IN _phonenumberto public.citext, IN _textbody public.citext, IN _chattype public.citext, IN _chatsource public.citext, IN _serialized public.citext, IN _chatbotsource public.citext, IN _isviewed boolean DEFAULT true, IN _isdelivered boolean DEFAULT true)
    LANGUAGE plpgsql
    AS $$
begin

INSERT INTO public.chatconversation(companyid, phonenumberfrom, phonenumberto, chattype, chatsource, serialized, isviewed, isdelivered,textbody,chatbotsource)
	VALUES (_companyid, _phonenumberfrom, _phonenumberto, _chattype, _chatsource, _serialized, _isviewed, _isdelivered, _textbody,_chatbotsource);

END;
$$;


--
-- Name: createclientintegration(uuid, uuid, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createclientintegration(IN _companyid uuid, IN _intcompanyid uuid, IN _name public.citext, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
 INSERT INTO createclientintegration (companyid, intcompanyid , name, createdby)
			 				  VALUES (_companyid, _intcompanyid, _name, _createdby);
			
END;
$$;


--
-- Name: createcompanychannels(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createcompanychannels(IN _companyid uuid, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin
insert into companychannels
select _companyid  as company, NL.id as ordersource  from namelookup NL
     where tabletype = 'ordersource';

END;
$$;


--
-- Name: createcompanyfaq(uuid, uuid, public.citext, public.citext, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createcompanyfaq(IN _id uuid DEFAULT NULL::uuid, IN _companyid uuid DEFAULT NULL::uuid, IN _question public.citext DEFAULT NULL::public.citext, IN _answer1 public.citext DEFAULT NULL::public.citext, IN _answer2 public.citext DEFAULT NULL::public.citext, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 

if _id is not null then
call updatecompanyfaq(_id,_question,_answer1,_answer2,_createdby);
else
 INSERT INTO public."companyfaq"(companyid,question,answer1,answer2,createdby)
              VALUES(_companyid,_question,_answer1,_answer2,_createdby);
end if;
END;
$$;


--
-- Name: createcompanyinfo(uuid, public.citext, text, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createcompanyinfo(IN _companyid uuid, IN _type public.citext, IN _value text, IN _languagecode public.citext DEFAULT 'en'::public.citext, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin
INSERT INTO companyinfo(
	 companyid, type, value,createdby)
	VALUES (_companyid ,_type, _value,_createdby);
--call createlanguageresource('companyInfo',_keys,comapnyinfoid,_languagecode,1,_createdby);
END;
$$;


--
-- Name: createcompanyinfonew(uuid, public.citext, text, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createcompanyinfonew(IN _companyid uuid, IN _type public.citext, IN _value text, IN _languagecode public.citext DEFAULT 'en'::public.citext, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
INSERT INTO companyinfo(
	 companyid, type, value,createdby)
	VALUES (_companyid ,_type, _value,_createdby);
--call createlanguageresource('companyInfo',_keys,comapnyinfoid,_languagecode,1,_createdby);
END;
$$;


--
-- Name: createcompanyreport(uuid, public.citext, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createcompanyreport(IN _companyid uuid, IN _reporttype public.citext, IN _link public.citext, IN _createdby public.citext)
    LANGUAGE plpgsql
    AS $$
begin
 INSERT INTO companyreports (companyid,reporttype,link,createdby)
			  VALUES (_companyid,_reporttype,_link,_createdby);
END;
$$;


--
-- Name: createcompanyservicechargebalance(uuid, uuid, public.citext, public.citext, public.citext, public.citext, integer, integer, integer); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createcompanyservicechargebalance(IN _companyid uuid, IN _serviceid uuid, IN _companyphoneid public.citext DEFAULT NULL::public.citext, IN _countrycode public.citext DEFAULT NULL::public.citext, IN _phonenumber public.citext DEFAULT NULL::public.citext, IN _whatsappphoneid public.citext DEFAULT NULL::public.citext, IN _chargebalance integer DEFAULT 0, IN _charlengthar integer DEFAULT NULL::integer, IN _charlengthen integer DEFAULT NULL::integer)
    LANGUAGE plpgsql
    AS $$

begin
    update companyservices set phonenumber = _phonenumber,
    whatsappid = _whatsappphoneid,
    whatsappcompanyid = _companyphoneid,
    counrtycode = _countrycode,
    chargebalance = _chargebalance,
    availablebalance = ((SELECT cs.availablebalance FROM companyservices cs where cs.companyid =_companyid and serviceid = _serviceid)+_chargebalance),
    updatedat = now() where companyid = _companyid and serviceid = _serviceid;
    
    if _charlengthar is not null then update companyservices set charlengthar = _charlengthar where companyid = _companyid and serviceid = _serviceid; end if;
    if _charlengthen is not null then update companyservices set charlengthen = _charlengthen where companyid = _companyid and serviceid = _serviceid; end if;

    INSERT INTO companyservicescharge(companyid, serviceid, chargebalance) VALUES (_companyid,_serviceid,_chargebalance);
   
end;
$$;


--
-- Name: createcompanyuser(public.citext, public.citext, public.citext, public.citext, public.citext, uuid[], uuid, uuid, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createcompanyuser(IN _usertype public.citext, IN _username public.citext, IN _email public.citext, IN _name public.citext, IN _phonenumber public.citext, IN _branchid uuid[], IN _companyid uuid, IN _keycloakid uuid, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
begin 
 INSERT INTO companyuser (keycloakid, usertype,username,email,name,phonenumber,branchid,companyid,createdby)
			  VALUES (_keycloakid,_usertype,_username,_email,_name,_phonenumber,_branchid,_companyid,_createdby)
			  returning id into _id;


END;
$$;


--
-- Name: createcompanywithinfo(public.citext, character varying, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createcompanywithinfo(IN name public.citext, IN logo character varying, IN type public.citext, IN createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
DECLARE companyid uuid;
begin 
INSERT INTO company(name,logo,createdby)
	VALUES(name,logo,createdby)
	RETURNING id INTO companyid;

INSERT INTO companyinfo(companyid, type, createdby)
	VALUES (companyid ,type,createdby);		
END;
$$;


--
-- Name: createcomplain(uuid, uuid, uuid, public.citext, public.citext, public.citext, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createcomplain(IN _customerid uuid, IN _branchid uuid, IN _orderstatuspossibilitiesid uuid, IN _category public.citext, IN _subcategory public.citext, IN _details public.citext, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
begin 
 INSERT INTO generalcomplain (customerid,branchid,orderstatuspossibilitiesid,category,subcategory,details,createdby)
			  VALUES (_customerid,_branchid,_orderstatuspossibilitiesid,_category,_subcategory,_details,_createdby)
			  returning id into _id;
			

END;
$$;


--
-- Name: createcopies(uuid, integer); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createcopies(IN _branchid uuid, IN _copies integer)
    LANGUAGE plpgsql
    AS $$
begin 

--use
update branch set copies = _copies where branch.id = _branchid;
END;
$$;


--
-- Name: createcoupon(uuid, integer, numeric, numeric, integer, integer, numeric, boolean, integer, uuid[], public.citext, timestamp without time zone, timestamp without time zone, timestamp without time zone, timestamp without time zone, numeric, boolean, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createcoupon(IN _offerid uuid DEFAULT NULL::uuid, IN _coupontype integer DEFAULT NULL::integer, IN _minprice numeric DEFAULT NULL::numeric, IN _maxprice numeric DEFAULT NULL::numeric, IN _minquantity integer DEFAULT NULL::integer, IN _maxquantity integer DEFAULT NULL::integer, IN _couponvalue numeric DEFAULT NULL::numeric, IN _isunlimited boolean DEFAULT false, IN _numberofuses integer DEFAULT NULL::integer, IN _customerids uuid[] DEFAULT NULL::uuid[], IN _code public.citext DEFAULT NULL::public.citext, IN _fromdate timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _todate timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _fromtime timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _totime timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _newprice numeric DEFAULT NULL::numeric, IN _ispercentage boolean DEFAULT false, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
INSERT INTO public.coupon(
	        coupontype, offerid, minprice, maxprice, minquantity, maxquantity, couponvalue, isunlimited, numberofuses, customerids, code, fromdate, todate, fromtime, totime, newprice, ispercentage,createdby)
    VALUES(_coupontype, _offerid,_minprice, _maxprice,_minquantity, _maxquantity, _couponvalue,_isunlimited,_numberofuses,_customerids,_code,_fromdate,_todate,_fromtime,_totime,_newprice, _ispercentage,_createdby);		
END;
$$;


--
-- Name: createcustomer(public.citext, date, public.citext, public.citext, public.citext, public.citext, public.citext, public.citext, uuid, numeric, public.citext, public.citext, public.citext, date, jsonb, public.citext, boolean, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createcustomer(IN _name public.citext, IN _dateofbirth date, IN _phoneno public.citext, IN _phoneno2 public.citext, IN _countrycode public.citext, IN _fullphonenumber public.citext, IN _email public.citext, IN _image public.citext, IN _channel uuid, IN _loyalitypoints numeric, IN _fb public.citext, IN _twitter public.citext, IN _instagram public.citext, IN _lastorderdate date, IN _blockdate jsonb, IN _notes public.citext, IN _isblocked boolean DEFAULT false, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
begin

insert into customer (name, dateofbirth, phoneno, phoneno2, countrycode, fullphonenumber,email, image, channel, loyalitypoints, fb, twitter, instagram,lastorderdate, notes,isblocked, blockdate, createdby) values (_name,_dateofbirth,_phoneno,_phoneno2, _countrycode, _fullphonenumber,_email,_image,_channel,_loyalitypoints,_fb,_twitter,_instagram,_lastorderdate,_notes ,_isblocked,_blockdate,_createdby)
    on conflict (phoneno) do update
        set name = _name, phoneno2 =_phoneno2 , countrycode = _countrycode, fullphonenumber = _fullphonenumber, email =_email, updatedat = now(), updatedby = _createdby
 returning id into _id;
END;
$$;


--
-- Name: createcustomer_ai(public.citext, public.citext, public.citext, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createcustomer_ai(IN _name public.citext, IN _phoneno public.citext, IN _email public.citext, IN _code public.citext, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 

INSERT INTO customer(id,name,phoneno,email,createdby,isblocked,createdat,ispublished,isdeleted,isverify,verifycode)
	VALUES (uuid_generate_v4(),_name,SUBSTRING("_phoneno", 4, 9),_email,_createdby,false,now(),true,false,false,_code);	
END;
$$;


--
-- Name: createcustomeraddress(uuid, uuid, public.citext, public.citext, public.citext, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createcustomeraddress(IN _customerid uuid, IN _addressid uuid, IN _buildingno public.citext DEFAULT NULL::public.citext, IN _streetname public.citext DEFAULT NULL::public.citext, IN _details public.citext DEFAULT NULL::public.citext, IN _name public.citext DEFAULT NULL::public.citext, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin
if((select COUNT(cusadd.customerid) from customeraddress cusadd where cusadd.customerid =_customerid and cusadd.addressid=_addressid)> 0)
then
if _buildingno is not null then update customeraddress SET buildingno = _buildingno , updatedat = now(), updatedby = _createdby where customerid =_customerid and addressid=_addressid; end if;
if _streetname is not null then update customeraddress SET streetname = _streetname , updatedat = now(), updatedby = _createdby where customerid =_customerid and addressid=_addressid; end if;
if _details is not null then update customeraddress SET details = _details , updatedat = now(), updatedby = _createdby where customerid =_customerid and addressid=_addressid; end if;
if _name is not null then update customeraddress SET name = _name , updatedat = now(), updatedby = _createdby where customerid =_customerid and addressid=_addressid; end if;
else
INSERT INTO customeraddress (customerid,addressid,buildingno,streetname,details,name,createdby)
            VALUES(_customerid, _addressid, _buildingno, _streetname, _details,_name, _createdby);

end if;
END;
$$;


--
-- Name: createcustomeraddress_ai(uuid, numeric, numeric, public.citext, public.citext, public.citext, public.citext, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createcustomeraddress_ai(IN _customerid uuid, IN _latitude numeric, IN _longtitude numeric, IN _buildingno public.citext DEFAULT NULL::public.citext, IN _details public.citext DEFAULT NULL::public.citext, IN _name public.citext DEFAULT NULL::public.citext, IN _departmentno public.citext DEFAULT NULL::public.citext, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
declare aid uuid;
begin 
Insert INTO address(name , latitude , longtitude ) 
values (concat (_name ,' - ',  (select name from customer where id = _customerid)),_latitude,_longtitude) 
returning id into aid;

INSERT INTO customeraddress (customerid,name,latitude,longtitude,details,addressid ,departmentno, createdby,buildingno,createdat,isdeleted)
VALUES(_customerid,_name,_latitude,_longtitude,_details,aid, _departmentno,_createdby,_buildingno,now(),false)
returning aid into _id;		
END;
$$;


--
-- Name: createcustomeraddress_ai(uuid, public.citext, numeric, numeric, public.citext, public.citext, public.citext, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createcustomeraddress_ai(IN _customerid uuid, IN _name public.citext, IN _latitude numeric DEFAULT NULL::numeric, IN _longtitude numeric DEFAULT NULL::numeric, IN _details public.citext DEFAULT 'SYSTEM'::public.citext, IN _buildingno public.citext DEFAULT NULL::public.citext, IN _streetname public.citext DEFAULT NULL::public.citext, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
declare aid uuid;
begin
if((select count(csad.customerid) from customeraddress csad where csad.customerid = _customerid and csad.latitude is not null and csad.longtitude is not null ) > 0 ) 
then
   if((select count(id) from getdistance(_customerid,_latitude,_longtitude) where distance < (100)::double precision) > 0 )
      then
         aid = (select id from getdistance(_customerid,_latitude,_longtitude) where distance < (100)::double precision order by distance ASC limit 1);
         call updatecustomeraddressbydistance_ai(_customerid,aid,_name,_latitude,_longtitude,_details,_buildingno,_streetname,_createdby);
         _id = aid ;
         else
          Insert INTO address(name , latitude , longtitude ) 
  values (concat (_name ,' - ',  (select name from customer where id = _customerid)),_latitude,_longtitude) 
  returning id into aid;
  INSERT INTO customeraddress (customerid,name,latitude,longtitude,details,addressid , createdby,buildingno,streetname,createdat)
  VALUES(_customerid,_name,_latitude,_longtitude, _details,aid, _createdby,_buildingno,_streetname,now())
  returning aid into _id;
    end if;
else
  Insert INTO address(name , latitude , longtitude ) 
  values (concat (_name ,' - ',  (select name from customer where id = _customerid)),_latitude,_longtitude) 
  returning id into aid;
  INSERT INTO customeraddress (customerid,name,latitude,longtitude,details,addressid , createdby,buildingno,streetname,createdat)
  VALUES(_customerid,_name,_latitude,_longtitude, _details,aid, _createdby,_buildingno,_streetname,now())
  returning aid into _id;
end if;
END;
$$;


--
-- Name: createcustomerpaymentdetail(public.citext, uuid, uuid, public.citext, public.citext, public.citext, public.citext, public.citext, public.citext, public.citext, public.citext, public.citext, public.citext, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createcustomerpaymentdetail(IN _hyperpayid public.citext, IN _customerid uuid, IN _companyid uuid, IN _registrationid public.citext, IN _paymentbrand public.citext, IN _description public.citext, IN _bin public.citext, IN _bincountry public.citext, IN _lastfourdigit public.citext, IN _holder public.citext, IN _expirymonth public.citext, IN _expiryyear public.citext, IN _bank public.citext, IN _cardtype public.citext, IN _level public.citext)
    LANGUAGE plpgsql
    AS $$
begin

if((select count(*) from customerpaymentdetail where customerid = _customerid and companyid =_companyid and bin = _bin and lastfourdigit = _lastfourdigit and expiryyear = _expiryyear and expirymonth = _expirymonth) = 0) then
        insert into customerpaymentdetail( hyperpayid ,customerid, companyid,registrationid ,paymentbrand ,description  ,bin ,bincountry ,lastfourdigit ,holder ,expirymonth  , expiryyear ,bank ,cardtype ,level)
        values ( _hyperpayid,_customerid,_companyid,_registrationid,_paymentbrand, _description,_bin,_bincountry,_lastfourdigit,_holder,_expirymonth,_expiryyear,_bank,_cardtype,_level );
else
    update customerpaymentdetail
        set registrationid = _registrationid,
            expiryyear = _expiryyear,
            expirymonth = _expirymonth
        where customerid = _customerid and companyid =_companyid and bin = _bin and lastfourdigit = _lastfourdigit;
end if;

END;
$$;


--
-- Name: createdelayedorders(uuid, timestamp without time zone); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createdelayedorders(INOUT _orderid uuid, IN _actiontime timestamp without time zone DEFAULT NULL::timestamp without time zone)
    LANGUAGE plpgsql
    AS $$
declare orderproductid uuid;
begin 

 INSERT INTO delayedorders (orderid, actiontime)
			  VALUES (_orderid,_actiontime);			

END;
$$;


--
-- Name: createdeliverycompany(jsonb, boolean, public.citext, uuid, timestamp without time zone, timestamp without time zone, public.citext, boolean, public.citext, public.citext, uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createdeliverycompany(IN _name jsonb, IN _isaggregated boolean, IN _phonenumber public.citext, IN _addressid uuid, IN _opentime timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _closetime timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _currency public.citext DEFAULT NULL::public.citext, IN _isavailable boolean DEFAULT true, IN _logo public.citext DEFAULT NULL::public.citext, IN _website public.citext DEFAULT NULL::public.citext, INOUT _id uuid DEFAULT NULL::uuid, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
INSERT INTO public.deliverycompany(
			name, isaggregated, opentime, closetime, currency, addressid, phonenumber, isavailable, logo, website,createdby)
	VALUES (_name, _isaggregated, _opentime,_closetime, _currency,_addressid, _phonenumber, _isavailable, _logo,_website,_createdby)
	returning id into _id;
	END;
$$;


--
-- Name: creatediscount(uuid, public.citext, public.citext, uuid[], uuid[], uuid[], uuid[], uuid[], uuid[], numeric, integer, integer, numeric, numeric, integer, boolean, integer, integer, integer, integer, timestamp without time zone, timestamp without time zone, timestamp without time zone, timestamp without time zone, integer[], public.citext, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.creatediscount(IN _companyid uuid, IN _name public.citext, IN _discounttype public.citext, IN _productids uuid[] DEFAULT NULL::uuid[], IN _attributeids uuid[] DEFAULT NULL::uuid[], IN _categoryids uuid[] DEFAULT NULL::uuid[], IN _channelids uuid[] DEFAULT NULL::uuid[], IN _branchids uuid[] DEFAULT NULL::uuid[], IN _customerids uuid[] DEFAULT NULL::uuid[], IN _discountvalue numeric DEFAULT NULL::numeric, IN _maxdiscountquantity integer DEFAULT NULL::integer, IN _mindiscountquantity integer DEFAULT NULL::integer, IN _maxdiscountprice numeric DEFAULT NULL::numeric, IN _mindiscountprice numeric DEFAULT NULL::numeric, IN _priority integer DEFAULT NULL::integer, IN _ispercentage boolean DEFAULT false, IN _discountpercent integer DEFAULT NULL::integer, IN _newprice integer DEFAULT NULL::integer, IN _percentvalue integer DEFAULT NULL::integer, IN _valuepercent integer DEFAULT NULL::integer, IN _fromtime timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _totime timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _fromdate timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _todate timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _daysofweek integer[] DEFAULT NULL::integer[], IN _promocode public.citext DEFAULT NULL::public.citext, IN _description public.citext DEFAULT NULL::public.citext, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
INSERT INTO public.discount(
	companyid,name,discounttype, productids,attributeids, categoryids, channelids, branchids, customerids, discountvalue, maxdiscountquantity, mindiscountquantity, maxdiscountprice, mindiscountprice, priority, ispercentage, discountpercent,newprice,percentvalue,valuepercent,fromtime, totime, fromdate, todate, daysofweek,promocode, description, createdby)
	VALUES(_companyid,_name,_discounttype, case when(_productids is not null) then _productids else (select getproductscategoryfordiscount(_categoryids))end, _attributeids, _categoryids, _channelids, _branchids, _customerids, _discountvalue, _maxdiscountquantity, _mindiscountquantity, _maxdiscountprice, _mindiscountprice, _priority, _ispercentage,_discountpercent,_newprice,_percentvalue,_valuepercent,_fromtime, _totime, _fromdate, _todate, _daysofweek, _promocode, _description,_createdby);		
END;
$$;


--
-- Name: creatediscountattribute(uuid, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.creatediscountattribute(IN _attributeid uuid, IN _discountid uuid)
    LANGUAGE plpgsql
    AS $$
begin 
INSERT INTO public.discountattribute(attributeid,discountid)
	VALUES(_attributeid,_discountid);
END;
$$;


--
-- Name: creatediscountchannelids(uuid, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.creatediscountchannelids(IN _channelid uuid, IN _discountid uuid)
    LANGUAGE plpgsql
    AS $$
begin 
INSERT INTO public.discounchannel(channelid,discountid)
	VALUES(_channelid,_discountid);
END;
$$;


--
-- Name: creatediscountinfo(uuid, public.citext, public.citext, numeric, public.citext, public.citext, integer, integer, integer, boolean, public.citext, integer[], timestamp without time zone, timestamp without time zone, boolean, numeric, numeric, integer, public.citext, uuid[], uuid[], uuid[], uuid[], uuid[], uuid[], uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.creatediscountinfo(IN _companyid uuid, IN _name public.citext, IN _discounttype public.citext, IN _discountvalue numeric DEFAULT NULL::numeric, IN _description public.citext DEFAULT NULL::public.citext, IN _promocode public.citext DEFAULT NULL::public.citext, IN _priority integer DEFAULT 1, IN _noofuse integer DEFAULT NULL::integer, IN _noofusefrocustomer integer DEFAULT NULL::integer, IN _isdaily boolean DEFAULT false, IN _level public.citext DEFAULT NULL::public.citext, IN _daysofweek integer[] DEFAULT NULL::integer[], IN _availablefrom timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _availableto timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _ispercentage boolean DEFAULT false, IN _maxdiscountprice numeric DEFAULT NULL::numeric, IN _mindiscountprice numeric DEFAULT NULL::numeric, IN _mindiscountquantity integer DEFAULT NULL::integer, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext, IN _productids uuid[] DEFAULT NULL::uuid[], IN _attributeids uuid[] DEFAULT NULL::uuid[], IN _categoryids uuid[] DEFAULT NULL::uuid[], IN _branchids uuid[] DEFAULT NULL::uuid[], IN _channelids uuid[] DEFAULT NULL::uuid[], IN _customerids uuid[] DEFAULT NULL::uuid[], INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
declare cid uuid;
declare pid uuid;
declare attid uuid;
declare brid uuid;
declare chid uuid;
begin
INSERT INTO public.discountinfo(
	companyid,name,type, value, description, promocode, priority, noofuse, noofusefrocustomer, isdaily, level,daysofweek,availablefrom,availableto, ispercentage, maxvalue, minprice, minquantity,createdby)
	VALUES(_companyid,_name,_discounttype,_discountvalue, _description, _promocode,_priority,_noofuse,_noofusefrocustomer,_isdaily,_level,_daysofweek,_availablefrom,_availableto,_ispercentage,_maxdiscountprice,_mindiscountprice,_mindiscountquantity,_createdby )
    returning id into _id;
if (_attributeids is null) then
  if(_productids is null) then --only categoryids
    if(_categoryids is not null) then
        foreach cid in array _categoryids loop
          FOR pid IN (select id from product where categoryid = cid)
	        LOOP
	           INSERT INTO public.discountproduct(productid, discountid)
	           VALUES(pid,_id);
	        END LOOP;
          end loop;
    end if;
     
else
        --there is products
    if(_productids is not null) then
        foreach pid in array _productids loop
           INSERT INTO public.discountproduct(productid, discountid)
	       VALUES(pid,_id);
        end loop;
    end if;
end if;
    else 
        --there is attributes
     if(_attributeids is not null) then
        foreach attid in array _attributeids loop
           INSERT INTO public.discountattribute(attributeid,discountid)
	       VALUES(attid,_id);
        end loop;
      end if;
end if;
 if(_branchids is not null) then
   foreach brid in array _branchids loop
           INSERT INTO public.discountbranch(branchid,discountid)
	       VALUES(brid,_id);
        end loop;
  end if;
 if(_channelids is not null) then
   foreach chid in array _channelids loop
           INSERT INTO public.discountchannel(channelid,discountid)
	       VALUES(chid,_id);
        end loop;
 end if;
END;
$$;


--
-- Name: creatediscountinfo(uuid, public.citext, public.citext, numeric, public.citext, public.citext, integer, integer, integer, boolean, public.citext, integer[], timestamp without time zone, timestamp without time zone, boolean, numeric, numeric, integer, public.citext, uuid[], uuid[], uuid[], uuid[], uuid[], uuid[], jsonb, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.creatediscountinfo(IN _companyid uuid, IN _name public.citext, IN _discounttype public.citext, IN _discountvalue numeric DEFAULT NULL::numeric, IN _description public.citext DEFAULT NULL::public.citext, IN _promocode public.citext DEFAULT NULL::public.citext, IN _priority integer DEFAULT 1, IN _noofuse integer DEFAULT NULL::integer, IN _noofusefrocustomer integer DEFAULT NULL::integer, IN _isdaily boolean DEFAULT false, IN _level public.citext DEFAULT NULL::public.citext, IN _daysofweek integer[] DEFAULT NULL::integer[], IN _availablefrom timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _availableto timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _ispercentage boolean DEFAULT false, IN _maxdiscountprice numeric DEFAULT NULL::numeric, IN _mindiscountprice numeric DEFAULT NULL::numeric, IN _mindiscountquantity integer DEFAULT NULL::integer, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext, IN _productids uuid[] DEFAULT NULL::uuid[], IN _attributeids uuid[] DEFAULT NULL::uuid[], IN _categoryids uuid[] DEFAULT NULL::uuid[], IN _branchids uuid[] DEFAULT NULL::uuid[], IN _channelids uuid[] DEFAULT NULL::uuid[], IN _customerids uuid[] DEFAULT NULL::uuid[], IN _descriptionlanguage jsonb DEFAULT NULL::jsonb, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
declare cid uuid;
declare pid uuid;
declare attid uuid;
declare brid uuid;
declare chid uuid;
begin
INSERT INTO public.discountinfo(
	companyid,name,type, value, description, promocode, priority, noofuse, noofusefrocustomer, isdaily, level,daysofweek,availablefrom,availableto, ispercentage, maxvalue, minprice, minquantity,createdby,descriptionlanguage)
	VALUES(_companyid,_name,_discounttype,_discountvalue, _description, _promocode,_priority,_noofuse,_noofusefrocustomer,_isdaily,_level,_daysofweek,_availablefrom,_availableto,_ispercentage,_maxdiscountprice,_mindiscountprice,_mindiscountquantity,_createdby,_descriptionlanguage )
    returning id into _id;
if (_attributeids is null) then
  if(_productids is null) then --only categoryids
    if(_categoryids is not null) then
        foreach cid in array _categoryids loop
          FOR pid IN (select id from product where categoryid = cid)
	        LOOP
	           INSERT INTO public.discountproduct(productid, discountid)
	           VALUES(pid,_id);
	        END LOOP;
          end loop;
    end if;
     
else
        --there is products
    if(_productids is not null) then
        foreach pid in array _productids loop
           INSERT INTO public.discountproduct(productid, discountid)
	       VALUES(pid,_id);
        end loop;
    end if;
end if;
    else 
        --there is attributes
     if(_attributeids is not null) then
        foreach attid in array _attributeids loop
           INSERT INTO public.discountattribute(attributeid,discountid)
	       VALUES(attid,_id);
        end loop;
      end if;
end if;
 if(_branchids is not null) then
   foreach brid in array _branchids loop
           INSERT INTO public.discountbranch(branchid,discountid)
	       VALUES(brid,_id);
        end loop;
  end if;
 if(_channelids is not null) then
   foreach chid in array _channelids loop
           INSERT INTO public.discountchannel(channelid,discountid)
	       VALUES(chid,_id);
        end loop;
 end if;
END;
$$;


--
-- Name: creatediscountproducts(uuid, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.creatediscountproducts(IN _productid uuid, IN _discountid uuid)
    LANGUAGE plpgsql
    AS $$
begin 
INSERT INTO public.discountproduct(productid,discountid)
	VALUES(_productid,_discountid);
END;
$$;


--
-- Name: createelicashcredentials(public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createelicashcredentials(IN _brandrefid public.citext, IN _companyid uuid)
    LANGUAGE plpgsql
    AS $$
begin
    insert into elicashcredentials(brandrefid, companyid)
    values
        (_brandrefid, _companyid)
    on conflict (companyid)
        do update
        set brandrefid = _brandrefid,
            companyid = _companyid,
            createdat = now();
END;
$$;


--
-- Name: createelicashuser(public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createelicashuser(IN _refid public.citext, IN _customerid uuid)
    LANGUAGE plpgsql
    AS $$
begin

    insert into elicashusers(refid, customerid)
    values (_refid, _customerid)
    on conflict (customerid) do update
        set refid = _refid,
            customerid = _customerid,
            createdat = now();

END;
$$;


--
-- Name: createhyperpaycredentials(uuid, public.citext, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createhyperpaycredentials(IN _restauranid uuid, IN _merchantid public.citext, IN _authid public.citext, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
begin
    insert into restaurantpaymentcredentials (rid, marchentname, username, password, marchent, authid)
    values                                   (_restauranid, 'system','system', 'system', _merchantid, _authid)
    on conflict (rid) do update
    set marchentname = 'system', username = 'sytem', password = 'systemm', marchent = _merchantid, authid = _authid
    returning rid into _id;
END;
$$;


--
-- Name: createintegrationcompany(public.citext, public.citext, public.citext, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createintegrationcompany(IN _name public.citext, IN _type public.citext, IN _phone public.citext, IN _logo public.citext DEFAULT NULL::public.citext, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
 INSERT INTO integrationcompany(name,logo,type,phone,createdby)
            VALUES(_name,_logo,_type,_phone,_createdby);		
END;
$$;


--
-- Name: createintegrationmiddlewarerequestlog(public.citext, public.citext, public.citext, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createintegrationmiddlewarerequestlog(IN _url public.citext, IN _method public.citext, IN _headers public.citext, IN _requestbody public.citext, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
begin
    insert into integrationmiddlewarerequestlog(url, "method" ,headers, requestbody) values (_url,_method,_headers,_requestbody)
    returning id into _id;
END;
$$;


--
-- Name: createinterfaceapirequestlog(public.citext, public.citext, public.citext, public.citext, public.citext, uuid, uuid, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createinterfaceapirequestlog(IN _url public.citext, IN _method public.citext, IN _headers public.citext, IN _requestbody public.citext, IN _requestby public.citext, IN _companyid uuid, IN _authuserid uuid, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$

begin
    insert into interfaceapirequestlog(url, "method" ,headers, requestbody,requestby,companyid,authuserid) values (_url,_method,_headers,_requestbody,_requestby,_companyid,_authuserid)
    returning id into _id;
END;
$$;


--
-- Name: createlanguageresource(public.citext, public.citext, uuid, public.citext, integer, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createlanguageresource(IN _key public.citext, IN _value public.citext, IN _objectid uuid, IN _languagecode public.citext, IN _type integer, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if(select case when (select resourceid from resourceexist(_languagecode,_objectid,_key,_type)) is null then true else false end) then 
INSERT INTO public.languageresource(
	 languageid, key, value, objectid, languagecode, type,createdby)
	VALUES ((select languageid from getlanguageid(_languagecode)),_key, _value, _objectid, _languagecode, _type,_createdby);
else 
UPDATE public.languageresource
	SET value=_value , updatedat = now() , updatedby = _createdby
	WHERE id = (select resourceid from resourceexist(_languagecode,_objectid,_key,_type));
	
end if;

END;
$$;


--
-- Name: createmenu(public.citext, uuid, uuid[], uuid[], uuid, boolean, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createmenu(IN _name public.citext, IN _companyid uuid, IN _branchids uuid[] DEFAULT NULL::uuid[], IN _productids uuid[] DEFAULT NULL::uuid[], INOUT _menuid uuid DEFAULT NULL::uuid, IN _isavailable boolean DEFAULT true, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
declare pid uuid;
begin 
INSERT INTO public.menu(name,isavailable,companyid, createdby) VALUES (_name,_isavailable,_companyid,_createdby)returning id into _menuid;
if _branchids is not null then
update branch set menuid = _menuid where branch.id = any (_branchids);
end if; 

if _productids is not null then 
FOREACH pid IN ARRAY _productids LOOP
	INSERT INTO menuproduct(menuid, productid,createdby) VALUES (_menuid, pid, _createdby);
  if(((select count(categoryid) from menucategories where menuid =_menuid and categoryid = (select categoryid from product where product.id = pid))<1 ))then
  insert into menucategories (menuid , categoryid) 
  values(_menuid , (select categoryid from product where product.id = pid));
  end if;
  END LOOP;
   
end if; 
END;
$$;


--
-- Name: createmenu(public.citext, uuid, uuid[], uuid[], uuid[], uuid, boolean, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createmenu(IN _name public.citext, IN _companyid uuid, IN _branchids uuid[] DEFAULT NULL::uuid[], IN _productids uuid[] DEFAULT NULL::uuid[], IN _channelids uuid[] DEFAULT NULL::uuid[], INOUT _menuid uuid DEFAULT NULL::uuid, IN _isavailable boolean DEFAULT true, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
declare pid uuid;
declare bid uuid;
begin
INSERT INTO public.menu(name,isavailable,companyid, createdby) VALUES (_name,_isavailable,_companyid,_createdby)returning id into _menuid;
if (select ((select id from namelookup where tabletype = 'ordersource' and name = 'callcenter')  = any(_channelids))) then
update branch set menuid = _menuid where branch.id = any (_branchids);
end if;

if _productids is not null then
FOREACH pid IN ARRAY _productids LOOP
	INSERT INTO menuproduct(menuid, productid,createdby) VALUES (_menuid, pid, _createdby);
  if(((select count(categoryid) from menucategories where menuid =_menuid and categoryid = (select categoryid from product where product.id = pid))<1 ))then
  insert into menucategories (menuid , categoryid)
  values(_menuid , (select categoryid from product where product.id = pid));
  end if;
  END LOOP;

end if;

if _channelids is not null then
   FOREACH pid IN ARRAY _channelids LOOP
      FOREACH bid IN ARRAY _branchids LOOP
       insert into menuchannel values (_menuid , pid,bid);
       END LOOP;
   END LOOP;
end if;

END;
$$;


--
-- Name: createmenuchannel(public.citext, uuid, public.citext, uuid[], uuid[], uuid, boolean, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createmenuchannel(IN _name public.citext, IN _companyid uuid, IN _channel public.citext, IN _branchids uuid[] DEFAULT NULL::uuid[], IN _productids uuid[] DEFAULT NULL::uuid[], INOUT _menuid uuid DEFAULT NULL::uuid, IN _isavailable boolean DEFAULT true, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
declare pid uuid;
begin 
INSERT INTO public.menu(name,isavailable,companyid, createdby) VALUES (_name,_isavailable,_companyid,_createdby)returning id into _menuid;
if _branchids is not null then
update branch set menuid = _menuid where branch.id = any (_branchids);
end if; 

if _productids is not null then 
FOREACH pid IN ARRAY _productids LOOP
	INSERT INTO menuproduct(menuid, productid,createdby) VALUES (_menuid, pid, _createdby);
  if(((select count(categoryid) from menucategories where menuid =_menuid and categoryid = (select categoryid from product where product.id = pid))<1 ))then
  insert into menucategories (menuid , categoryid) 
  values(_menuid , (select categoryid from product where product.id = pid));
  end if;
  END LOOP;
   
end if; 
END;
$$;


--
-- Name: createmenuintegrationsync(uuid, uuid, boolean, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createmenuintegrationsync(IN _menuid uuid, IN _channelid uuid, IN _issync boolean, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin

DELETE FROM menuintegratiosync WHERE menuid =_menuid and channelid =_channelid;
IF((Select nlk.name from namelookup nlk WHERE nlk.id = _channelid and nlk.tabletype ='ordersource') != 'callcenter')
THEN
INSERT INTO menuintegratiosync (menuid, channelid, issync, createdat, createdby)
			  VALUES (_menuid,_channelid,_issync,now(),_createdby);
END IF;
END;
$$;


--
-- Name: createmenuproduct(uuid, uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createmenuproduct(IN _menuid uuid, IN _productid uuid, IN _createdby public.citext DEFAULT 'system'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin
    INSERT INTO menuproduct(menuid, productid,createdby) VALUES (_menuid, _productid, _createdby);
END;
$$;


--
-- Name: createmenurequestlog(public.citext, public.citext, public.citext, public.citext, public.citext, uuid, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createmenurequestlog(IN _url public.citext, IN _method public.citext, IN _headers public.citext, IN _requestbody public.citext, IN _brandid public.citext, IN _companyid uuid, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$

begin
    insert into menurequestlog(url, "method" ,headers, requestbody,brandid, companyid) values (_url,_method,_headers,_requestbody,_brandid, _companyid)
    returning id into _id;
END;
$$;


--
-- Name: createnamelookup(public.citext, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createnamelookup(IN _name public.citext, IN _type public.citext, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 

 INSERT INTO namelookup(name,tabletype,createdby)
          VALUES(_name,_type,_createdby);
END;
$$;


--
-- Name: createnewonlineordercustomeraddress(uuid, public.citext, numeric, numeric, public.citext, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createnewonlineordercustomeraddress(IN _customerid uuid, IN _name public.citext, IN _latitude numeric DEFAULT NULL::numeric, IN _longtitude numeric DEFAULT NULL::numeric, IN _details public.citext DEFAULT 'SYSTEM'::public.citext, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$

declare aid uuid;
begin
if((select count(csad.customerid) from customeraddress csad where csad.customerid = _customerid and csad.latitude is not null and csad.longtitude is not null ) > 0 ) 
then
    if((select count(id) from getdistance(_customerid,_latitude,_longtitude) where distance < 100) > 0 ) 
 then
    aid = (select id from getdistance(_customerid,_latitude,_longtitude) where distance < 100 order by distance ASC limit 1);
    call updatecustomeraddressbydistance(_customerid,aid,_name,_latitude,_longtitude,_details,null,null,_createdby);
    _id= aid ;
 else
    Insert INTO address(name , latitude , longtitude )
    values (concat (_name ,' - ',  (select name from customer where id = _customerid)),_latitude,_longtitude)
    returning id into aid;
    INSERT INTO customeraddress (customerid,name,latitude,longtitude,details,addressid , createdby)
    VALUES(_customerid,_name,_latitude,_longtitude, _details,aid, _createdby)
    returning aid into _id;
   end if;
else
   Insert INTO address(name , latitude , longtitude )
   values (concat (_name ,' - ',  (select name from customer where id = _customerid)),_latitude,_longtitude)
   returning id into aid;
   INSERT INTO customeraddress (customerid,name,latitude,longtitude,details,addressid , createdby)
   VALUES(_customerid,_name,_latitude,_longtitude, _details,aid, _createdby)
   returning aid into _id;
end if;

END;
$$;


--
-- Name: createnewonlineordering(uuid, uuid, numeric, public.citext, numeric, jsonb, timestamp without time zone, public.citext, numeric, uuid, uuid, public.citext, boolean, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createnewonlineordering(IN _customerid uuid, IN _branchid uuid, IN _totalprice numeric, IN _paymenttype public.citext, IN _subtotalprice numeric, IN _price jsonb DEFAULT NULL::jsonb, IN _scheduled timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _notes public.citext DEFAULT NULL::public.citext, IN _deliveryprice numeric DEFAULT NULL::numeric, IN _deliveryaddress uuid DEFAULT NULL::uuid, IN _deliverytype uuid DEFAULT NULL::uuid, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext, IN _chatbotsource boolean DEFAULT false, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
declare  newstatus citext = '';
begin 
 INSERT INTO public."order"
     (
      branchorderid,
      ordersource,
      scheduled,
      deliverytype,
      customerid,
      branchid,
      notes,
      totalprice,
      price,
      deliveryprice,
      deliveryaddress,
      subtotalprice,
      paymenttype,
      currentstatus,
      createdby)
              VALUES(
                     getorderseq(_branchid),
                     case when _chatbotsource = false then 'd43d0969-837d-474f-abe0-75d6181d44af'::uuid else '79401a8a-0d53-4988-a08d-31d1b3514919'::uuid end,
                     _scheduled,
                     _deliverytype,
                     _customerid,
                     _branchid,
                     _notes,
                     _totalprice,
                     _price,
                     _deliveryprice,
                     _deliveryaddress,
                     _subtotalprice,
                     _paymenttype,
                     (select getfirststatusforbranch(_branchid)),
                     _createdby)
			  returning id into _id;
              if((select isautoprint from branch where id = _branchid) = true)
              then
                INSERT INTO printingorder (branchid, orderid)
                VALUES(_branchid,_id);
              end if;
                if((select coalesce(isautoaccept and  delay ='{"Min": 0, "Hour": 0}',false) from branch where id = _branchid))
              then
                 call setordernextstatus(_id,'AutoAccept',newstatus);
              end if;
END;
$$;


--
-- Name: createnewonlineordering(uuid, uuid, numeric, public.citext, public.citext, numeric, jsonb, timestamp without time zone, public.citext, numeric, uuid, uuid, public.citext, boolean, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createnewonlineordering(IN _customerid uuid, IN _branchid uuid, IN _totalprice numeric, IN _paymenttype public.citext, IN _numberofpeople public.citext, IN _subtotalprice numeric, IN _price jsonb DEFAULT NULL::jsonb, IN _scheduled timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _notes public.citext DEFAULT NULL::public.citext, IN _deliveryprice numeric DEFAULT NULL::numeric, IN _deliveryaddress uuid DEFAULT NULL::uuid, IN _deliverytype uuid DEFAULT NULL::uuid, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext, IN _chatbotsource boolean DEFAULT false, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
declare  newstatus citext = '';
begin 
 INSERT INTO public."order"
     (
      branchorderid,
      ordersource,
      scheduled,
      deliverytype,
      customerid,
      branchid,
      notes,
      totalprice,
      price,
      deliveryprice,
      deliveryaddress,
      subtotalprice,
      paymenttype,
      numberofpeople,
      currentstatus,
      createdby)
              VALUES(
                     getorderseq(_branchid),
                     case when _chatbotsource = false then 'd43d0969-837d-474f-abe0-75d6181d44af'::uuid else '79401a8a-0d53-4988-a08d-31d1b3514919'::uuid end,
                     _scheduled,
                     _deliverytype,
                     _customerid,
                     _branchid,
                     _notes,
                     _totalprice,
                     _price,
                     _deliveryprice,
                     _deliveryaddress,
                     _subtotalprice,
                     _paymenttype,
                     _numberofpeople,
                     (select getfirststatusforbranch(_branchid)),
                     _createdby)
			  returning id into _id;
              if((select isautoprint from branch where id = _branchid) = true)
              then
                INSERT INTO printingorder (branchid, orderid)
                VALUES(_branchid,_id);
              end if;
                if((select coalesce(isautoaccept and  delay ='{"Min": 0, "Hour": 0}',false) from branch where id = _branchid))
              then
                 call setordernextstatus(_id,'AutoAccept',newstatus);
              end if;

END;
$$;


--
-- Name: createnewonlineordering(uuid, uuid, numeric, public.citext, public.citext, numeric, jsonb, timestamp without time zone, public.citext, numeric, uuid, uuid, public.citext, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createnewonlineordering(IN _customerid uuid, IN _branchid uuid, IN _totalprice numeric, IN _paymenttype public.citext, IN _numberofpeople public.citext, IN _subtotalprice numeric, IN _price jsonb DEFAULT NULL::jsonb, IN _scheduled timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _notes public.citext DEFAULT NULL::public.citext, IN _deliveryprice numeric DEFAULT NULL::numeric, IN _deliveryaddress uuid DEFAULT NULL::uuid, IN _deliverytype uuid DEFAULT NULL::uuid, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext, IN _ordersource public.citext DEFAULT 'OnlineOrdering'::public.citext, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
    declare  newstatus citext = '';
declare pr uuid;

begin 
 INSERT INTO public."order"
     (
      branchorderid,
      ordersource,
      scheduled,
      deliverytype,
      customerid,
      branchid,
      notes,
      totalprice,
      price,
      deliveryprice,
      deliveryaddress,
      subtotalprice,
      paymenttype,
      numberofpeople,
      currentstatus,
      createdby)
              VALUES(
                     getorderseq(_branchid),
                     --case when _chatbotsource = false then 'd43d0969-837d-474f-abe0-75d6181d44af'::uuid else '79401a8a-0d53-4988-a08d-31d1b3514919'::uuid end,
                     (select id from namelookup where tabletype = 'ordersource' and name = _ordersource)::uuid,
                     _scheduled,
                     _deliverytype,
                     _customerid,
                     _branchid,
                     _notes,
                     _totalprice,
                     _price,
                     _deliveryprice,
                     _deliveryaddress,
                     _subtotalprice,
                     _paymenttype,
                     _numberofpeople,
                     (select getfirststatusforbranch(_branchid)),
                     _createdby)
			  returning id into _id;
              if((select isautoprint from branch where id = _branchid) = true)
              then
                INSERT INTO printingorder (branchid, orderid)
                VALUES(_branchid,_id);
                FOR pr IN (SELECT id from printers where branchid= _branchid) LOOP
                        INSERT INTO newprinter (orderid,companyid,branchid,printerid)
                             VALUES(_id,(select companyid from branch where id=_branchid),_branchid,pr);
                  END LOOP;
              end if;
                if((select coalesce(isautoaccept and  delay ='{"Min": 0, "Hour": 0}',false) from branch where id = _branchid))
              then
                 call setordernextstatus(_id,'AutoAccept',newstatus);
              end if;
END;
$$;


--
-- Name: createnotification(public.citext, uuid, integer[], uuid[], public.citext, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createnotification(IN _subject public.citext, IN _companyid uuid, IN _category integer[] DEFAULT NULL::integer[], IN _customer uuid[] DEFAULT NULL::uuid[], IN _title public.citext DEFAULT NULL::public.citext, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
declare caid integer;
declare cuid uuid;
begin
 INSERT INTO public."notification"(subject,title,companyid,category,createdby)
              VALUES(_subject,_title,_companyid,_category,_createdby)
			  returning id into _id;

if(_customer is null) then --only categoryids
    if(_category is not null) then
        foreach caid in array _category loop
          FOR cuid IN (select customerid from statuslog where status = caid and restaurantid = _companyid)
	        LOOP
	           INSERT INTO public.notificationfollowup(notificationid, customerid)
	           VALUES(_id,cuid);
	        END LOOP;
          end loop;
    end if;
 else
     foreach cuid in array _customer loop
            INSERT INTO public.notificationfollowup(notificationid, customerid)
	        VALUES(_id,cuid);
     end loop;
 end if;
END;
$$;


--
-- Name: createnotification(text, integer, uuid, integer, uuid[], timestamp without time zone, timestamp without time zone, boolean, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createnotification(IN _subject text, IN _type integer, IN _companyid uuid, IN _priority integer, IN _branchid uuid[], IN _startdate timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _starttime timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _urgent boolean DEFAULT false, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
begin 
 INSERT INTO public."notification"(subject,type,startdate,starttime,companyid,urgent,priority,createdby)
              VALUES(_subject,_type,_startdate,_starttime,_companyid,_urgent,_priority,_createdby)	
			  returning id into _id;
			  
INSERT INTO public."notificationfollowup"(notificationid,branchid)
              VALUES(_id,_branchid);
END;
$$;


--
-- Name: createoffer(public.citext, jsonb, jsonb, integer, integer, uuid[], uuid[], timestamp without time zone, timestamp without time zone, timestamp without time zone, timestamp without time zone, integer[], integer, integer, integer, integer, integer, integer, numeric, numeric, integer, integer, integer, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createoffer(IN _offertype public.citext DEFAULT NULL::public.citext, IN _productids jsonb DEFAULT NULL::jsonb, IN _productactions jsonb DEFAULT NULL::jsonb, IN _ispercentage integer DEFAULT NULL::integer, IN _offeraction integer DEFAULT NULL::integer, IN _branchids uuid[] DEFAULT NULL::uuid[], IN _channelids uuid[] DEFAULT NULL::uuid[], IN _fromdate timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _todate timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _fromtime timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _totime timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _daysofweek integer[] DEFAULT NULL::integer[], IN _priority integer DEFAULT NULL::integer, IN _discounvalue integer DEFAULT NULL::integer, IN _discounpercent integer DEFAULT NULL::integer, IN _maxpercent integer DEFAULT NULL::integer, IN _maxofferquantity integer DEFAULT NULL::integer, IN _minofferquantity integer DEFAULT NULL::integer, IN _maxofferprice numeric DEFAULT NULL::numeric, IN _minofferprice numeric DEFAULT NULL::numeric, IN _newprice integer DEFAULT NULL::integer, IN _percentvalue integer DEFAULT NULL::integer, IN _valuepercent integer DEFAULT NULL::integer, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
begin 
INSERT INTO public.offer(offertype, productids,productactions,ispercentage,offeraction,branchids, channelids, fromdate, todate, fromtime, totime, daysofweek, priority,discounvalue,discounpercent,maxpercent,maxofferquantity,minofferquantity,maxofferprice,minofferprice,newprice,percentvalue,valuepercent,createdby)
                VALUES  (_offertype,_productids,_productactions,_ispercentage,_offeraction, _branchids, _channelids, _fromdate, _todate, _fromtime, _totime, _daysofweek, _priority,_discounvalue,_discounpercent,_maxpercent,_maxofferquantity,_minofferquantity,_maxofferprice,_minofferprice,_newprice,_percentvalue,_valuepercent,_createdby)
				returning id into _id;		
END;
$$;


--
-- Name: createofferaction(integer, uuid, uuid, integer[], uuid, numeric, boolean, numeric, numeric, numeric, integer, integer, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createofferaction(IN _quantity integer DEFAULT NULL::integer, IN _categoryid uuid DEFAULT NULL::uuid, IN _productid uuid DEFAULT NULL::uuid, IN _attributes integer[] DEFAULT NULL::integer[], IN _offerid uuid DEFAULT NULL::uuid, IN _newprice numeric DEFAULT NULL::numeric, IN _ispercentage boolean DEFAULT false, IN _discountvalue numeric DEFAULT NULL::numeric, IN _maxdiscountprice numeric DEFAULT NULL::numeric, IN _mindiscountprice numeric DEFAULT NULL::numeric, IN _maxdiscountquantity integer DEFAULT NULL::integer, IN _mindiscountquantity integer DEFAULT NULL::integer, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
INSERT INTO public.offeraction(
	        quantity, categoryid, productid, attributes, offerid, newprice, ispercentage, discountvalue, maxdiscountprice, mindiscountprice, maxdiscountquantity, mindiscountquantity, createdby)
    VALUES(_quantity, _categoryid,_productid, _attributes,_offerid, _newprice, _ispercentage,_discountvalue,_maxdiscountprice,_mindiscountprice,_maxdiscountquantity,_mindiscountquantity,_createdby);		
END;
$$;


--
-- Name: createofferimages(public.citext, uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createofferimages(IN _imagepath public.citext, IN _companyid uuid, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
 INSERT INTO offerimage (imagepath,companyid,createdby)
			  VALUES (_imagepath,_companyid,_createdby);
			

END;
$$;


--
-- Name: createonlineaddress(uuid, numeric, numeric, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createonlineaddress(IN _customerid uuid, IN _latitude numeric, IN _longtitude numeric, IN _name public.citext DEFAULT 'SYSTEM'::public.citext, IN _details public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
 INSERT INTO customeraddress (customerid,latitude,longtitude,name,details)
            VALUES(_customerid, _latitude, _longtitude,_name, _details);		
END;
$$;


--
-- Name: createonlineorderconfig(uuid, public.citext, public.citext, uuid[], public.citext, public.citext, public.citext, public.citext, timestamp without time zone, timestamp without time zone, timestamp without time zone, public.citext, boolean, boolean, uuid[], uuid[], uuid[], public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createonlineorderconfig(IN _companyid uuid, IN _bio public.citext, IN _language public.citext, IN _selectedservices uuid[], IN _logo public.citext, IN _registrationphoto public.citext, IN _themecolor public.citext, IN _buttoncolor public.citext, IN _reservationtime timestamp without time zone, IN _ordertime timestamp without time zone, IN _preparetime timestamp without time zone, IN _restaurantdomain public.citext, IN _issms boolean, IN _istrackorder boolean, IN _pickupbranchids uuid[], IN _dineinbranchids uuid[], IN _deliverybranchids uuid[], IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin
delete from "orderconfig" where companyid = _companyid;
delete from companyinfo where "companyinfo".type = 'Bio' and companyid = _companyid;
 INSERT INTO orderconfig (companyid,language,selectedservices,logo,registrationphoto,themecolor,buttoncolor,reservationtime,ordertime,preparetime,restaurantdomain,issms,istrackOrder,pickupbranchids,dineinbranchids,deliverybranchids,createdby)
			  VALUES (_companyid,_language,_selectedservices,_logo,_registrationphoto,_themecolor,_buttoncolor,_reservationtime,_ordertime,_preparetime,_restaurantdomain,_issms,_istrackOrder,_pickupbranchids,_dineinbranchids,_deliverybranchids,_createdby);
 if _companyid is not null then call createcompanyinfo (_companyid,'Bio',_bio); end if;
 if _logo is not null then update company set logo = _logo where id = _companyid; end if ;
END;
$$;


--
-- Name: createonlineorderconfignew(uuid, uuid[], uuid[], uuid[], uuid[], public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createonlineorderconfignew(IN _companyid uuid, IN _selectedservices uuid[], IN _pickupbranchids uuid[], IN _dineinbranchids uuid[], IN _deliverybranchids uuid[], IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin


if((select count(*) from orderconfig where companyid = _companyid) > 0 )
then
  update orderconfig set selectedservices = _selectedservices, updatedat = now(), updatedby = _createdby where companyid = _companyid;
 update orderconfig set pickupbranchids = _pickupbranchids, updatedat = now(), updatedby = _createdby where companyid = _companyid;
 update orderconfig set dineinbranchids = _dineinbranchids, updatedat = now(), updatedby = _createdby where companyid = _companyid;
 update orderconfig set deliverybranchids = _deliverybranchids, updatedat = now(), updatedby = _createdby where companyid = _companyid;
else
INSERT INTO orderconfig (companyid,selectedservices,pickupbranchids,dineinbranchids,deliverybranchids,createdby)
			  VALUES (_companyid,_selectedservices,_pickupbranchids,_dineinbranchids,_deliverybranchids,_createdby);
end if;
END;
$$;


--
-- Name: createonlineorderimages(uuid, public.citext, public.citext, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createonlineorderimages(IN _companyid uuid, IN _logo public.citext, IN _registrationphoto public.citext, IN _offerlogo public.citext, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin
if((select count(*) from orderconfig where companyid = _companyid) > 0 )
then
 if _logo is not null then update orderconfig set logo = _logo, updatedat = now(), updatedby = _createdby where companyid = _companyid; end if ;
 if _registrationphoto is not null then update orderconfig set registrationphoto = _registrationphoto, updatedat = now(), updatedby = _createdby where companyid = _companyid; end if ; 
 if _offerlogo is not null then update orderconfig set offerlogo = _offerlogo, updatedat = now(), updatedby = _createdby where companyid = _companyid; end if ; 
else
INSERT INTO orderconfig (companyid,logo,registrationphoto,offerlogo,createdby)
			 VALUES (_companyid,_logo,_registrationphoto,_offerlogo,_createdby);
end if;
END;
$$;


--
-- Name: createonlineorderinfo(uuid, public.citext, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createonlineorderinfo(IN _companyid uuid, IN _restaurantdomain public.citext, IN _aboutus public.citext, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin
if((select count(*) from orderconfig where companyid = _companyid) > 0 )
then
 if _restaurantdomain is not null then update orderconfig set restaurantdomain = _restaurantdomain, updatedat = now(), updatedby = _createdby where companyid = _companyid; end if ;
else
INSERT INTO orderconfig (companyid,restaurantdomain,createdby)
			  VALUES (_companyid,_restaurantdomain,_createdby);
end if;

if((select count(*) from companyinfo where "companyinfo".type = 'Bio' and companyid = _companyid) > 0 )
then
 if _aboutus is not null then update companyinfo set value = _aboutus where "companyinfo".type = 'Bio' and companyid = _companyid; end if ;
 else
 if _companyid is not null then call createcompanyinfo (_companyid,'Bio',_aboutus); end if;
 end if;
END;
$$;


--
-- Name: createonlineorderingcustomeraddress(uuid, public.citext, numeric, numeric, public.citext, uuid, public.citext, public.citext, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createonlineorderingcustomeraddress(IN _customerid uuid, IN _name public.citext, IN _latitude numeric DEFAULT NULL::numeric, IN _longtitude numeric DEFAULT NULL::numeric, IN _details public.citext DEFAULT 'SYSTEM'::public.citext, IN _labeladdressid uuid DEFAULT NULL::uuid, IN _buildingno public.citext DEFAULT NULL::public.citext, IN _streetname public.citext DEFAULT NULL::public.citext, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
declare aid uuid;
begin
if((select count(csad.customerid) from customeraddress csad where csad.customerid = _customerid and csad.latitude is not null and csad.longtitude is not null ) > 0 )
then
   if((select count(id) from getdistance(_customerid,_latitude,_longtitude) where distance < (100)::double precision) > 0 )
      then
         aid = (select id from getdistance(_customerid,_latitude,_longtitude) where distance < (100)::double precision order by distance ASC limit 1);
         call updatecustomeraddressbydistance(_customerid,aid,_name,_latitude,_longtitude,_details,_buildingno,_streetname,_createdby);
         _id = aid ;
         else
          Insert INTO address(name , latitude , longtitude )
  values (concat (_name ,' - ',  (select name from customer where id = _customerid)),_latitude,_longtitude)
  returning id into aid;
  INSERT INTO customeraddress (customerid,name,latitude,longtitude,details,addressid , createdby,labeladdressid,buildingno,streetname)
  VALUES(_customerid,_name,_latitude,_longtitude, _details,aid, _createdby,_labeladdressid,_buildingno,_streetname)
  returning aid into _id;
    end if;
else
  Insert INTO address(name , latitude , longtitude )
  values (concat (_name ,' - ',  (select name from customer where id = _customerid)),_latitude,_longtitude)
  returning id into aid;
  INSERT INTO customeraddress (customerid,name,latitude,longtitude,details,addressid , createdby,labeladdressid,buildingno,streetname)
  VALUES(_customerid,_name,_latitude,_longtitude, _details,aid, _createdby,_labeladdressid,_buildingno,_streetname)
  returning aid into _id;
end if;
END;
$$;


--
-- Name: createonlineorderingdeliveryaddress(uuid, public.citext, public.citext, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createonlineorderingdeliveryaddress(IN _customerid uuid, IN _name public.citext, IN _details public.citext DEFAULT 'SYSTEM'::public.citext, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
declare aid uuid;
begin 
Insert INTO address(name) 
values (concat (_name ,' - ',  (select name from customer where id = _customerid))) 
returning id into aid;
INSERT INTO customeraddress (customerid,name,details,addressid , createdby)
VALUES(_customerid,_name, _details,aid, _createdby)
returning aid into _id;		
END;
$$;


--
-- Name: createonlineordertheme(uuid, public.citext, public.citext, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createonlineordertheme(IN _companyid uuid, IN _themecolor public.citext, IN _buttoncolor public.citext, IN _restaurantdomain public.citext, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin
if((select count(*) from orderconfig where companyid = _companyid) > 1 )
then
 if _themecolor is not null then update orderconfig set themecolor = _themecolor, updatedat = now(), updatedby = _createdby where companyid = _companyid; end if ;
 if _buttoncolor is not null then update orderconfig set buttoncolor = _buttoncolor, updatedat = now(), updatedby = _createdby where companyid = _companyid; end if ; 
 if _restaurantdomain is not null then update orderconfig set restaurantdomain = _restaurantdomain, updatedat = now(), updatedby = _createdby where companyid = _companyid; end if ; 
else
INSERT INTO orderconfig (companyid,themecolor,buttoncolor,restaurantdomain,createdby)
			  VALUES (_companyid,_themecolor,_buttoncolor,_restaurantdomain,_createdby);
end if;
END;
$$;


--
-- Name: createoption(public.citext, public.citext, uuid, uuid, integer, jsonb, boolean, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createoption(IN _languagecode public.citext, IN _name public.citext, IN _suboptionid uuid, IN _attributeid uuid, IN _quantity integer, IN _price jsonb, IN _ispreselected boolean DEFAULT false, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
declare optionid uuid;
begin 

 INSERT INTO public.option(
	        suboptionid, attributeid, ispreselected, quantity, price,createdby)
	VALUES (_suboptionid,_attributeid,_ispreselected,_quantity,_price,_createdby)
	returning id into optionid;
			
INSERT INTO languageresource(
	 languageid, key, value, objectid, languagecode, type, createdby)
	VALUES (getlanguageid(_languagecode),'optionName', _name, optionid,_languagecode , 1,_createdby);
			
END;
$$;


--
-- Name: createorder(uuid, uuid, uuid, numeric, public.citext, numeric, jsonb, timestamp without time zone, public.citext, numeric, uuid, uuid, jsonb, public.citext, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createorder(IN _customerid uuid, IN _branchid uuid, IN _ordersource uuid, IN _totalprice numeric, IN _paymenttype public.citext, IN _subtotalprice numeric, IN _price jsonb DEFAULT NULL::jsonb, IN _scheduled timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _notes public.citext DEFAULT NULL::public.citext, IN _deliveryprice numeric DEFAULT NULL::numeric, IN _deliveryaddress uuid DEFAULT NULL::uuid, IN _deliverytype uuid DEFAULT NULL::uuid, IN _referencenumber jsonb DEFAULT '{}'::json, IN _referencenumber2 public.citext DEFAULT NULL::public.citext, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
declare  newstatus citext = '';
declare pr uuid;
declare _currstatus citext = (select osp1.status from orderstatuspossibilities1 osp1 where osp1.isfirststatus = true);
declare _nextstatus citext;

begin
 INSERT INTO public."order"
     (
      branchorderid,
      ordersource,
      scheduled,
      deliverytype,
      customerid,
      branchid,
      notes,
      totalprice,
      price,
      deliveryprice,
      deliveryaddress,
      subtotalprice,
      paymenttype,
      currentstatus,
      referencenumber,
      referencenumber2,
      createdby
      )
              VALUES(
                     getorderseq(_branchid),
                     _ordersource,
                     _scheduled,
                     _deliverytype,
                     _customerid,
                     _branchid,
                     _notes,
                     _totalprice,
                     _price,
                     _deliveryprice,
                     _deliveryaddress,
                     _subtotalprice,
                     _paymenttype,
                     --(select getfirststatusforbranch(_branchid)), --old
                      (select osp1.id from orderstatuspossibilities1 osp1 where osp1.isfirststatus = true),
                     _referencenumber,
                     _referencenumber2,
                     _createdby
                     )
			  returning id into _id;
                call createorderhistory(_id,_currstatus,'',_createdby); -- new
               if((select coalesce(isautoaccept and  delay ='{"Min": 0, "Hour": 0}',false) from branch where id = _branchid))
              then
                  --call setordernextstatus(_id,'AutoAccept',newstatus); --old
                 call settopreparingstatus(_id, 'AutoAccept'); --new
                  _nextstatus = (select osp1.status from orderstatuspossibilities1 osp1 where osp1.id = (select o.currentstatus from "order" o where o.id = _id )); --new
                 call createorderhistory(_id,_nextstatus,_createdby); -- new
              end if;
END;
$$;


--
-- Name: createorderfollowup(uuid, public.citext, boolean, boolean, boolean, public.citext, public.citext, uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createorderfollowup(IN _id uuid, IN _case public.citext, IN _isagent boolean DEFAULT NULL::boolean, IN _isteamleader boolean DEFAULT NULL::boolean, IN _isbranch boolean DEFAULT NULL::boolean, IN _complaincategory public.citext DEFAULT NULL::public.citext, IN _complainsubcategory public.citext DEFAULT NULL::public.citext, IN _customerid uuid DEFAULT NULL::uuid, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if ((select count(id) from orderfollowup where id = _id and ordercase = _case )= 0) then 
 INSERT INTO orderfollowup(id,ordercase,isagent,isteamleader,isbranch,category,subcategory,customerid,createdby)
                    VALUES(_id,_case,_isagent,_isteamleader,_isbranch,_complaincategory,_complainsubcategory,_customerid,_createdby);END if;
END;
$$;


--
-- Name: createorderfollowupdetails(uuid, public.citext, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createorderfollowupdetails(IN _orderid uuid, IN _notes public.citext DEFAULT NULL::public.citext, IN _usertype public.citext DEFAULT NULL::public.citext, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
 INSERT INTO orderfollowupdetails(orderid,notes,usertype,createdby)
                    VALUES(_orderid,_notes,_usertype,_createdby);		
END;
$$;


--
-- Name: createorderhistory(uuid, public.citext, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createorderhistory(IN _id uuid, IN _status public.citext, IN _notes public.citext DEFAULT NULL::public.citext, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
 INSERT INTO orderhistory (id,status, notes,createdby)
			  VALUES (_id,_status,_notes,_createdby) on conflict (id, status) do nothing ;
			

END;
$$;


--
-- Name: createorderprint(uuid, public.citext, integer, public.citext, uuid, public.citext, public.citext, public.citext, uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createorderprint(IN _jobid uuid, IN _restaurantname public.citext, IN _copies integer, IN _branchname public.citext, IN _branchid uuid, IN _branchphone public.citext, IN _printer public.citext, IN _template public.citext, IN _printerid uuid, IN _taxnumber public.citext DEFAULT NULL::public.citext)
    LANGUAGE plpgsql
    AS $$

begin 
--USE
IF ( (_template = '1') AND (SELECT paid FROM branchtemplate brt WHERE brt.type = 'Cashier' and brt.branchid = _branchid) 
AND ((SELECT paymenttype FROM "order" WHERE id = _jobid ) IN (select unnest(Array['CASH - pending','Cash' ,'prepaid'])::citext) ) ) THEN

IF (((SELECT COUNT(prs.id) FROM printers prs WHERE prs.isdeleted = false and prs.id = _printerid 
and (SELECT ord.ordersource FROM "order" ord where ord.id = _jobid) = any(prs.channel)) > 0)) THEN

 INSERT INTO orderprint (printerid,taxnumber,jobid, restaurantname, copies, branchname, branchid, branchphone, printer, template,items,clientinfo,orderinfo)
			  VALUES (_printerid,_taxnumber,_jobid, _restaurantname, _copies, _branchname, _branchid, _branchphone, _printer, _template,
        (select (CASE WHEN _template = '1'  THEN  to_json(
        Array(
            select
                to_json(
                    json_build_object(
                        'item',
                        (prd.name ->> (select languageselected from printers prlang where prlang.id = _printerid )::citext)::citext,
						'QTY',
						ordpr.itemcount,
						'notes',
						ordpr.notes,
                        'price',
                        ordpr.pricesubtotal,
                        'topping',
                        to_json(
                            Array(
                                select
                                    to_json(
                                        json_build_object(
                                            'attributename',
											(prdatt.name ->> (select languageselected from printers prlang where prlang.id = _printerid )::citext)::citext,
											'values',
											(ordpratt.children)::json ,
                                            'notes',
                                            ordpratt.notes
                                        )
                                    )
                                from
                                    orderproductattribute ordpratt
                                    left join productattribute prdatt on ordpratt.attributeid = prdatt.id
								where ordpratt.orderproductid = ordpr.id
                            )
                        )
                    )
                )
            from
                orderproduct ordpr
                left join product prd on ordpr.productid = prd.id
                 where ordpr.orderid = _jobid
        )
    ) ELSE to_json(
        Array(
            select
                to_json(
                    json_build_object(
                        'item',
                        (prd.name ->> (select languageselected from printers prlang where prlang.id = _printerid )::citext)::citext,
						'QTY',
						ordpr.itemcount,
						'notes',
						ordpr.notes ,
                        'price',
                        ordpr.pricesubtotal,
                        'topping',
                        to_json(
                            Array(
                                select
                                    to_json(
                                        json_build_object(
                                            'attributename',
											(prdatt.name ->> (select languageselected from printers prlang where prlang.id = _printerid )::citext)::citext,
											'values',
											(ordpratt.children)::json,
                                            'notes',
                                            ordpratt.notes
                                        )
                                    )
                                from
                                    orderproductattribute ordpratt
                                    left join productattribute prdatt on ordpratt.attributeid = prdatt.id
								where ordpratt.orderproductid = ordpr.id
                            )
                        )
                    )
                )
            from
                orderproduct ordpr
                left join product prd on ordpr.productid = prd.id
                 where ordpr.orderid = _jobid  and prd.categoryid IN (select unnest(prs.categoryids) from printers prs where prs.id = _printerid and prs.type = 'Kitchen')
        )
    )  END)),(select to_json(json_build_object(
 'clientName', (cu.name ),
 'clientPhone',(cu.phoneno),
 'clientAddress',((select concat(cua.name,'-',(select concat(brdc.city,'-',brdc.area,'-',brdc.subarea)from branchdeliverycharge brdc where brdc.id=cua.labeladdressid),'-',cua.streetname,'-',cua.notes,'-',cua.buildingno,'-',cua.details)
from  customeraddress cua where cua.addressid = ord.deliveryaddress and cua.customerid = ord.customerid)),'clientStreetNo',(select cua.streetname from customeraddress cua where cua.addressid = ord.deliveryaddress and cua.customerid = ord.customerid),'clientBuildingNo',((select cua.buildingno from customeraddress cua where cua.addressid = ord.deliveryaddress and cua.customerid = ord.customerid)),'notes',((select cua.notes from customeraddress cua where cua.addressid = ord.deliveryaddress and cua.customerid = ord.customerid )))
                            )from customer cu inner join "order" ord on ord.customerid = cu.id where ord.id = _jobid),
                      (select to_json(json_build_object(
'orderNo', concat('#',ord.branchorderid,'#',(CASE WHEN (select namelookup.name from namelookup where namelookup.id = (select namelookup.id from namelookup where namelookup.id = ord.deliverytype))
is not null THEN 'P'
ELSE 'D' END)) ,
 'paymentStatus',(CASE WHEN ord.paymenttype NOT IN (select unnest(Array['CASH - pending','Cash' ,'prepaid'])::citext) THEN 'Paid'  ELSE 'UnPaid' END) ,
 'orderType',
(CASE WHEN (select namelookup.name from namelookup where namelookup.id = (select namelookup.id from namelookup where namelookup.id = ord.deliverytype))
is not null THEN (select namelookup.name from namelookup where namelookup.id = (select namelookup.id from namelookup where namelookup.id = ord.deliverytype))
ELSE 'Delivery' END) 
,'orderSource',
(
(CASE WHEN (ord.referencenumber != '{}' and ord.referencenumber !='{
  "callcenter": null
}') THEN (
    select (CASE WHEN (select resoucevalue.reskey from (SELECT value::citext as resvalue,key::citext as reskey FROM jsonb_each((select ord1.referencenumber from "order" ord1 where ord1.id = ord.id)) where value !='null' and (SELECT COUNT(value::citext) as resvalue FROM jsonb_each((select ord1.referencenumber from "order" ord1 where ord1.id = ord.id)) where value !='null') = 1 ) as resoucevalue)
 = 'careem' THEN

    (select concat('Careem',':',resoucevalue.resvalue)  from (SELECT value::citext as resvalue,key::citext as reskey FROM jsonb_each((select ord1.referencenumber from "order" ord1 where ord1.id = ord.id)) where (value !='null' )) as resoucevalue)

    ELSE (select concat('TALABAT',':',(select trim(both '"' from (resoucevalue.resvalue))))  from (SELECT (value::citext) as resvalue,key::citext as reskey FROM jsonb_each((select ord1.referencenumber from "order" ord1 where ord1.id = ord.id)) where (value !='null' )) as resoucevalue  WHERE   (resoucevalue.reskey = 'shortCode' )) END)
    ) ELSE (select name  from namelookup where id = ord.ordersource and isdeleted = false and ispublished = true)  END)
)
, 'orderDate',(  ord.createdat )
,'DeliveryPrice',(CASE WHEN (select brt.isdeliveryfees from branchtemplate brt where brt.type = 'Cashier' and brt.branchid = _branchid) THEN ord.deliveryprice END),
 'scheduledorder', (  ord.scheduled ),
 'tax',( '0' ),
 'notes',(ord.notes ),
 'subTotal',( ord.subtotalprice ), 'total',(ord.totalprice+ord.deliveryprice))) from "order" ord where ord.id = _jobid) 
 );
			
END IF;
ELSE
IF (((SELECT COUNT(prs.id) FROM printers prs WHERE prs.isdeleted = false and prs.id = _printerid 
and (SELECT ord.ordersource FROM "order" ord where ord.id = _jobid) = any(prs.channel)) > 0)) THEN
 INSERT INTO orderprint (printerid,taxnumber,jobid, restaurantname, copies, branchname, branchid, branchphone, printer, template,items,clientinfo,orderinfo)
			  VALUES (_printerid,_taxnumber,_jobid, _restaurantname, _copies, _branchname, _branchid, _branchphone, _printer, _template,
        (select (CASE WHEN _template = '1'  THEN  to_json(
        Array(
            select
                to_json(
                    json_build_object(
                        'item',
                        (prd.name ->> (select languageselected from printers prlang where prlang.id = _printerid )::citext)::citext,
						'QTY',
						ordpr.itemcount,
						'notes',
						ordpr.notes,
                        'price',
                        ordpr.pricesubtotal,
                        'topping',
                        to_json(
                            Array(
                                select
                                    to_json(
                                        json_build_object(
                                            'attributename',
											(prdatt.name ->> (select languageselected from printers prlang where prlang.id = _printerid )::citext)::citext,
											'values',
											(ordpratt.children)::json ,
                                            'notes',
                                            ordpratt.notes
                                        )
                                    )
                                from
                                    orderproductattribute ordpratt
                                    left join productattribute prdatt on ordpratt.attributeid = prdatt.id
								where ordpratt.orderproductid = ordpr.id
                            )
                        )
                    )
                )
            from
                orderproduct ordpr
                left join product prd on ordpr.productid = prd.id
                 where ordpr.orderid = _jobid
        )
    ) ELSE to_json(
        Array(
            select
                to_json(
                    json_build_object(
                        'item',
                        (prd.name ->> (select languageselected from printers prlang where prlang.id = _printerid )::citext)::citext,
						'QTY',
						ordpr.itemcount,
						'notes',
						ordpr.notes ,
                        'price',
                        ordpr.pricesubtotal,
                        'topping',
                        to_json(
                            Array(
                                select
                                    to_json(
                                        json_build_object(
                                            'attributename',
											(prdatt.name ->> (select languageselected from printers prlang where prlang.id = _printerid )::citext)::citext,
											'values',
											(ordpratt.children)::json,
                                            'notes',
                                            ordpratt.notes
                                        )
                                    )
                                from
                                    orderproductattribute ordpratt
                                    left join productattribute prdatt on ordpratt.attributeid = prdatt.id
								where ordpratt.orderproductid = ordpr.id
                            )
                        )
                    )
                )
            from
                orderproduct ordpr
                left join product prd on ordpr.productid = prd.id
                 where ordpr.orderid = _jobid  and prd.categoryid IN (select unnest(prs.categoryids) from printers prs where prs.id = _printerid and prs.type = 'Kitchen')
        )
    )  END)),(select to_json(json_build_object(
 'clientName', (cu.name ),
 'clientPhone',(cu.phoneno),
 'clientAddress',((select concat(cua.name,'-',(select concat(brdc.city,'-',brdc.area,'-',brdc.subarea)from branchdeliverycharge brdc where brdc.id=cua.labeladdressid),'-',cua.streetname,'-',cua.notes,'-',cua.buildingno,'-',cua.details)
from  customeraddress cua where cua.addressid = ord.deliveryaddress and cua.customerid = ord.customerid)),'clientStreetNo',(select cua.streetname from customeraddress cua where cua.addressid = ord.deliveryaddress and cua.customerid = ord.customerid),'clientBuildingNo',((select cua.buildingno from customeraddress cua where cua.addressid = ord.deliveryaddress and cua.customerid = ord.customerid)),'notes',((select cua.notes from customeraddress cua where cua.addressid = ord.deliveryaddress and cua.customerid = ord.customerid )))
                            )from customer cu inner join "order" ord on ord.customerid = cu.id where ord.id = _jobid),
                      (select to_json(json_build_object(
'orderNo', concat('#',ord.branchorderid,'#',(CASE WHEN (select namelookup.name from namelookup where namelookup.id = (select namelookup.id from namelookup where namelookup.id = ord.deliverytype))
is not null THEN 'P'
ELSE 'D' END)) ,
 'paymentStatus',(CASE WHEN ord.paymenttype NOT IN (select unnest(Array['CASH - pending','Cash' ,'prepaid'])::citext) THEN 'Paid'  ELSE 'UnPaid' END) ,
 'orderType',
(CASE WHEN (select namelookup.name from namelookup where namelookup.id = (select namelookup.id from namelookup where namelookup.id = ord.deliverytype))
is not null THEN (select namelookup.name from namelookup where namelookup.id = (select namelookup.id from namelookup where namelookup.id = ord.deliverytype))
ELSE 'Delivery' END) 
,'orderSource',
(
(CASE WHEN (ord.referencenumber != '{}' and ord.referencenumber !='{
  "callcenter": null
}') THEN (
    select (CASE WHEN (select resoucevalue.reskey from (SELECT value::citext as resvalue,key::citext as reskey FROM jsonb_each((select ord1.referencenumber from "order" ord1 where ord1.id = ord.id)) where value !='null' and (SELECT COUNT(value::citext) as resvalue FROM jsonb_each((select ord1.referencenumber from "order" ord1 where ord1.id = ord.id)) where value !='null') = 1 ) as resoucevalue)
 = 'careem' THEN

    (select concat('Careem',':',resoucevalue.resvalue)  from (SELECT value::citext as resvalue,key::citext as reskey FROM jsonb_each((select ord1.referencenumber from "order" ord1 where ord1.id = ord.id)) where (value !='null' )) as resoucevalue)

    ELSE (select concat('TALABAT',':',(select trim(both '"' from (resoucevalue.resvalue))))  from (SELECT (value::citext) as resvalue,key::citext as reskey FROM jsonb_each((select ord1.referencenumber from "order" ord1 where ord1.id = ord.id)) where (value !='null' )) as resoucevalue  WHERE   (resoucevalue.reskey = 'shortCode' )) END)
    ) ELSE (select name  from namelookup where id = ord.ordersource and isdeleted = false and ispublished = true)  END)
)
, 'orderDate',
(  ord.createdat )
,'DeliveryPrice',(CASE WHEN (select brt.isdeliveryfees from branchtemplate brt where brt.type = 'Cashier' and brt.branchid = _branchid) THEN ord.deliveryprice END),
 'scheduledorder', (  ord.scheduled ),
 'tax',( '0' ),
 'notes',(ord.notes ),
 'subTotal',( ord.subtotalprice ), 'total',(ord.totalprice+ord.deliveryprice))) from "order" ord where ord.id = _jobid) 
 );
		
END IF;
END IF;

DELETE from orderprint op where op.branchid = _branchid and op.isdeleted = true
and (EXTRACT(EPOCH FROM ((now() AT TIME ZONE 'Asia/Amman'::text) - op.createdat)))::bigint > (345800)::bigint; 
END;
$$;


--
-- Name: createorderproduct(uuid, uuid, numeric, numeric, numeric, public.citext, integer, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createorderproduct(IN _orderid uuid, IN _productid uuid, IN _pricesubtotal numeric, IN _pricetaxvalue numeric, IN _pricetaxpercentage numeric, IN _notes public.citext, IN _itemcount integer DEFAULT 1, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
begin 
 INSERT INTO orderproduct (orderid, productid ,pricesubtotal,pricetaxvalue,pricetaxpercentage,notes,itemcount,createdby)
			  VALUES (_orderid,_productid,_pricesubtotal,_pricetaxvalue,_pricetaxpercentage,_notes,_itemcount,_createdby)
	returning id into _id;
			

END;
$$;


--
-- Name: createorderproductattribute(uuid, uuid, numeric, numeric, numeric, public.citext, jsonb, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createorderproductattribute(IN _orderproductid uuid, IN _attributeid uuid, IN _pricesubtotal numeric, IN _pricetaxvalue numeric, IN _pricetaxpercentage numeric, IN _notes public.citext, IN _attributevalues jsonb, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
begin 

 INSERT INTO orderproductattribute (orderproductid, attributeid ,pricesubtotal,pricetaxvalue,pricetaxpercentage,notes,children,createdby)
			  VALUES (_orderproductid,_attributeid,_pricesubtotal,_pricetaxvalue,_pricetaxpercentage,_notes,_attributevalues,_createdby)
	returning id into _id;
			

END;
$$;


--
-- Name: createorderstatuspossibilities(uuid, public.citext, uuid, uuid, boolean, boolean, boolean, public.citext, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createorderstatuspossibilities(IN _branchid uuid, IN _status public.citext, IN _companyid uuid, IN _nextstatus uuid DEFAULT NULL::uuid, IN _cancancel boolean DEFAULT false, IN _isfirststatus boolean DEFAULT false, IN _islaststatus boolean DEFAULT false, IN _color public.citext DEFAULT 'gray'::public.citext, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
begin 

INSERT INTO orderstatuspossibilities(branchid, status, nextstatus, cancancel, companyid, isfirststatus, islaststatus,color,createdby)
	VALUES (_branchid,_status,_nextstatus,_cancancel,_companyid, _isfirststatus, _islaststatus,_color,_createdby)
	returning id into _id;
	
END;
$$;


--
-- Name: createorupdateashyaeelog(uuid, public.citext, timestamp without time zone, public.citext, jsonb, timestamp without time zone, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.createorupdateashyaeelog(_id uuid, _eventid public.citext, _occurredat timestamp without time zone, _eventtype public.citext, _details jsonb, _createdat timestamp without time zone, _branchid uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
declare logid uuid;
begin
insert into ashyaeeorderlog (
        id,
        eventid,
        occurredat,
        eventtype,
        details,
        createdat,
        branchid
    )
values (
        _id,
        _eventid,
        _occurredat,
        _eventtype,
        _details,
        NOW(),
        _branchid
    ) ON CONFLICT (id) DO
UPDATE
SET
    eventid = _eventid,
    occurredat = _occurredat,
    eventtype = _eventtype,
    details = _details,
    branchid = _branchid
RETURNING id into logid;
return logid;
END;
$$;


--
-- Name: createorupdatecustomerbillingdetails(uuid, public.citext, public.citext, public.citext, public.citext, public.citext, public.citext, public.citext, public.citext, public.citext, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createorupdatecustomerbillingdetails(IN _customerid uuid, IN _firstname public.citext, IN _lastname public.citext, IN _email public.citext, IN _postalcode public.citext, IN _country public.citext, IN _provinance public.citext, IN _city public.citext, IN _street public.citext, IN _buildingnumber public.citext, IN _ipaddress public.citext, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
BEGIN
    insert into customerbillingdetails (customerid, firstname, lastname, email, postalcode, country, provinance,
                                        city,
                                        street,
                                        buildingnumber,
                                        ipaddress,
                                        createdat,
                                        createdby)
    VALUES (_customerid,
            _firstname,
            _lastname,
            _email,
            _postalcode,
            _country,
            _provinance,
            _city,
            _street,
            _buildingnumber,
            _ipaddress,
            now(),
            _firstname)
    ON CONFLICT (customerid) DO UPDATE SET customerid     = _customerid,
                                           firstname      = _firstname,
                                           lastname       = _lastname,
                                           email          = _email,
                                           postalcode     = _postalcode,
                                           country        = _country,
                                           provinance     = _provinance,
                                           city           = _city,
                                           street         = _street,
                                           buildingnumber = _buildingnumber,
                                           ipaddress      = _ipaddress,
                                           createdby      = _firstname
    returning id into _id;
END;
$$;


--
-- Name: createpaymentcompanyinfo(uuid, public.citext, text, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createpaymentcompanyinfo(IN _companyid uuid, IN _type public.citext, IN _value text, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 

INSERT INTO companyinfo(companyid, type, value, createdby)
	 		    VALUES (_companyid ,_type, _value, _createdby);
--call createlanguageresource('companyInfo',_value,_languagecode,1,_createdby);
END;
$$;


--
-- Name: createpaymentcompanyinfocompany(uuid, public.citext, public.citext[], public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createpaymentcompanyinfocompany(IN _companyid uuid, IN _type public.citext, IN _values public.citext[], IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
declare _value citext;
begin 
delete from companyinfo where companyid = _companyid and type = _type;
foreach _value in ARRAY _values loop
INSERT INTO companyinfo(companyid, type, value, createdby) VALUES (_companyid ,_type, _value, _createdby);
end loop;
END;
$$;


--
-- Name: createpaymentrequestlog(uuid, uuid, public.citext, public.citext, public.citext, public.citext, public.citext, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createpaymentrequestlog(IN _companyid uuid, IN _customerid uuid, IN _merchanttransactionid public.citext, IN _entityid public.citext, IN _amount public.citext, IN _request public.citext, IN _method public.citext, IN _url public.citext, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
begin
    insert into paymentrequestlog
        (companyid,customerid,merchanttransactionid, entityid ,amount, request, method, url)
    values
        (_companyid, _customerid, _merchanttransactionid,_entityid,_amount,_request, _method, _url)
    returning id into _id;
END;
$$;


--
-- Name: createposintegration(uuid, uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createposintegration(IN _companyid uuid, IN _integrationcompany uuid, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin
    if((select count(*) from posintegration po where po.companyid = _companyid)=0)
    then
     INSERT INTO posintegration (companyid, integrationcompanyid , createdby) VALUES (_companyid, _integrationCompany, _createdby);
    end if;
END;
$$;


--
-- Name: createprinter(public.citext, public.citext, uuid, uuid, public.citext[], boolean, integer, uuid[], public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createprinter(IN _name public.citext, IN _type public.citext, IN _branchid uuid, IN _printerid uuid, IN _types public.citext[], IN _auto boolean, IN _copies integer DEFAULT 1, IN _channels uuid[] DEFAULT NULL::uuid[], IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin

--use
IF((select COUNT(name) from printers where printerid = _printerid and type = _type )< 1)THEN
INSERT INTO public.printers(name,type,branchid,printerid,types,createdby,autoprint,channel,noofcopy)
VALUES (_name,_type,_branchid,_printerid,_types,_createdby,_auto,_channels,_copies);
ELSE
if _type is not null then update "printers" SET type = _type ,types = _types , updatedat = now(), updatedby = _createdby where printerid = _printerid and types = _types; end if;
if _auto is not null then update "printers" SET autoprint = _auto ,types = _types , updatedat = now(), updatedby = _createdby where printerid = _printerid and types = _types; end if;
if _channels is null then update "printers" SET channel = getallsources() ,types = _types , updatedat = now(), updatedby = _createdby where printerid = _printerid and types = _types; end if;
if _copies is not null then update "printers" SET noofcopy = _copies ,types = _types , updatedat = now(), updatedby = _createdby where printerid = _printerid and types = _types; end if;
END IF;
END;
$$;


--
-- Name: createprinterview(public.citext, uuid, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createprinterview(IN _name public.citext, IN _branchid uuid, IN _companyid uuid)
    LANGUAGE plpgsql
    AS $$
begin 


--USE

--DELETE FROM printorder WHERE branchid = _branchid;
--INSERT INTO printorder (id, branchid)
--SELECT orderid, branchid
--FROM printingorder
--WHERE branchid = _branchid  and printername IS NULL;
--DELETE FROM printingorder WHERE branchid = _branchid and (EXTRACT(EPOCH FROM ((now() AT TIME ZONE 'Asia/Amman'::text) - printingorder.createdat)))::bigint > (360)::bigint;
 --and (EXTRACT(EPOCH FROM ((now() AT TIME ZONE 'Asia/Amman'::text) - printingorder.createdat)))::bigint < (30)::bigint
if ((select count(id) from "viewprinter" where name = _name and branchid =_branchid) < 1 ) then 
     INSERT INTO public.viewprinter(name,branchid,companyid) 
     VALUES (_name,_branchid,_companyid); 
END if;
END;
$$;


--
-- Name: createprintingorder(uuid, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createprintingorder(IN _id uuid, IN _branchid uuid)
    LANGUAGE plpgsql
    AS $$
begin 
--use
INSERT INTO public.printingorder(orderid,branchid)
     VALUES (_id,_branchid);

END;
$$;


--
-- Name: createprodcutavailability(uuid, uuid[], uuid[], uuid[], uuid[], timestamp without time zone, timestamp without time zone, timestamp without time zone, timestamp without time zone, integer[], boolean, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createprodcutavailability(IN _companyid uuid, IN _productids uuid[] DEFAULT NULL::uuid[], IN _categoryids uuid[] DEFAULT NULL::uuid[], IN _channelids uuid[] DEFAULT NULL::uuid[], IN _attributeids uuid[] DEFAULT NULL::uuid[], IN _fromtime timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _totime timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _fromdate timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _todate timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _daysofweek integer[] DEFAULT NULL::integer[], IN _isavailable boolean DEFAULT false, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
INSERT INTO public.productavailability(companyid ,productids, attributeids ,categoryids, channelids,fromtime, totime, fromdate,todate, daysofweek, isavailable, createdby)
VALUES(_companyid,_productids,_attributeids, _categoryids, _channelids,_fromtime,_totime, _fromdate,_todate, _daysofweek, _isavailable, _createdby);		
END;
$$;


--
-- Name: createproduct(jsonb, jsonb, jsonb, jsonb, public.citext, boolean, boolean, boolean, boolean, integer, integer, uuid, public.citext, public.citext, integer, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createproduct(IN _name jsonb, IN _fulldescription jsonb, IN _shortdescription jsonb, IN _producttags jsonb, IN _sku public.citext, IN _isavailable boolean, IN _ispublished boolean, IN _isoffer boolean, IN _istopselling boolean, IN _hour integer, IN _min integer, IN _categoryid uuid, IN _imagepath public.citext DEFAULT NULL::public.citext, IN _thumbimage public.citext DEFAULT NULL::public.citext, IN _displaynumber integer DEFAULT 1, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext, INOUT _productid uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
begin

 INSERT INTO product (name, shortdescription, fulldescription ,producttags,sku,isavailable,ispublished,isoffer,istopselling,hour,min,categoryid,displaynumber,imagepath,thumbimage,createdby)
			  VALUES (_name,_shortdescription,_fulldescription,_producttags,_sku,_isavailable,_ispublished,_isoffer,_istopselling,_hour,_min,_categoryid,_displaynumber,_imagepath,_thumbimage,_createdby)
	returning id into _productid;


END;
$$;


--
-- Name: createproductattribute(uuid, jsonb, jsonb, integer, uuid, public.citext, boolean, boolean, boolean, integer, boolean, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createproductattribute(IN _productid uuid, IN _name jsonb, IN _description jsonb, IN _priority integer, IN _attributeid uuid, IN _controltype public.citext, IN _isrequired boolean DEFAULT false, IN _isalergy boolean DEFAULT false, IN _isavailable boolean DEFAULT true, IN _noofselection integer DEFAULT 0, IN _ispreselected boolean DEFAULT false, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
 INSERT INTO productattribute(productid,name,description,isrequired,isalergy,isavailable,attributeid,controltype,noofselection,priority,ispreselected,createdby)
            VALUES(	_productid,_name,_description,_isrequired,_isalergy,_isavailable,_attributeid,_controltype,_noofselection,_priority,_ispreselected,_createdby);		
END;
$$;


--
-- Name: createproductavailability(public.citext, uuid, uuid[], uuid[], uuid[], uuid[], integer[], uuid[], timestamp without time zone, timestamp without time zone, timestamp without time zone, timestamp without time zone, boolean, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createproductavailability(IN _name public.citext, IN _companyid uuid, IN _productids uuid[] DEFAULT NULL::uuid[], IN _categoryids uuid[] DEFAULT NULL::uuid[], IN _channelids uuid[] DEFAULT NULL::uuid[], IN _branchids uuid[] DEFAULT NULL::uuid[], IN _daysofweek integer[] DEFAULT NULL::integer[], IN _attributeids uuid[] DEFAULT NULL::uuid[], IN _fromtime timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _totime timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _fromdate timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _todate timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _isavailable boolean DEFAULT false, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
INSERT INTO public.productavailability(name, companyid ,productids, attributeids ,categoryids, channelids, branchids, daysofweek,fromtime, totime, fromdate,todate, isavailable, createdby)
VALUES(_name, _companyid,_productids,_attributeids, _categoryids, _channelids,_branchids,_daysofweek,_fromtime,_totime, _fromdate,_todate, _isavailable, _createdby);		
END;
$$;


--
-- Name: createproductimages(public.citext, uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createproductimages(IN _imagepath public.citext, IN _productid uuid, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
declare menuid uuid;
begin 

INSERT INTO public.productimages(
	        imagepath, productid, createdby)
	VALUES (_imagepath,_productid,_createdby);	
END;
$$;


--
-- Name: createproductselectedattribute(uuid, jsonb, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createproductselectedattribute(IN _productid uuid, IN _attribute jsonb, IN _createdby public.citext DEFAULT NULL::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
INSERT INTO public.productselectedattribute(
	product, attribute, createdby)
	VALUES(_productid, _attribute, _createdby);   
END;
$$;


--
-- Name: createproducttags(uuid, public.citext[], public.citext[], public.citext[]); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createproducttags(IN _productid uuid, IN _nametags public.citext[], IN _sizetags public.citext[], IN _ingredienttags public.citext[])
    LANGUAGE plpgsql
    AS $$
begin
    if(select count(*) from producttags where productid=_productid)>0 --and _isactive=false
        then
            delete from producttags where productid = _productid;
            end if;
    insert  into producttags values (_productid , _nametags,_sizetags,_ingredienttags);

end;
$$;


--
-- Name: createpromocode(uuid, public.citext, public.citext, numeric, public.citext, integer, integer, jsonb, integer, boolean, integer[], timestamp without time zone, timestamp without time zone, boolean, numeric, numeric, integer, public.citext, uuid[], uuid[], uuid[], uuid[], uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createpromocode(IN _companyid uuid, IN _name public.citext, IN _type public.citext, IN _value numeric DEFAULT NULL::numeric, IN _description public.citext DEFAULT NULL::public.citext, IN _priority integer DEFAULT 1, IN _numberofuse integer DEFAULT NULL::integer, IN _descriptionlanguage jsonb DEFAULT NULL::jsonb, IN _numberofusecustomer integer DEFAULT NULL::integer, IN _isdaily boolean DEFAULT false, IN _daysofweek integer[] DEFAULT NULL::integer[], IN _availablefrom timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _availableto timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _ispercentage boolean DEFAULT false, IN _maxvalue numeric DEFAULT NULL::numeric, IN _minprice numeric DEFAULT NULL::numeric, IN _minquantity integer DEFAULT NULL::integer, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext, IN _categoryids uuid[] DEFAULT NULL::uuid[], IN _branchids uuid[] DEFAULT NULL::uuid[], IN _channelids uuid[] DEFAULT NULL::uuid[], IN _customerids uuid[] DEFAULT NULL::uuid[], INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$

declare brid uuid;
declare cid uuid;
declare chid uuid;
declare cusid uuid;

begin
INSERT INTO public.promocode(
	companyid,name,type, value, description, priority, numberofusecustomer, isdaily,daysofweek,availablefrom,availableto, ispercentage, maxvalue, minprice, minquantity,createdby,numberofuse,descriptionlanguage)
	VALUES(_companyid,_name,_type,_value, _description,_priority,_numberofusecustomer,_isdaily,_daysofweek,_availablefrom,_availableto,_ispercentage,_maxvalue,_minprice,_minquantity,_createdby,_numberofuse ,_descriptionlanguage)
    returning id into _id;

   foreach brid in array _branchids loop
           INSERT INTO public.promocodebranch(branchid,promocodeid)
	       VALUES(brid,_id);
        end loop;
        
        
   foreach chid in array _channelids loop
           INSERT INTO public.promocodechannel(channelid,promocodeid)
	       VALUES(chid,_id);
        end loop; 
        
 if (_customerids is not null) then
  foreach cusid in array _customerids loop
           INSERT INTO public.promocodecustomers(customerid,promocodeid)
	       VALUES(cusid,_id);
        end loop;
 end if;
 
END;
$$;


--
-- Name: createpromocodecustomers(uuid, uuid, integer, timestamp without time zone, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createpromocodecustomers(IN _promocodeid uuid, IN _customerid uuid, IN _numberofuse integer DEFAULT NULL::integer, IN _lastusetime timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
INSERT INTO public.promocodecustomers(promocodeid,customerid,numberofuse,lastusetime,createdby)
	VALUES(_promocodeid,_customerid,_numberofuse,_lastusetime,_createdby);		
END;
$$;


--
-- Name: createrelatedproduct(uuid, uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createrelatedproduct(IN _productid uuid, IN _relatedproductid uuid, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
declare productid uuid;
begin 

 INSERT INTO relatedproduct(
	        productid, relatedproductid,createdby)
	VALUES (_productid,_relatedproductid,_createdby);			
END;
$$;


--
-- Name: createreminderorder(uuid, timestamp without time zone); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createreminderorder(IN _orderid uuid, IN _reminder timestamp without time zone)
    LANGUAGE plpgsql
    AS $$
begin 
update "order"  set  reminder = _reminder
where "order".id = _orderid;
END;
$$;


--
-- Name: createrequestlog(public.citext, public.citext, public.citext, public.citext, uuid, public.citext, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createrequestlog(IN _url public.citext, IN _method public.citext, IN _headers public.citext, IN _requestbody public.citext, IN _remoteid uuid, IN _talabatbrandid public.citext, IN _deliveryplatformid public.citext, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
begin
    insert into RequestLog(url, "method" ,headers, requestbody,remoteid,talabatbrandid,deliveryplatformid) values (_url,_method,_headers,_requestbody,_remoteId,_talabatBrandId,_deliveryplatformid)
    returning id into _id;
END;
$$;


--
-- Name: createrestaurantcustomer(uuid, uuid, public.citext, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createrestaurantcustomer(IN _customerid uuid, IN _restaurantid uuid, IN _name public.citext, IN _phonenumber public.citext, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
declare
begin
--         call insertcustomerdetails(_customerid,_name,_phonenumber);
--         if( (select count(*) from restaurantcustomer where customerid = _customerid and restaurantid = _restaurantid)=0 ) then
--             insert into restaurantcustomer (customerid, restaurantid) values (_customerid, _restaurantid)
--             returning id into _id;
--             call insertlogstatus(_id,1,0,_customerid,_restaurantid);
--         else
--             null;
--         end if;

            insert into restaurantcustomer (customerid, restaurantid) values (_customerid, _restaurantid)
            on conflict (customerid, restaurantid)
                do nothing
            returning id into _id;
            if(_id is not null) then
                call insertlogstatus(_id,1,0,_customerid,_restaurantid);
            end if;
            if(_id is null) then
                _id = _customerid::uuid;
            end if;



end;
$$;


--
-- Name: createrestaurantparams(uuid, integer, public.citext, public.citext, integer, integer, numeric); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createrestaurantparams(IN _restaurantid uuid, IN _period integer, IN _createdby public.citext, IN _restaurantname public.citext, IN _loyalpoint integer DEFAULT NULL::integer, IN _loyalcount integer DEFAULT NULL::integer, IN _loyalamount numeric DEFAULT NULL::numeric)
    LANGUAGE plpgsql
    AS $$
declare
begin

if((select count(*) from restaurantparams where restaurantid = _restaurantid) < 1)
then
       insert into restaurantparams (restaurantid, period, loyalityperiod, loyalitycount, loyalityamount, createdby, restaurantname)
        values
        (_restaurantid,_period,_loyalpoint,_loyalcount,_loyalamount,_createdby, _restaurantname);
else
if _period is not null then update "restaurantparams" SET period = _period  where restaurantid = _restaurantid; end if;
update "restaurantparams" SET loyalityperiod = _loyalpoint  where restaurantid = _restaurantid;
update "restaurantparams" SET loyalitycount = _loyalcount  where restaurantid = _restaurantid;
update "restaurantparams" SET loyalityamount = _loyalamount  where restaurantid = _restaurantid;
end if;
end;
$$;


--
-- Name: createrestaurntmenuwithbrandid(uuid, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createrestaurntmenuwithbrandid(IN _companyid uuid, IN _brandid public.citext, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin

update talabatmenu SET status = true,updatedby = _createdby, updatedat = (now() AT TIME ZONE 'Asia/Amman'::text) where brandid = _brandid and companyid = _companyid and status = false and ispublished = false;
INSERT INTO public.talabatmenu(brandid, companyid, menu, createdby, version, versiontime, menuversionnumber)
	VALUES (_brandid, _companyid, getrestaurntmenuwithbrandid(_companyid,_brandid),_createdby, concat('version','-',checkverison(_companyid,_brandid)), (now() AT TIME ZONE 'Asia/Amman'::text),checkverison(_companyid,_brandid));
END;
$$;


--
-- Name: createtalabatcredentials(uuid, public.citext, public.citext, uuid, boolean); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createtalabatcredentials(IN _branchid uuid, IN _talabatbrandid public.citext, IN _talabatbranchid public.citext, IN _companyid uuid, IN _istaxable boolean)
    LANGUAGE plpgsql
    AS $$
begin
    if(select count(*) from talabatcredential where ishbekbranchid = _branchid) = 0
        then
            insert into talabatcredential values (_branchid, _talabatbranchid,_talabatbrandid ,_companyid, NOW(),_istaxable);
    else
        update talabatcredential  set talabatbrandid = _talabatbrandid, talabatbranchid = _talabatbranchid where ishbekbranchid = _branchid;
    end if;
END;
$$;


--
-- Name: createtalabatdelivery(uuid, public.citext, jsonb, jsonb, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createtalabatdelivery(IN _orderid uuid, IN _talabatorderid public.citext, IN _request jsonb, IN _response jsonb, IN _requesttype public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
 INSERT INTO talabatdelivery (orderid,talabatorderid,request,response,requesttype)
			  VALUES (_orderid,_talabatorderid,_request,_response,_requesttype);
			

END;
$$;


--
-- Name: createtalabatdeliveryorder(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.createtalabatdeliveryorder(_id uuid) RETURNS TABLE(id uuid, deliveryprice numeric, totalprice numeric, finalprice numeric, notes public.citext, customer jsonb, deliveryaddress jsonb, branch jsonb, deliverytype public.citext, paymenttype public.citext)
    LANGUAGE plpgsql
    AS $$
    BEGIN
return query
    select o.id,
           (o.price->>'DeliveryPrice')::numeric,
           (o.price->>'Total')::numeric,
           (o.price->>'FinalPrice')::numeric,
           o.notes,
           (select to_json( json_build_object('name',name , 'phone' , phoneno))from customer where customerid = customer.id)::jsonb,
       (select to_json(json_build_object('name',name, 'longtitude',longtitude,'latitude',latitude)) from address where o.deliveryaddress = address.id)::jsonb,
       (select to_json(json_build_object('id',branch.id,'name',concat(name ,' - ', (select cc.name from company  cc where cc.id = branch.companyid)),'phone',phonenumber,'address',addressname,'longtitude',longtitude,'latitude',latitude)) from branch where branchid = branch.id)::jsonb ,
       (select case when (o.deliverytype = '6b2c15bd-39ae-4ade-ae78-3cb0bfeb3fbf') then 'vendor'::citext else case when(o.deliverytype = 'cfaca9cd-25cc-4e9a-a798-3d5496dde9f1') then 'cashless'::citext  else 'itemspayatpickup'::citext  end end),
        o.paymenttype
         from "order" o
         where o.id  = _id;

    END;
$$;


--
-- Name: createtax(public.citext, uuid, uuid, uuid, numeric, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createtax(IN _name public.citext, IN _countryid uuid, IN _cityid uuid, IN _taxcategoryid uuid, IN _value numeric, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 

 INSERT INTO tax(name,countryid,cityid,taxcategoryid,value,createdby)
          VALUES(_name,_countryid,_cityid,_taxcategoryid,_value,_createdby);
END;
$$;


--
-- Name: createtaxcategory(uuid, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createtaxcategory(IN _companyid uuid, IN _name public.citext, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 

 INSERT INTO taxcategory(companyid, name, createdby)
            VALUES(_companyid, _name, _createdby);
			
END;
$$;


--
-- Name: createtransaction(public.citext, uuid, uuid, public.citext, public.citext, public.citext, public.citext, public.citext, public.citext, public.citext, public.citext, public.citext, jsonb); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createtransaction(IN _hyperpayid public.citext, IN _customerid uuid, IN _companyid uuid, IN _amount public.citext, IN _descriptor public.citext, IN _description public.citext, IN _extendeddescription public.citext, IN _transactionid public.citext, IN _orderid public.citext, IN _paymenttype public.citext, IN _ip public.citext, IN _timestamp public.citext, IN _alldetails jsonb)
    LANGUAGE plpgsql
    AS $$
begin
    insert into
        transaction
        (hyperpayid ,customerid,companyid ,amount, descriptor ,description ,extendeddescription ,transactionid ,orderid ,paymenttype, ip,timestamp ,alldetails)
    values
        (_hyperpayid ,_customerid,_companyid , _amount, _descriptor ,_description ,_extendeddescription ,_transactionid ,_orderid ,_paymenttype, _ip,_timestamp ,_alldetails);
END;
$$;


--
-- Name: createtransferbranch(uuid, uuid, timestamp without time zone, timestamp without time zone, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createtransferbranch(IN _branchidselected uuid, IN _transfertobranchid uuid, IN _fromdate timestamp without time zone, IN _todate timestamp without time zone, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
begin 

INSERT INTO transferbranch(branchidselected, transfertobranchid, fromdate, todate,createdby)
	VALUES (_branchidselected,_transfertobranchid,_fromdate,_todate,_createdby)
	returning id into _id;
	
END;
$$;


--
-- Name: createwaapilogs(public.citext, jsonb, jsonb, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createwaapilogs(IN _endpoint public.citext, IN _request jsonb, IN _response jsonb, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
begin
INSERT INTO public.waapilogs(request, response, endpoint)
	VALUES (_request, _response, _endpoint)
			  returning id into _id;
end;
$$;


--
-- Name: createwhatsapptemplate(uuid, public.citext, public.citext, public.citext, public.citext, public.citext, jsonb, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.createwhatsapptemplate(IN _companyid uuid, IN _name public.citext, IN _category public.citext, IN _tlanguage public.citext, IN _status public.citext, IN _whatsapptemplateid public.citext, IN _components jsonb, IN _servicename public.citext)
    LANGUAGE plpgsql
    AS $$
begin 

 INSERT INTO whatsapptemplate(name, companyid, tlanguage, category,components,status,whatsapptemplateid,servicename)
			  VALUES (_name,_companyid,_category,_tlanguage,_components,_status,_whatsapptemplateid,_servicename);
			

END;
$$;


--
-- Name: creatwhatsappchatbotnumber(uuid, text, public.citext, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.creatwhatsappchatbotnumber(IN _companyid uuid, IN _number text, IN _type public.citext, IN _languagecode public.citext DEFAULT 'en'::public.citext, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin
INSERT INTO companyinfo(companyid, type, value,createdby)
VALUES (_companyid ,_type, _number,_createdby);
END;
$$;


--
-- Name: customerdistances(uuid, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.customerdistances(_customerid uuid, lat1 double precision, lon1 double precision) RETURNS TABLE(id uuid, name public.citext, distance double precision)
    LANGUAGE plpgsql
    AS $$
DECLARE
 		cusaddress customerdistance;
        dist float = 0;
        radlat1 float;
        radlat2 float;
        theta float;
        radtheta float;
		result calculateddistance[]= ARRAY[]::calculateddistance[];
		
    BEGIN
			FOREACH cusaddress IN ARRAY (select array_agg((customeraddress.addressid , customeraddress.name , customeraddress.latitude,customeraddress.longtitude)::customerdistance)from customeraddress where customeraddress.customerid = _customerid and (select count(csad.customerid) from customeraddress csad where csad.customerid = _customerid) > 0 and customeraddress.latitude is not null and customeraddress.longtitude is not null) LOOP
            dist = 0;
			radlat1 = pi() * lat1 / 180;
			radlat2 = pi() * cusaddress.latitude / 180;
            theta = lon1 - cusaddress.longtitude;
            radtheta = pi() * theta / 180;
            dist = sin(radlat1) * sin(radlat2) + cos(radlat1) * cos(radlat2) * cos(radtheta);
            IF dist > 1 THEN dist = 1; END IF;
            dist = acos(dist);
            dist = dist * 180 / pi();
            dist = dist * 60 * 1.1515;
			dist = dist * 1.609344;
			result=array_append(result, (cusaddress.id,cusaddress.name,dist)::calculateddistance);
            END LOOP;
            return query (select res.id , res.name ,res.distance from  unnest(result) res); END;
$$;


--
-- Name: daycount(public.citext, timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.daycount(_dayname public.citext DEFAULT NULL::public.citext, _from timestamp without time zone DEFAULT NULL::timestamp without time zone, _to timestamp without time zone DEFAULT NULL::timestamp without time zone) RETURNS TABLE(day public.citext, count integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN query
    SELECT to_char(ser, 'Day') ::citext as day,count(*)::integer
FROM generate_series( case when (_from is null) then (now() - '30 day'::interval) else (_from) end,
    case when (_to is null) then (now()) else (_to) end ,
    '1 day'::interval)  ser
where ((_dayname is null) or to_char(ser, 'Day') ::citext like concat('%',_dayname,'%'))
group by to_char(ser, 'Day');
END;
$$;


--
-- Name: declineadminblacklistrequest(uuid, uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.declineadminblacklistrequest(IN _customerid uuid, IN _companyid uuid, IN _actionby public.citext)
    LANGUAGE plpgsql
    AS $$
begin
    delete from blacklist where customerid = _customerid and companyid = _companyid;

END;
$$;


--
-- Name: declineorder(uuid, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.declineorder(IN _orderid uuid DEFAULT NULL::uuid, IN _updatedby public.citext DEFAULT 'System'::public.citext, INOUT _status public.citext DEFAULT NULL::public.citext)
    LANGUAGE plpgsql
    AS $$
declare laststatusid uuid;
declare username citext;
begin 
username = _updatedby; 
-- if((select count(id) from orderstatuspossibilities where islaststatus = true and branchid = (select branchid from "order" where id = _orderid)
-- 	and isdeleted = false and ispublished = true)>0)
-- 	then
-- 	laststatusid = (select id from orderstatuspossibilities where islaststatus = true and branchid = branchid and isdeleted = false and ispublished = true order by createdat desc limit 1);
-- 	else
--  	laststatusid =  (select id from orderstatuspossibilities where companyid = (select companyid from branch where branch.id = (select branchid from "order" where id = _orderid))and  islaststatus = true and branchid = branchid and isdeleted = false and ispublished = true order by createdat desc limit 1);
-- end if;

-- 	update "order"
-- 	set isdeclined = true , currentstatus = laststatusid
-- 	where "order".id = _orderid;
-- 	_status= (select  getorderstatus((select currentstatus from "order" where id = _orderid)));
-- 	call createorderhistory(_orderid,'declined','',username);

    	update "order"
	set isdeclined = true , currentstatus = (select osp1.id from orderstatuspossibilities1 osp1 where osp1.islaststatus = true)
	where "order".id = _orderid;
	call createorderhistory(_orderid,'declined','',username);
	
END;
$$;


--
-- Name: deleteaddressbyid(uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deleteaddressbyid(IN _id uuid)
    LANGUAGE plpgsql
    AS $$

begin
update customeraddress set isdeleted = true where addressid = _id;
end;
$$;


--
-- Name: deleteallbranchdeliverychargebycompanyid(uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deleteallbranchdeliverychargebycompanyid(IN _companyid uuid)
    LANGUAGE plpgsql
    AS $$
begin
delete from branchdeliverycharge where companyid = _companyid;
end;
$$;


--
-- Name: deleteallcompanyfaq(uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deleteallcompanyfaq(IN _companyid uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
begin
    delete from companyfaq cf where cf.companyid = _companyid;
END;
$$;


--
-- Name: deleteallishbekmapzones(); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deleteallishbekmapzones()
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE FROM ishbekmapzones;

END;
$$;


--
-- Name: deleteallordersforacompany(uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deleteallordersforacompany(IN _companyid uuid)
    LANGUAGE plpgsql
    AS $$
begin
    delete from orderproductattribute where attributeid in (select id from productattribute where companyid = _companyid or productid in (select id from product where categoryid = any(select id from category where companyid = _companyid)));
    delete from orderproductattribute where orderproductid = any(select id from orderproduct where orderid = any(select id from "order" where branchid = any(select id from branch where companyid = _companyid)));
    delete from "orderproduct" where orderid = any(select id from "order" where branchid = any(select id from branch where companyid = _companyid));
    delete  from "order" where branchid = any(select id from branch where companyid = _companyid);

end;
$$;


--
-- Name: deletebranch(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletebranch(IN _id uuid, IN _deletedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if ((select isdeleted from branch where id = _id) = false) then 
update branch SET isdeleted = true,ispublished = false , deletedat = now(), deletedby = _deletedby where id = _id; end if;
end;
$$;


--
-- Name: deletebranchdeliverycalculator(uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletebranchdeliverycalculator(IN _branchid uuid)
    LANGUAGE plpgsql
    AS $$
begin
    delete from branchcalculator where branchid = _branchid;
end;
$$;


--
-- Name: deletebranchdeliverychargelabel(uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletebranchdeliverychargelabel(IN _id uuid)
    LANGUAGE plpgsql
    AS $$
begin 
delete from branchdeliverycharge where id = _id;
end;
$$;


--
-- Name: deletebranchdeliverycompany(uuid, uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletebranchdeliverycompany(IN _branchid uuid, IN _deliverycompanyid uuid, IN _deletedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
delete from branchdelivery where branchid= _branchid and deliverycompanyid = _deliverycompanyid;
end;
$$;


--
-- Name: deletecategory(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletecategory(IN _id uuid, IN _deletedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if ((select isdeleted from category where id = _id) = false) then 
update product set isdeleted = true where categoryid = _id ;
update category SET isdeleted = true,ispublished = false , deletedat = now(), deletedby = _deletedby where id = _id; end if;
end;
$$;


--
-- Name: deleteclientintegration(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deleteclientintegration(IN _id uuid, IN _deletedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select isdeleted from clientintegration where companyid = _id) = false) and ((select ispublished from clientintegration where companyid = _id) = true)) then 
update clientintegration SET isdeleted = true, ispublished = false , deletedat = now(), deletedby = _deletedby where companyid = _id; end if;
end;
$$;


--
-- Name: deletecomapnymenu(uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletecomapnymenu(IN _companyid uuid)
    LANGUAGE plpgsql
    AS $$
begin
    call deleteallordersforacompany(_companyid);
    delete
    from productattribute
    where companyid = _companyid
       or productid in
          ((select id from product where categoryid in (select id from category where companyid = _companyid)));
    delete from menuproduct where menuid = any (select id from menu where companyid = _companyid);
    delete from menucategories where categoryid = any (select id from category where companyid = _companyid);
    delete from menuchannel where branchid = any (select id from branch where companyid = _companyid);
    delete from menuintegratiosync where menuid = any (select id from menu where companyid = _companyid);
    delete from menu where companyid = _companyid;
    delete from discountproduct where discountid = any (select id from discountinfo where companyid = _companyid);
    delete from discountattribute where discountid = any (select id from discountinfo where companyid = _companyid);
    delete from product where categoryid = any (select id from category where companyid = _companyid);
    delete from category where companyid = _companyid;
END;
$$;


--
-- Name: deletecompany(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletecompany(IN _id uuid, IN _deletedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if ((select isdeleted from company where id = _id) = false) then 
update company SET isdeleted = true,ispublished = false , deletedat = now(), deletedby = _deletedby where id = _id; end if;
end;
$$;


--
-- Name: deletecompanyfaq(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletecompanyfaq(IN _id uuid, IN _deletedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 

update companyfaq SET isdeleted = true , deletedat = now(), deletedby = _deletedby where id = _id;

END;
$$;


--
-- Name: deletecompanyinfo(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletecompanyinfo(IN _id uuid, IN _deletedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if ((select isdeleted from companyinfo where id = _id) = false) then 
update companyinfo SET isdeleted = true,ispublished = false , deletedat = now(), deletedby = _deletedby where id = _id; end if;
end;
$$;


--
-- Name: deletecompanyuser(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletecompanyuser(IN _id uuid, IN _deletedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select isdeleted from companyuser where id = _id) = false) and ((select isactive from companyuser where id = _id) = true)) then 
update companyuser SET isdeleted = true,isactive = false , deletedat = now(), deletedby = _deletedby where id = _id; end if;
end;
$$;


--
-- Name: deletecoupon(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletecoupon(IN _id uuid, IN _deletedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select isdeleted from coupon where id = _id) = false) and ((select ispublished from coupon where id = _id) = true)) then 
update coupon SET isdeleted = true,ispublished = false , deletedat = now(), deletedby = _deletedby where id = _id; end if;
end;
$$;


--
-- Name: deletecustomeraddress(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletecustomeraddress(IN _customerid uuid, IN _deletedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin
delete from customeraddress where customerid = _customerid;
end;
$$;


--
-- Name: deletecustomerfromblacklist(uuid, uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletecustomerfromblacklist(IN _customerid uuid, IN _companyid uuid, IN _actionby public.citext)
    LANGUAGE plpgsql
    AS $$
begin
    delete from blacklist where customerid = _customerid and companyid = _companyid;
END;
$$;


--
-- Name: deletedcustomeraccount(uuid, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletedcustomeraccount(IN _id uuid, IN _companyid uuid)
    LANGUAGE plpgsql
    AS $$


begin
update restaurantcustomer set isactive = false where customerid = _id and restaurantid = _companyid;
end;
$$;


--
-- Name: deletedcustomeraddress_ai(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletedcustomeraddress_ai(IN _id uuid, IN _deletedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if _id is not null then update customeraddress SET isdeleted = true , deletedat = now(), deletedby = _deletedby where addressid = _id;  end if;

end;
$$;


--
-- Name: deletedeliverycompany(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletedeliverycompany(IN _id uuid, IN _deletedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if ((select isdeleted from deliverycompany where id = _id) = false) then 
update deliverycompany SET isdeleted = true,ispublished = false , deletedat = now(), deletedby = _deletedby where id = _id; end if;
end;
$$;


--
-- Name: deletedeliverycostfordeliveryservice(uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletedeliverycostfordeliveryservice(IN _addressdeliverycompanyid uuid)
    LANGUAGE plpgsql
    AS $$
begin 
 delete from branchdeliveryaddress where branchdeliverycompany = _addressdeliverycompanyid;
END;
$$;


--
-- Name: deletediscountbydiscountid(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletediscountbydiscountid(IN _discountid uuid, IN _deletedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 

update discountinfo SET isdeleted = true,ispublished = false , deletedat = now(), deletedby = _deletedby where id = _discountid;
end;
$$;


--
-- Name: deletediscountphysical(uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletediscountphysical(IN _id uuid)
    LANGUAGE plpgsql
    AS $$
begin 
delete from discount where id = _id;
end;
$$;


--
-- Name: deletefeesbylabel(uuid, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletefeesbylabel(IN _branchid uuid, IN _addressid uuid)
    LANGUAGE plpgsql
    AS $$
begin 
delete from branchaddress where branchid = _branchid and addressid = _addressid ;
end;
$$;


--
-- Name: deletefollowup(uuid, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletefollowup(IN _id uuid, IN _ordercase public.citext, IN _deletedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if _id is not null and _ordercase is not null then
call deleteorderfollowupdetailsbyorder(_id);
if _id is not null and _ordercase is not null then delete from orderfollowup  where id = _id and ordercase = _ordercase; end if;
end if;
end;
$$;


--
-- Name: deletegeneralcomplain(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletegeneralcomplain(IN _id uuid, IN _deletedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select isdeleted from generalcomplain where id = _id) = false) and ((select ispublished from generalcomplain where id = _id) = true)) then 
update generalcomplain SET isdeleted = true, ispublished = false , deletedat = now(), deletedby = _deletedby where id = _id; end if;
end;
$$;


--
-- Name: deletehyperpaycredentialsbycompany(uuid, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletehyperpaycredentialsbycompany(IN _companyid uuid, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
begin
    delete from restaurantpaymentcredentials rpc where rpc.rid = _companyid
    returning rpc.rid into _id;
end;
$$;


--
-- Name: deleteintegrationcompany(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deleteintegrationcompany(IN _id uuid, IN _deletedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if ((select isdeleted from integrationcompany where id = _id) = false) then 
update integrationcompany SET isdeleted = true,ispublished = false , deletedat = now(), deletedby = _deletedby where id = _id; end if;
end;
$$;


--
-- Name: deletelookup(uuid, bigint); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletelookup(IN _rid uuid, IN _sid bigint)
    LANGUAGE plpgsql
    AS $$
begin
    delete from rlookup where sid = _sid and rid = _rid;
end;
$$;


--
-- Name: deletemenu(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletemenu(IN _id uuid, IN _deletedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select isdeleted from menu where id = _id) = false) and ((select ispublished from menu where id = _id) = true)) then
update menu SET isdeleted = true,ispublished = false , deletedat = now(), deletedby = _deletedby where id = _id;
delete from menuchannel where menuid = _id;
delete from menuintegratiosync where menuid = _id;
end if;
end;
$$;


--
-- Name: deletemenuintegrationsync(uuid, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletemenuintegrationsync(IN _menuid uuid, IN _channelid uuid)
    LANGUAGE plpgsql
    AS $$
begin 
DELETE FROM menuintegratiosync WHERE menuid=_menuid and channelid =_channelid ;
END;
$$;


--
-- Name: deletemenuintegrationsyncbymenuid(uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletemenuintegrationsyncbymenuid(IN _menuid uuid)
    LANGUAGE plpgsql
    AS $$
begin 
DELETE FROM menuintegratiosync WHERE menuid=_menuid;
END;
$$;


--
-- Name: deletenamelookup(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletenamelookup(IN _id uuid, IN _deletedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select isdeleted from namelookup where id = _id) = false) and ((select ispublished from namelookup where id = _id) = true)) then 
update namelookup SET isdeleted = true,ispublished = false , deletedat = now(), deletedby = _deletedby where id = _id; end if;
end;
$$;


--
-- Name: deletenotification(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletenotification(IN _id uuid, IN _deletedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if ((select isdeleted from notification where id = _id) = false) then 
update notification SET isdeleted = true,deletedat = now(), deletedby = _deletedby where id = _id; end if;
end;
$$;


--
-- Name: deleteoffer(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deleteoffer(IN _id uuid, IN _deletedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select isdeleted from discount where id = _id) = false) and ((select ispublished from discount where id = _id) = true)) then 
update discount SET isdeleted = true,ispublished = false , deletedat = now(), deletedby = _deletedby where id = _id; end if;
end;
$$;


--
-- Name: deleteofferaction(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deleteofferaction(IN _id uuid, IN _deletedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select isdeleted from offeraction where id = _id) = false) and ((select ispublished from offeraction where id = _id) = true)) then 
update offeraction SET isdeleted = true,ispublished = false , deletedat = now(), deletedby = _deletedby where id = _id; end if;
end;
$$;


--
-- Name: deleteofferimage(public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deleteofferimage(IN _imagepath public.citext, IN _companyid uuid)
    LANGUAGE plpgsql
    AS $$
begin 
delete from offerimage where imagepath = _imagepath and companyid = _companyid;
end;
$$;


--
-- Name: deleteonlinecustomeraddress(uuid, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deleteonlinecustomeraddress(IN _customerid uuid, IN _addressid uuid)
    LANGUAGE plpgsql
    AS $$
begin 
delete from customeraddress where addressid = _addressid and customerid = _customerid;
end;
$$;


--
-- Name: deleteoption(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deleteoption(IN _id uuid, IN _deletedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select isdeleted from option where id = _id) = false) and ((select ispublished from option where id = _id) = true)) then 
update option SET isdeleted = true,ispublished = false , deletedat = now(), deletedby = _deletedby where id = _id; end if;
end;
$$;


--
-- Name: deleteorderconfig(uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deleteorderconfig(IN _companyid uuid)
    LANGUAGE plpgsql
    AS $$
begin 
delete from "orderconfig" where companyid = _companyid;
delete from companyinfo where "companyinfo".type = 'Bio' and companyid = _companyid;
END;
$$;


--
-- Name: deleteorderfollowup(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deleteorderfollowup(IN _id uuid, IN _deletedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select isdeleted from orderfollowup where id = _id) = false) and ((select ispublished from orderfollowup where id = _id) = true)) then 
update orderfollowup SET isdeleted = true,ispublished = false , deletedat = now(), deletedby = _deletedby where id = _id; end if;
end;
$$;


--
-- Name: deleteorderfollowupdetails(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deleteorderfollowupdetails(IN _id uuid, IN _deletedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select isdeleted from orderfollowupdetails where id = _id) = false) and ((select ispublished from orderfollowupdetails where id = _id) = true)) then 
update orderfollowupdetails SET isdeleted = true,ispublished = false , deletedat = now(), deletedby = _deletedby where id = _id; end if;
end;
$$;


--
-- Name: deleteorderfollowupdetailsbyorder(uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deleteorderfollowupdetailsbyorder(IN _orderid uuid)
    LANGUAGE plpgsql
    AS $$
begin 
if _orderid is not null then 
delete from orderfollowupdetails  where orderid = _orderid ;end if;
end;
$$;


--
-- Name: deleteorderstatuspossibilities(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deleteorderstatuspossibilities(IN _id uuid, IN _deletedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select ispublished from orderstatuspossibilities where id = _id) = true) and ((select isdeleted from orderstatuspossibilities where id = _id) = false)) then 
update orderstatuspossibilities SET nextstatus = (select nextstatus from orderstatuspossibilities where id = _id) , updatedat = now(), updatedby = _deletedby where nextstatus = _id;
delete from orderstatuspossibilities where id = _id;
END if;
END;
$$;


--
-- Name: deletepaymentcompany(uuid[], uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletepaymentcompany(IN _id uuid[], IN _companyid uuid, IN _deletedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
delete from companyinfo where id = _id and companyid = _companyid;
end;
$$;


--
-- Name: deletepaymentonholdorders(uuid, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletepaymentonholdorders(IN _sessionid uuid, IN _paymentorderid uuid)
    LANGUAGE plpgsql
    AS $$
begin
update paymentonholdorders SET finished = true where sessoinid=_sessionid and paymentorderid=_paymentorderid;
end;
$$;


--
-- Name: deletepopupcompanyphone(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.deletepopupcompanyphone(_companyid uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
BEGIN
    DELETE FROM viciphonenumber
    WHERE companyid = _companyid;
        RETURN _companyid;

END;
$$;


--
-- Name: deleteposintegration(uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deleteposintegration(IN _id uuid)
    LANGUAGE plpgsql
    AS $$
begin
delete from posintegration  where companyid = _id;

end;
$$;


--
-- Name: deleteprinter(uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deleteprinter(IN _printerid uuid)
    LANGUAGE plpgsql
    AS $$
begin

--use
DELETE FROM printers where printerid = _printerid;
END;
$$;


--
-- Name: deleteproduct(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deleteproduct(IN _id uuid, IN _deletedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if ((select isdeleted from product where id = _id) = false) then 
update product SET isdeleted = true,ispublished = false , deletedat = now(), deletedby = _deletedby where id = _id; end if;
end;
$$;


--
-- Name: deleteproductattreibutebycomapnyid(uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deleteproductattreibutebycomapnyid(IN _companyid uuid)
    LANGUAGE plpgsql
    AS $$
begin
    delete from orderproductattribute where attributeid in (select id from productattribute where productid in (select id from product where categoryid in (select id from category where companyid=_companyid)));
    delete from productattribute where productid in (select id from product where categoryid in (select id from category where companyid=_companyid));
END;
$$;


--
-- Name: deleteproductattribute(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deleteproductattribute(IN _id uuid, IN _deletedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select isdeleted from productattribute where id = _id) = false) and ((select ispublished from productattribute where id = _id) = true)) then 
update productattribute SET isdeleted = true,ispublished = false , deletedat = now(), deletedby = _deletedby where id = _id; end if;
end;
$$;


--
-- Name: deleteproductavailability(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deleteproductavailability(IN _id uuid, IN _deletedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select isdeleted from productavailability where id = _id) = false) and ((select ispublished from productavailability where id = _id) = true)) then 
update productavailability SET isdeleted = true,ispublished = false , deletedat = now(), deletedby = _deletedby where id = _id; end if;
end;
$$;


--
-- Name: deleteproductimages(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deleteproductimages(IN _id uuid, IN _deletedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select isdeleted from productimages where id = _id) = false) and ((select ispublished from productimages where id = _id) = true)) then 
update productimages SET isdeleted = true,ispublished = false , deletedat = now(), deletedby = _deletedby where id = _id; end if;
end;
$$;


--
-- Name: deleteproductselectedattribute(uuid, uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deleteproductselectedattribute(IN _productid uuid, IN _attributeid uuid, IN _deletedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin
delete from productselectedattribute where product = _productid and attribute -> 'attribute' = to_json(_attributeid)::jsonb ;
end;
$$;


--
-- Name: deleteproductselectedattribute(uuid, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deleteproductselectedattribute(IN _productid uuid, IN _attributeid public.citext, IN _deletedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin
delete from productselectedattribute where product = _productid and attribute -> 'attribute' = to_json(_attributeid)::jsonb ;
end;
$$;


--
-- Name: deletepromocode(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletepromocode(IN _id uuid, IN _deletedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
declare cid uuid;
declare brid uuid;
declare chid uuid;
declare cus uuid;
begin 


if _id is not null then update promocode SET isdeleted = true , deletedat = now(), deletedby = _deletedby where id = _id; end if;

end;
$$;


--
-- Name: deleterelatedproduct(uuid, uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deleterelatedproduct(IN _productid uuid, IN _relatedproductid uuid, IN _deletedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select isdeleted from relatedproduct where relatedproductid = _relatedproductid and productid=_productid) = false) and ((select ispublished from relatedproduct where relatedproductid = _relatedproductid and productid=_productid) = true)) then 
update relatedproduct SET isdeleted = true,ispublished = false , deletedat = now(), deletedby = _deletedby where relatedproductid = _relatedproductid and productid=_productid; end if;
end;
$$;


--
-- Name: deletescheduledeliveryorderrequest(uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletescheduledeliveryorderrequest(IN _orderid uuid)
    LANGUAGE plpgsql
    AS $$
begin
    delete from public.scheduledeliveryorderrequest where scheduledeliveryorderrequest.orderid= _orderid;
    end;
$$;


--
-- Name: deletesinglebranchsubareafee(uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletesinglebranchsubareafee(IN _id uuid)
    LANGUAGE plpgsql
    AS $$
begin
    delete from public.branchsubareafees where id = _id;
end;
$$;


--
-- Name: deletetax(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletetax(IN _id uuid, IN _deletedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if ((select isdeleted from tax where id = _id) = false) then 
update tax SET isdeleted = true,ispublished = false , deletedat = now(), deletedby = _deletedby where id = _id; end if;
end;
$$;


--
-- Name: deletetaxcategory(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletetaxcategory(IN _id uuid, IN _deletedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if ((select isdeleted from taxcategory where id = _id) = false) then 
update taxcategory SET isdeleted = true,ispublished = false , deletedat = now(), deletedby = _deletedby where id = _id; end if;
end;
$$;


--
-- Name: deletewhatsappchatbotnumber(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletewhatsappchatbotnumber(IN _companyid uuid, IN _type public.citext)
    LANGUAGE plpgsql
    AS $$
begin
delete from companyinfo where companyid = _companyid and type = _type;
END;
$$;


--
-- Name: deletewhatsapptemplate(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.deletewhatsapptemplate(IN _companyid uuid, IN _name public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
DELETE FROM whatsapptemplate WHERE name = _name and companyid = _companyid;		

END;
$$;


--
-- Name: discountvalidfromcomapnyid(public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.discountvalidfromcomapnyid(_companyphone public.citext) RETURNS TABLE(activenow json, activeweek json, activealways json, productoffer json)
    LANGUAGE plpgsql
    AS $$
DECLARE
  selectedcompanyid uuid;
BEGIN
selectedcompanyid = (select companyid from companyinfo where type = 'phone' and value like(concat('%',_companyphone,'%')) order by createdat desc limit 1);
return query select (to_json(Array(select to_json(json_build_object('name' ,coalesce(d.description,d.name),'todate',to_char(d.availableto, 'DD/MM/YYYY'),'fromdate',to_char(d.availablefrom, 'DD/MM/YYYY')))from  discountinfo d left join discountchannel disch on disch.discountid = d.id  where disch.channelid = '79401a8a-0d53-4988-a08d-31d1b3514919' and ((case when (d.availablefrom::time < d.availableto::time) then
                 case when ((d.availablefrom::time <= ((now())::time + interval '3 hour')) and (d.availableto::time >= (now())::time))  then 1 else 0 end
             else
                 case when ((d.availableto::time <= (now())::time + interval '3 hour') and (d.availablefrom::time >= (now())::time))  then 0 else 1 end
		   end) =1)
            and
            ((d.availablefrom)::date) <= ((now())::date)  and ((d.availableto)::date) >= ((now())::date)
            and
            (select to_char ( (now()), 'D'  )::integer) = any (d.daysofweek)
--is on product not in attributes
and d.companyid = selectedcompanyid and d.isdeleted is not true and d.isavailable is true
            ))),(to_json(Array(select to_json(json_build_object('name' ,coalesce(d.description,d.name),'todate',to_char(d.availableto, 'DD/MM/YYYY'),'fromdate',to_char(d.availablefrom, 'DD/MM/YYYY')))from  discountinfo d  left join discountchannel disch on disch.discountid = d.id  where disch.channelid = '79401a8a-0d53-4988-a08d-31d1b3514919' and  ((case when (d.availablefrom::time < d.availableto::time) then
                 case when ((d.availablefrom::time <= ((now())::time + interval '3 hour')) and (d.availableto::time >= (now())::time))  then 1 else 0 end
             else
                 case when ((d.availableto::time <= (now())::time + interval '3 hour') and (d.availablefrom::time >= (now())::time))  then 0 else 1 end
		   end) =1)
            and
            ((d.availablefrom)::date) <= ((now())::date + interval '7 days')  and ((d.availableto)::date) >= ((now())::date)
            and
            (select to_char ( (now()), 'D'  )::integer) = any (d.daysofweek)
and d.companyid = selectedcompanyid and d.isdeleted is not true and d.isavailable is true
             ))),(to_json(Array(select to_json(json_build_object('name' ,coalesce(d.description,d.name),'todate',to_char(d.availableto, 'DD/MM/YYYY'),'fromdate',to_char(d.availablefrom, 'DD/MM/YYYY')))from  discountinfo d  left join discountchannel disch on disch.discountid = d.id  where disch.channelid = '79401a8a-0d53-4988-a08d-31d1b3514919' and  ((case when (d.availablefrom::time < d.availableto::time) then
                 case when ((d.availablefrom::time <= ((now())::time + interval '3 hour')) and (d.availableto::time >= (now())::time))  then 1 else 0 end
             else
                 case when ((d.availableto::time <= (now())::time + interval '3 hour') and (d.availablefrom::time >= (now())::time))  then 0 else 1 end
		   end) =1)
            and
            ((d.availablefrom)::date) <= ((now())::date)  and ((d.availableto)::date) >= ((now())::date + interval '7 month')
            and
            (select to_char ( (now()), 'D'  )::integer) = any (d.daysofweek)
--is on product not in attributes
and d.companyid = selectedcompanyid and d.isdeleted is not true and d.isavailable is true )))
, to_json(Array(select to_json(json_build_object('description',pr.description,'discountname',pr.description))from product pr where pr.isoffer = true and pr.ispublished = true and pr.isdeleted = false and pr.id in (select distinct productid from menuproduct where menuid in (select id from menu where ispublished = true and isdeleted = false  and id in (select distinct menuid from branch where companyid = selectedcompanyid and status=1))) GROUP BY pr.description));
end;
$$;


--
-- Name: distance(double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.distance(lat1 double precision, lon1 double precision, lat2 double precision, lon2 double precision) RETURNS double precision
    LANGUAGE plpgsql
    AS $$
DECLARE
        dist float = 0;
        radlat1 float;
        radlat2 float;
        theta float;
        radtheta float;

    BEGIN
	        radlat1 = pi() * lat1 / 180;
            radlat2 = pi() * lat2 / 180;
            theta = lon1 - lon2;
            radtheta = pi() * theta / 180;
            dist = sin(radlat1) * sin(radlat2) + cos(radlat1) * cos(radlat2) * cos(radtheta);
            IF dist > 1 THEN dist = 1; END IF; --for error handling
            dist = (((acos(dist)) * 180 / pi())* 60 * 1.1515)* 1.609344;
            RETURN dist;
    END;
$$;


--
-- Name: distance_ai(double precision, double precision, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.distance_ai(lat1 double precision, lon1 double precision, lat2 double precision, lon2 double precision) RETURNS double precision
    LANGUAGE plpgsql
    AS $$
DECLARE
        dist float = 0;
        radlat1 float;
        radlat2 float;
        theta float;
        radtheta float;

    BEGIN
	        radlat1 = pi() * lat1 / 180;
            radlat2 = pi() * lat2 / 180;
            theta = lon1 - lon2;
            radtheta = pi() * theta / 180;
            dist = sin(radlat1) * sin(radlat2) + cos(radlat1) * cos(radlat2) * cos(radtheta);
            IF dist > 1 THEN dist = 1; END IF; --for error handling
            dist = (((acos(dist)) * 180 / pi())* 60 * 1.1515)* 1.609344;
            RETURN dist;
    END;
$$;


--
-- Name: distances(double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.distances(lat1 double precision, lon1 double precision) RETURNS TABLE(id uuid, name public.citext, distance double precision)
    LANGUAGE plpgsql
    AS $$
DECLARE
 		branchd branchdistance;
        dist float = 0;
        radlat1 float;
        radlat2 float;
        theta float;
        radtheta float;
		result calculateddistance[]= ARRAY[]::calculateddistance[];
		
    BEGIN
			FOREACH branchd IN ARRAY (select array_agg( (branch.id , branch.name , branch.latitude,branch.longtitude)::branchdistance)  from branch where branch.latitude is not null and branch.longtitude is not null ) LOOP
            dist = 0;
			radlat1 = pi() * lat1 / 180;
			radlat2 = pi() * branchd.latitude / 180;
            theta = lon1 - branchd.longtitude;
            radtheta = pi() * theta / 180;
            dist = sin(radlat1) * sin(radlat2) + cos(radlat1) * cos(radlat2) * cos(radtheta);
            IF dist > 1 THEN dist = 1; END IF;
            dist = acos(dist);
            dist = dist * 180 / pi();
            dist = dist * 60 * 1.1515;
			dist = dist * 1.609344;
			result=array_append(result, (branchd.id,branchd.name,dist)::calculateddistance);
  END LOOP;
  return query (select res.id , res.name ,res.distance from  unnest(result) res); END;
$$;


--
-- Name: distancesforcompany(double precision, double precision, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.distancesforcompany(lat1 double precision, lon1 double precision, _companyid uuid) RETURNS TABLE(id uuid, name public.citext, distance double precision)
    LANGUAGE plpgsql
    AS $$
DECLARE
 		branchd branchdistance;
        dist float = 0;
        radlat1 float;
        radlat2 float;
        theta float;
        radtheta float;
		result calculateddistance[]= ARRAY[]::calculateddistance[];
		
    BEGIN
			FOREACH branchd IN ARRAY (select array_agg( (branch.id , branch.name , branch.latitude,branch.longtitude)::branchdistance)  from branch where branch.latitude is not null and branch.longtitude is not null ) LOOP
            dist = 0;
			radlat1 = pi() * lat1 / 180;
			radlat2 = pi() * branchd.latitude / 180;
            theta = lon1 - branchd.longtitude;
            radtheta = pi() * theta / 180;
            dist = sin(radlat1) * sin(radlat2) + cos(radlat1) * cos(radlat2) * cos(radtheta);
            IF dist > 1 THEN dist = 1; END IF;
            dist = acos(dist);
            dist = dist * 180 / pi();
            dist = dist * 60 * 1.1515;
			dist = dist * 1.609344;
			result=array_append(result, (branchd.id,branchd.name,dist)::calculateddistance);
  END LOOP;
  return query (select res.id , res.name ,res.distance from  unnest(result) res where res.id in(select branch.id from branch where companyid = _companyid)); END;
$$;


--
-- Name: doeshavechildren(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.doeshavechildren(_attributeid uuid) RETURNS SETOF boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN query
    select case when (count(*)>0)then true else false end
    from productattribute where attributeid = _attributeid and isdeleted = false;
END;
$$;


--
-- Name: doeshavechildren_careem(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.doeshavechildren_careem(_attributeid uuid) RETURNS SETOF boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN query
    select case when (count(*)>0)then true else false end
    from productattribute where attributeid = _attributeid and isdeleted = false;
END;
$$;


--
-- Name: get_all_now(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.get_all_now() RETURNS SETOF character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
    r character varying;
	querytoexecute character varying;
BEGIN
    FOR r IN
       (select
       col.table_name::character varying
from information_schema.columns col
where col.column_default is not null
      and col.table_schema not in('information_schema', 'pg_catalog') and col.column_default = 'now()')
    LOOP
	
	querytoexecute = concat('ALTER TABLE public.', r,' ALTER COLUMN createdat SET DEFAULT now() AT TIME ZONE ''Asia/Amman'';');
	execute format(querytoexecute);

        -- can do some processing here
        RETURN NEXT    querytoexecute;-- return current row of SELECT
    END LOOP;
    RETURN;

END;
$$;


--
-- Name: getaddressbranchbyid(uuid, uuid, uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getaddressbranchbyid(_companyid uuid, _addressid uuid DEFAULT NULL::uuid, _customerid uuid DEFAULT NULL::uuid, _languagecode public.citext DEFAULT 'en'::public.citext) RETURNS TABLE(id uuid, name public.citext, subareaid uuid, subareaname public.citext, areaid uuid, areaname public.citext, cityid uuid, cityname public.citext, countryid uuid, countryname public.citext, latitude numeric, longtitude numeric, buildingno public.citext, streetno public.citext, note public.citext, details public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select  ad.id ,cad.name , ad.subareaname ,
getlocalizationvalue(_languagecode , 'subareaName' ,ad.subareaname , 1),
ad.areaname, getlocalizationvalue(_languagecode , 'areaName' ,ad.areaname , 1), 
ad.cityname ,getlocalizationvalue(_languagecode , 'cityName' ,ad.cityname , 1), 
ad.countryname, getlocalizationvalue(_languagecode , 'countryname' ,ad.countryname , 1), 
ad.latitude , ad.longtitude ,
 cad.buildingno , cad.streetname ,
cad.notes , cad.details
from customeraddress cad
inner join address ad on ad.id= cad.addressid
inner join branchaddress on branchaddress.addressid = ad.id
inner join branch on branch.id = branchaddress.branchid 
where ad.id = _addressid and cad.customerid=_customerid and branch.companyid = _companyid and ad.isdeleted = false and ad.ispublished = true;

END;
$$;


--
-- Name: getaddressbyid(uuid, uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getaddressbyid(_addressid uuid DEFAULT NULL::uuid, _customerid uuid DEFAULT NULL::uuid, _languagecode public.citext DEFAULT 'ar'::public.citext) RETURNS TABLE(id uuid, name public.citext, latitude numeric, longtitude numeric, buildingno public.citext, streetno public.citext, note public.citext, details public.citext, labeladdress jsonb)
    LANGUAGE plpgsql
    AS $$

BEGIN
RETURN QUERY
select  ad.id ,cad.name ,
ad.latitude , ad.longtitude ,
 cad.buildingno , cad.streetname ,
cad.notes , cad.details
,to_json(jsonb_build_object('city',(select to_json(jsonb_build_object('id',brc.city ,'name',brc.city )) from branchdeliverycharge brc inner join branch on branch.id = brc.branchid where brc.id = cad.labeladdressid ),
                            'area',(select to_json(jsonb_build_object('id',brc.id ,'name',CONCAT(brc.area, ' - ',brc.subarea )::citext )) from branchdeliverycharge brc inner join branch on branch.id = brc.branchid where brc.id = cad.labeladdressid)
                            ))::jsonb
                           as labeladdress
from customeraddress cad
inner join address  ad on ad.id= cad.addressid
where ad.id = _addressid and cad.customerid=_customerid and ad.isdeleted = false and ad.ispublished = true;

END;
$$;


--
-- Name: getaddressbylocation(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getaddressbylocation(_areaid uuid, _subareaid uuid DEFAULT NULL::uuid) RETURNS SETOF uuid
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select address.id from address where ((_subareaid is null ) or(address.subareaname = _subareaid)) and address.areaname = _areaid;
END;
$$;


--
-- Name: getaddressddl(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getaddressddl() RETURNS TABLE(id uuid, name public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY

select distinct address.id, concat( case when (cityar.value  is not null) then cityar.value else cityen.value end ,' - ',area.value,' - ',subarea.value)::citext as name  from address 
left join languageresourcee cityen on (address.cityname = cityen.objectid and cityen.languagecode = 'en')
left join languageresourcee cityar on (address.cityname = cityar.objectid and cityar.languagecode = 'ar')
left join languageresourcee area on address.areaname = area.objectid
left join languageresourcee subarea on address.subareaname = subarea.objectid;
--where (( keyword is null )or 
--((subarea.value) like  concat('%', (keyword) , '%')) or
--((area.value) like  concat('%', (keyword) , '%')) or
--((cityar.value) like  concat('%', (keyword) , '%'))or
--cityen.value) like  concat('%', (keyword) , '%')))
--and area.value is not null and subarea.value is not null;
END;
$$;


--
-- Name: getaddressddl(public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getaddressddl(keyword public.citext) RETURNS TABLE(id uuid, name public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY

select distinct address.id, concat( case when (cityar.value  is not null) then cityar.value else cityen.value end ,' - ',area.value,' - ',subarea.value)::citext as name  from address 
left join languageresourcee cityen on (address.cityname = cityen.objectid and cityen.languagecode = 'en')
left join languageresourcee cityar on (address.cityname = cityar.objectid and cityar.languagecode = 'ar')
left join languageresourcee area on address.areaname = area.objectid
left join languageresourcee subarea on address.subareaname = subarea.objectid
where 
(( keyword is null ) or 
((subarea.value) like  concat('%', (keyword) , '%')) or
((area.value) like  concat('%', (keyword) , '%')) or
((cityar.value) like  concat('%', (keyword) , '%'))or
((cityen.value) like  concat('%', (keyword) , '%')))
and area.value is not null and subarea.value is not null;END;
$$;


--
-- Name: getaddressname(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getaddressname(addressid uuid) RETURNS SETOF public.citext
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
-- select name from address where
-- select concat( case when (cityar.value  is not null) then cityar.value else cityen.value end ,' - ',area.value,' - ',subarea.value)::citext from address
-- left join languageresourcee cityen on (address.cityname = cityen.objectid and cityen.languagecode = 'en')
-- left join languageresourcee cityar on (address.cityname = cityar.objectid and cityar.languagecode = 'ar')
-- left join languageresourcee area on address.areaname = area.objectid
-- left join languageresourcee subarea on address.subareaname = subarea.objectid
-- where address.id = addressid;
select name from address where address.id = addressid;

END;
$$;


--
-- Name: getalabatordertoken(public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getalabatordertoken(_deliveryplatformid public.citext) RETURNS TABLE(ordertoekn public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select (((requestbody::JSON->>'order')::JSON)->>'Token')::citext from RequestLog 
where deliveryplatformid = _deliveryplatformid and "method" ='OrderCreation' and deliveryplatformid IS NOT NULL limit 1;
END
$$;


--
-- Name: getallblockedcustomer(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getallblockedcustomer() RETURNS TABLE(id uuid, name public.citext, phoneno public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
   select cus.id, cus.name ,cus.phoneno from customer cus where isblocked = true;
 END;
$$;


SET default_tablespace = '';

SET default_table_access_method = heap;

--
-- Name: clientintegration; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.clientintegration (
    companyid uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    intcompanyid uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    name public.citext,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext
);


--
-- Name: getallclientintegration(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getallclientintegration() RETURNS SETOF public.clientintegration
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select * from clientintegration where isdeleted = false and ispublished = true ;
END;
$$;


--
-- Name: getallcompanies(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getallcompanies() RETURNS TABLE(id uuid, name public.citext, phone public.citext, branchesjson json)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    select c.id , c.name , ci.value::citext , (
    select to_json(array( select to_json(json_build_object(
        'id',b.id,
        'name',b.name,
        'opentime', b.opentime,
        'closetime', b.closetime,
        'latitude',b.latitude,
        'longitude',b.longtitude,
        'isactive',case when(b.status) = 1 then true else false end
        )
    ) from branch b where b.companyid= c.id and b.isdeleted = false and b.latitude IS NOT NULL and b.longtitude IS NOT NULL
        )) )From companyactiveintegrations cai
         join company c on cai.companyid = c.id
         left join companyinfo ci on ci.companyid = c.id and ci.type = 'phone' 
         where cai.channelid = '79401a8a-0d53-4988-a08d-31d1b3514919' 
         
         ; -- chatbot source
END;
$$;


--
-- Name: getallcompany(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getallcompany() RETURNS TABLE(id uuid, name public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select c.id,c.name from company c where c.isdeleted = false  ORDER BY createdat desc ;
END;
$$;


--
-- Name: companyfaq; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.companyfaq (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    question public.citext NOT NULL,
    answer1 public.citext NOT NULL,
    answer2 public.citext,
    companyid uuid NOT NULL,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext
);


--
-- Name: getallcompanyfaq(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getallcompanyfaq(_companyid uuid DEFAULT NULL::uuid) RETURNS SETOF public.companyfaq
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select c.* from companyfaq c where c.isdeleted = false and c.companyid = _companyid order by createdat desc;
END;
$$;


--
-- Name: getallcompanyfaqbyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getallcompanyfaqbyid(_id uuid) RETURNS SETOF public.companyfaq
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select c.* from companyfaq c where c.isdeleted = false and c.id = _id;
END;
$$;


--
-- Name: getallcompanysubarea(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getallcompanysubarea(_companyid uuid) RETURNS TABLE(id uuid, companyid uuid, cityid integer, areaid bigint, name public.citext, areacode integer, cityname public.citext, areaname public.citext, concatname text)
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        csa.id,
        csa.companyid,
        csa.cityid,
        csa.areaid,
        csa.name,
        csa.areacode,
        ic.name_en AS cityname,
        ia.name_en AS areaname,
        CONCAT(ic.name_en, ' - ', ia.name_en, ' - ', csa.name) AS concatname
    FROM companysubarea csa
    JOIN public.ishbekcities ic ON csa.cityid = ic.cityid
    JOIN public.ishbekareas ia ON csa.areaid = ia.areaid
    WHERE csa.companyid = _companyid;
END;
$$;


--
-- Name: getalldiscountsbycompanyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getalldiscountsbycompanyid(_companyid uuid) RETURNS TABLE(id uuid, name public.citext, availablefromtime time without time zone, availablefromdate date, availabletotime time without time zone, availabletodate date, isavailable boolean, numofbranch bigint, numofproducts bigint, numofchannel bigint)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select dinfo.id,
        dinfo.name,
        (dinfo.availablefrom::time) as availablefromtime,
        (dinfo.availablefrom::date) as availablefromdate,
        (dinfo.availableto::time) as availabletotime,
        (dinfo.availableto::date) as availabletodate,
        dinfo.isavailable,
        (select count(*) from discountbranch where discountid = dinfo.id) as numofbranch,
        (select count(*) from discountproduct where discountid = dinfo.id) as numofproducts,
        (select count(*) from discountchannel where discountid = dinfo.id) as numofchannel
    from discountinfo dinfo
    where dinfo.companyid = _companyid
    and dinfo.isdeleted = false;

END;
$$;


--
-- Name: getallishbekareas(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getallishbekareas() RETURNS TABLE(id uuid, areaid bigint, ishbekcityserialid integer, name public.citext, name_en public.citext, name_ar public.citext, lat double precision, lng double precision, searchable_text public.citext, url_name_en public.citext, url_name_ar public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select ia.id as "Id",
           ia.areaid as "AreaId",
           ia.cityid as "CityId",
           ia.name as "Name",
           ia.name_en as "NameEn",
           ia.name_ar as "NameAr",
           ia.lat as "Lat",
           ia.lng as "Lng",
           ia.searchable_text as "SearchableText",
           ia.url_name_ar as "UrlNameAr",
           ia.url_name_en as "UrlNameEn"
    from ishbekareas ia
    where ia.ispublished = true;
END;
$$;


--
-- Name: getallishbekmapzones(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getallishbekmapzones() RETURNS TABLE(cityname public.citext, cityid integer, areaname public.citext, areaid integer, coordinates jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT ishbekmapzones.cityname , ishbekmapzones.cityid , ishbekmapzones.areaname , ishbekmapzones.areaid, ishbekmapzones.coordinates
    FROM ishbekmapzones;
END;
$$;


--
-- Name: getallmenu(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getallmenu(_pagenumber integer DEFAULT NULL::integer, _pagesize integer DEFAULT NULL::integer) RETURNS TABLE(id uuid, name public.citext, createdat timestamp without time zone, createdby public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select  
menu.id, menu.name, menu.createdat, menu.createdby 
from menu where isdeleted = false and ispublished = true
LIMIT _pagesize
OFFSET ((_pagenumber-1) * _pagesize);

END;
$$;


--
-- Name: getallpopupcompanyphone(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getallpopupcompanyphone() RETURNS TABLE(id uuid, companyname public.citext, companyid uuid, companyphone public.citext, createdat timestamp without time zone, createdby public.citext)
    LANGUAGE plpgsql
    AS $$
    BEGIN
    RETURN QUERY
   select vpn.id, vpn.companyname, vpn.companyid, vpn.companyphone, vpn.createdat, vpn.createdby from viciphonenumber vpn ;
END;
$$;


--
-- Name: getallsources(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getallsources() RETURNS uuid[]
    LANGUAGE sql
    AS $$
    select array_agg(id) AS result from namelookup where tabletype ='ordersource' ;
$$;


--
-- Name: printers; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.printers (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    name public.citext NOT NULL,
    categoryids uuid[],
    isdeleted boolean DEFAULT false NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext,
    type public.citext,
    branchid uuid,
    printerid uuid,
    types public.citext[],
    autoprint boolean DEFAULT true NOT NULL,
    channel uuid[] DEFAULT public.getallsources(),
    noofcopy bigint DEFAULT 1 NOT NULL,
    paymentstatus public.citext[],
    languageselected public.citext DEFAULT 'ar'::public.citext NOT NULL
);


--
-- Name: getallprinters(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getallprinters() RETURNS SETOF public.printers
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY

--USE
 select * from printers where isdeleted = false ;
END;
$$;


--
-- Name: getallpromocodebycompanyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getallpromocodebycompanyid(_companyid uuid) RETURNS TABLE(id uuid, name public.citext, availablefromtime time without time zone, availablefromdate date, availabletotime time without time zone, availabletodate date, isavailable boolean, numofbranch bigint, numofproducts bigint, numofchannel bigint)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select prc.id,
        prc.name,
        (prc.availablefrom::time) as availablefromtime,
        (prc.availablefrom::date) as availablefromdate,
        (prc.availableto::time) as availabletotime,
        (prc.availableto::date) as availabletodate,
        prc.isavailable,
        (select count(*) from promocodebranch where promocodeid = prc.id) as numofbranch,
        (select count(*) from promocodecategory where promocodeid = prc.id) as numofproducts,
        (select count(*) from promocodechannel where promocodeid = prc.id) as numofchannel
    from promocode prc
    where prc.companyid = _companyid
    and prc.isdeleted = false;

END;
$$;


--
-- Name: getashyaeeorderproductattribute(uuid, integer, numeric); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getashyaeeorderproductattribute(_attributeid uuid, _quantity integer, _price numeric) RETURNS TABLE(id uuid, name jsonb, price jsonb, isalergy boolean, priority integer, isrequired boolean, controltype public.citext, description jsonb, isavailable boolean, noofselection integer, count integer, pricesubtotal numeric)
    LANGUAGE plpgsql
    AS $$
BEGIN
if (select isattributeashyaeelevel3(_attributeid := _attributeid))
    then
        return query
    select
        c.id,
        json_build_object('ar',
            concat(p.name->>'ar',' - ',c.name->>'ar'),
            'en',
            concat(p.name->>'en',' - ',c.name->>'en')
            )::jsonb
        ,
        json_build_object('ashyaee', (((coalesce(((c.price::jsonb)->>'ashyaee'),((c.price::jsonb)->>'default'))::double precision)+(coalesce(((p.price::jsonb)->>'ashyaee'),((p.price::jsonb)->>'default'))::double precision)) * (((pr.price::jsonb)->>'priceTaxPercentage'))::double precision +1),
            'default',(((((c.price::jsonb)->>'default')::double precision)+(((p.price::jsonb)->>'default')::double precision))* (((pr.price::jsonb)->>'priceTaxPercentage'))::double precision +1)
            )::jsonb

        ,c.isalergy,c.priority,c.isrequired,c.controltype,c.description,c.isavailable,c.noofselection, _quantity, _price
        --check if it was multiplied by quantity
    from productattribute c
    inner join productattribute p on c.attributeid = p.id
    inner join product pr on p.productid = pr.id
    where c.id = _attributeid;
    else
    return  query
   select
        c.id,
      c.name,
      c.price::jsonb,c.isalergy,c.priority,c.isrequired,c.controltype,c.description,c.isavailable,c.noofselection, _quantity,_price
      --check if it was multiplied by quantity
    from productattribute c
    where c.id = _attributeid;

end if;
END;
$$;


--
-- Name: getashyaeeorderproductattributejson(uuid, integer, numeric); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getashyaeeorderproductattributejson(_attributeid uuid, _quantity integer, _price numeric) RETURNS TABLE(attribute json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN query

select row_to_json(getashyaeeorderproductattribute(_attributeid, _quantity, _price));

END;
$$;


--
-- Name: getashyaeestatusmenubycompanyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getashyaeestatusmenubycompanyid(_companyid uuid DEFAULT NULL::uuid) RETURNS TABLE(branchid uuid, name public.citext, response public.citext, createdat timestamp without time zone)
    LANGUAGE plpgsql
    AS $$

BEGIN
return query

 select asrl.ishbekid, b.name, asrl.response, asrl.creationtime
       from ashyaeerequestlog asrl
       inner join branch b on b.id = asrl.ishbekid
       where asrl.ishbekid in (select id from branch where companyid = _companyid) and asrl.method = 'CREATEMENUREQUEST' order by asrl.creationtime desc limit 10 ;


END;
$$;


--
-- Name: getattrbiuteiscountishbekinterface(uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getattrbiuteiscountishbekinterface(_id uuid, _channel public.citext) RETURNS TABLE(value numeric, ispercentage boolean, priceafterdiscount numeric)
    LANGUAGE plpgsql
    AS $$
    BEGIN
    RETURN QUERY
        select dinfo.value,dinfo.ispercentage,
        (CASE WHEN dinfo.ispercentage THEN (((select (case when ((productattribute.price)-> _channel is not null) then (((productattribute.price)-> _channel)::decimal ) else ((((productattribute.price)->'default')::decimal)) end)::decimal from productattribute where id = _id )::decimal) - ((select (case when ((productattribute.price)-> _channel is not null) then (((productattribute.price)-> _channel)::decimal ) else ((((productattribute.price)->'default')::decimal)) end)::decimal from productattribute where id = _id )::decimal) * (dinfo.value / 100))::decimal else
        (((select (case when ((productattribute.price)-> _channel is not null) then (((productattribute.price)-> _channel)::decimal ) else ((((productattribute.price)->'default')::decimal)) end)::decimal from productattribute where id = _id )::decimal) - (dinfo.value)::decimal)::decimal end)::decimal
        from discountinfo dinfo
               inner join discountattribute disatt on disatt.discountid = dinfo.id
               inner join discountchannel disch on disch.discountid = dinfo.id
        where
             ((case when (dinfo.availablefrom::time < dinfo.availableto::time) then
                 case when ((dinfo.availablefrom::time <= ((now())::time + interval '3 hour')) and (dinfo.availableto::time >= (now())::time))  then 1 else 0 end
             else
                 case when ((dinfo.availableto::time <= (now())::time + interval '3 hour') and (dinfo.availablefrom::time >= (now())::time))  then 0 else 1 end
		   end) =1)
            and
            ((dinfo.availablefrom)::date) <= ((now())::date)  and ((dinfo.availableto)::date) >= ((now())::date)
            and
            (select to_char ( (now()), 'D'  )::integer) = any (dinfo.daysofweek)
            and disatt.attributeid = _id
            and disch.channelid = (select nlk.id from namelookup nlk where nlk.name =_channel)
            and dinfo.isdeleted is not true
            and dinfo.type = 'Order' order by dinfo.priority desc,dinfo.createdat desc LIMIT 1;
    END;
$$;


--
-- Name: productattribute; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.productattribute (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    productid uuid,
    name jsonb NOT NULL,
    description jsonb,
    isrequired boolean DEFAULT false NOT NULL,
    isalergy boolean DEFAULT false,
    isavailable boolean DEFAULT true NOT NULL,
    attributeid uuid,
    controltype public.citext,
    noofselection integer DEFAULT 0 NOT NULL,
    priority integer,
    ispreselected boolean DEFAULT false,
    isglobal boolean DEFAULT false NOT NULL,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext,
    weight public.citext,
    companyid uuid,
    oldprice public.citext,
    price jsonb,
    minimumcount integer DEFAULT 0 NOT NULL,
    maximumcount integer DEFAULT 1 NOT NULL,
    ischatbotquestion boolean DEFAULT false,
    external_pos_id public.citext,
    CONSTRAINT productattribute_controltype_check CHECK ((controltype OPERATOR(public.=) ANY (ARRAY['checkbox'::public.citext, 'updown'::public.citext, 'radiobutton'::public.citext])))
);


--
-- Name: getattributebyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getattributebyid(_id uuid) RETURNS SETOF public.productattribute
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select * from productattribute where id = _id and isdeleted = false and ispublished = true;
END;
$$;


--
-- Name: getattributename(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getattributename(_id uuid) RETURNS TABLE(name jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN QUERY 
   select patt.name from productattribute patt where patt.id = _id;

END;
$$;


--
-- Name: getattributeoptionids(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getattributeoptionids(_attributeid uuid DEFAULT NULL::uuid) RETURNS SETOF uuid[]
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select array_agg(options.id) from
    (select unnest(case when((select count (*) from productattribute l3 where l3.attributeid = l2.id and l3.isdeleted = false and l2.isdeleted=false )>0)
    then (select array_agg(id) from productattribute l3 where l3.attributeid = l2.id) --with children
    else l2.id || null::uuid[] --without children
    end ) as id
    from productattribute l2
    where l2.attributeid = _attributeid and l2.isdeleted = false) options;
END;
$$;


--
-- Name: getattributeoptionids_careem(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getattributeoptionids_careem(_attributeid uuid DEFAULT NULL::uuid) RETURNS SETOF uuid[]
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select array_agg(options.id) from
    (select unnest(case when((select count (*) from productattribute l3 where l3.attributeid = l2.id and l3.isdeleted = false and l2.isdeleted=false )>0)
    then (select array_agg(id) from productattribute l3 where l3.attributeid = l2.id) --with children
    else l2.id || null::uuid[] --without children
    end ) as id
    from productattribute l2
    where l2.attributeid = _attributeid and l2.isdeleted = false) options;
END;
$$;


--
-- Name: getattributeparent(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getattributeparent(_id uuid DEFAULT NULL::uuid) RETURNS SETOF uuid
    LANGUAGE plpgsql
    AS $$

BEGIN
    RETURN QUERY select (Case
                             when (select count(attributeid)
                                   from productattribute
                                   where id = (select att1.attributeid from productattribute att1 where id = _id)) > 0
                                 then
                                 (select att.attributeid
                                  from productattribute att
                                  where
                                      att.id = (select att1.attributeid from productattribute att1 where att1.id = _id))
                             else (select att.attributeid from productattribute att where att.id = _id)
        end);

END;
$$;


--
-- Name: getattributeposinfo(public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getattributeposinfo(_id public.citext) RETURNS TABLE(id uuid, name jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN QUERY 
   select patt.id,patt.name from productattribute patt where patt.external_pos_id = _id;

END;
$$;


--
-- Name: getattributeposinfo(public.citext, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getattributeposinfo(_id public.citext, _attributeid uuid) RETURNS TABLE(id uuid, name jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN QUERY 
   select patt.id,patt.name from productattribute patt 
   where patt.external_pos_id = _id
  and patt.attributeid = _attributeid
  and patt.isdeleted = false;

END;
$$;


--
-- Name: getattributepricebyid(uuid, public.citext, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getattributepricebyid(_id uuid, _channel public.citext, _tbalename public.citext) RETURNS TABLE(price numeric, pricetaxpercentage numeric)
    LANGUAGE plpgsql
    AS $$
BEGIN

IF _tbalename = 'productattribute' 
            THEN RETURN QUERY (select (patt.price->>_channel)::numeric,(patt.price->>'priceTaxPercentage')::numeric from productattribute patt where patt.id = _id);
            ELSE RETURN QUERY (select (p.price->>_channel)::numeric,(p.price->>'priceTaxPercentage')::numeric from product p where p.id = _id);
END IF;
END;
$$;


--
-- Name: getattributequestionposinfo(public.citext, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getattributequestionposinfo(_id public.citext, _productid uuid) RETURNS TABLE(id uuid, name jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN QUERY 
   select patt.id,patt.name from productattribute patt
   where patt.external_pos_id = _id
  and patt.productid = _productid
  and patt.attributeid is null
  and patt.isdeleted = false ;

END;
$$;


--
-- Name: getattributevalues(uuid[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getattributevalues(_attributeid uuid[] DEFAULT NULL::uuid[]) RETURNS SETOF public.productattribute
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select * from productattribute where attributeid = Any (_attributeid) and isdeleted = false and ispublished = true order by priority desc;
END;
$$;


--
-- Name: getattributevaluesforproudct(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getattributevaluesforproudct(_id uuid) RETURNS TABLE(id uuid, name jsonb, isavailable boolean)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select attributevalues.id , attributevalues.name , attributevalues.isavailable from productattribute attributevalues where attributevalues.attributeid = any(select productattribute.id from productattribute productattribute where productattribute.productid = _id and productattribute.isdeleted = false and productattribute.ispublished = true);
END;
$$;


--
-- Name: benefeciary; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.benefeciary (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    name public.citext NOT NULL,
    imagepath public.citext NOT NULL,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext
);


--
-- Name: getbenefeciaries(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbenefeciaries() RETURNS SETOF public.benefeciary
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select * from benefeciary where isdeleted = false and ispublished=true;
END
$$;


--
-- Name: getblacklistcustomer(uuid, integer, integer, timestamp without time zone, timestamp without time zone, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getblacklistcustomer(_companyid uuid, _pagenumber integer DEFAULT 1, _pagesize integer DEFAULT 5, _fromtime timestamp without time zone DEFAULT NULL::timestamp without time zone, _totime timestamp without time zone DEFAULT NULL::timestamp without time zone, _customerphone public.citext DEFAULT NULL::public.citext) RETURNS TABLE(customerid uuid, customername public.citext, customerphone public.citext, status public.citext, isapproved boolean, actiontime timestamp without time zone, actionby public.citext, createdby public.citext, notes public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select bl.customerid, c.name,c.phoneno, bl.status, bl.isapproved, bl.actiontime,bl.actionby,bl.createdby,bl.notes from blacklist bl
    inner join customer c on c.id = bl.customerid
    inner join company com on com.id = bl.companyid
    where bl.companyid= _companyid and (bl.isapproved is null or bl.isapproved is true)
     AND (_fromtime IS NULL OR _fromtime <= bl.createdat)
     AND (_totime IS NULL OR _totime >= bl.createdat)
     AND (
            (_customerphone IS NULL)
            OR (c.id = ANY (SELECT c.id FROM customer WHERE c.phoneno like concat('%', _customerphone, '%')))
        )
    order by bl.createdat desc
    LIMIT _pagesize
 OFFSET ((_pagenumber - 1) * _pagesize);
END
$$;


--
-- Name: getblacklistcustomers(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getblacklistcustomers(_id uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, name public.citext, phoneno public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY

select distinct customer.id , customer.name , customer.phoneno from customer LEFT JOIN "order" ord ON "ord".customerid = customer.id INNER JOIN branch bra ON "bra".id = "ord".branchid
INNER JOIN company com ON "com".id = "bra".companyid WHERE "com".id = _id and customer.isblocked =true;

 END;
$$;


--
-- Name: getblackliststatuses(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getblackliststatuses() RETURNS TABLE(id uuid, name public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select nlk.id, nlk.name from namelookup nlk where tabletype = 'blacklist';
END
$$;


--
-- Name: getbranchactive(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchactive(_addressid uuid) RETURNS TABLE(hasactivemenu boolean, status integer, createdby public.citext, createdat timestamp without time zone, countryid uuid, addressid uuid, addressname public.citext, phonenumber public.citext, name public.citext, id uuid, companyid uuid, latitude numeric, longtitude numeric, opentime timestamp without time zone, closetime timestamp without time zone, isactive integer, fees numeric)
    LANGUAGE plpgsql
    AS $$
    BEGIN
    RETURN QUERY
    select
    (select menu.isavailable from menu where menu.id = (select menu.id from menu where menu.id = any(select mch.menuid from menuchannel mch where mch.branchid = branch.id and mch.channelid =(select nlk.id from namelookup nlk where nlk.name ='callcenter')) and menu.isdeleted = false) and branch.isdeleted = false),
    branch.status, branch.createdby,
    branch.createdat, branch.countryid,
    branch.addressid, branch.addressname,
    branch.phonenumber, branch.name,
    branch.id, branch.companyid,
    branch.latitude, branch.longtitude,
    branch.opentime, branch.closetime,
    case when (branch.status = 1) then
    case when (branch.opentime::time < branch.closetime::time) then
    case when ((branch.opentime::time <= ((now() AT TIME ZONE 'Asia/Amman'::text)::time))
               and (branch.closetime::time >= (now() AT TIME ZONE 'Asia/Amman'::text)::time) )  then 1 else 0 end
    else case when ((branch.closetime::time <= (now() AT TIME ZONE 'Asia/Amman'::text)::time)
               and (branch.opentime::time >= (now() AT TIME ZONE 'Asia/Amman'::text)::time) )  then 0 else 1 end
               end
    else 0 end,
    b.fees
    from branch
    inner join branchdeliverycharge b on branch.id = b.branchid
    where b.id = _addressid and branch.latitude is not null and branch.longtitude is not null and branch.isdeleted = false;

    END;
    
$$;


--
-- Name: getbranchandpricebasedoncoordinatesaddress(uuid, double precision, double precision, boolean, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchandpricebasedoncoordinatesaddress(_companyid uuid, _latitude double precision, _longitude double precision, _iscalc boolean, _isintegration boolean) RETURNS TABLE(id uuid, name public.citext, opentime timestamp without time zone, closetime timestamp without time zone, status integer, addressname public.citext, menuid uuid, latitude numeric, longtitude numeric, phonenumber public.citext, hasactivemenu boolean, distancee double precision, fees numeric)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
        WITH distancebranch AS (
            SELECT branch.id,
                   branch.name,
                   branch.opentime,
                   branch.closetime,
                   CASE
                       WHEN (branch.status = 1) THEN
                           CASE
                               WHEN (branch.opentime::time < branch.closetime::time) THEN
                                   CASE
                                       WHEN (branch.opentime::time <= (now() AT TIME ZONE 'Asia/Amman'::text)::time)
                                            AND (branch.closetime::time >= (now() AT TIME ZONE 'Asia/Amman'::text)::time)
                                       THEN 1
                                       ELSE 0
                                   END
                               ELSE CASE
                                       WHEN (branch.closetime::time <= (now() AT TIME ZONE 'Asia/Amman'::text)::time)
                                            AND (branch.opentime::time >= (now() AT TIME ZONE 'Asia/Amman'::text)::time)
                                       THEN 0
                                       ELSE 1
                                   END
                           END
                       ELSE 0
                   END AS status,
                   branch.addressname,
                   branch.menuid,
                   branch.latitude,
                   branch.longtitude,
                   branch.phonenumber,
                   case when  (
                  select m.isavailable as hasactivemenu
                  from menu m
                  left join  menuchannel mc on m.id = mc.menuid
                   where mc.branchid = branch.id
                     and mc.channelid ='4bba2939-a11f-43eb-845d-2e2b9e23c29d'
                      ) then true
                  else false
                 end as hasactivemenu,
                   distance(branch.latitude, branch.longtitude, _latitude, _longitude) AS distancee
            FROM branch
            WHERE branch.companyid = _companyid
              AND branch.isdeleted = FALSE
              AND branch.ispublished = TRUE
        ),
        feescalculation AS (
            SELECT db.id AS branch_id,
                   db.distancee,
                   CASE
                       WHEN _iscalc = TRUE AND _isintegration = TRUE THEN
                           COALESCE(
                               (SELECT bc.price
                                FROM branchcalculator bc
                                WHERE bc.startperiod <= db.distancee
                                  AND bc.endperiod > db.distancee
                                  AND bc.branchid = db.id
                                LIMIT 1),
                               (SELECT 0
                                FROM public.branchdelivery bdy
                                WHERE bdy.branchid = db.id
                                  AND bdy.maxdistance >= db.distancee
                                LIMIT 1)
                           )
                       WHEN _iscalc = TRUE THEN
                           (SELECT bc.price
                            FROM branchcalculator bc
                            WHERE bc.startperiod <= db.distancee
                              AND bc.endperiod > db.distancee
                              AND bc.branchid = db.id
                            LIMIT 1)
                       WHEN _isintegration = TRUE THEN
                           (SELECT 0
                            FROM public.branchdelivery bdy
                            WHERE bdy.branchid = db.id
                              AND bdy.maxdistance >= db.distancee
                            LIMIT 1)
                       ELSE NULL
                   END AS fees
            FROM distancebranch db
        )
        SELECT db.id,
               db.name,
               db.opentime,
               db.closetime,
               db.status,
               db.addressname,
               db.menuid,
               db.latitude,
               db.longtitude,
               db.phonenumber,
               db.hasactivemenu,
               db.distancee,
               fc.fees
        FROM distancebranch db
        LEFT JOIN feescalculation fc ON fc.branch_id = db.id
        where fc.fees is not null
        ORDER BY db.distancee;
END;
$$;


--
-- Name: getbranchavailability(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchavailability(_menuid uuid, _objectid uuid) RETURNS TABLE(channelname public.citext, id uuid, name public.citext, isavailable boolean)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
        SELECT DISTINCT clk.name,
                        mc.branchid,
                        b.name,
                        CASE
                            WHEN bav.objectid IS NOT NULL THEN FALSE
                            ELSE true
                            END AS isavailable
        FROM menuchannel mc
                 INNER JOIN branch b ON b.id = mc.branchid
                 LEFT JOIN branchavailability bav
                           ON bav.branchid = mc.branchid
                               AND bav.objectid = _objectid
                               AND bav.channelid = mc.channelid
                 LEFT JOIN channellookup clk ON clk.id = mc.channelid
        WHERE mc.menuid = _menuid;
    --AND mc.channelid = ANY(_channelids);
END;
$$;


--
-- Name: getbranchavailabilitybycatgeory(uuid, uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchavailabilitybycatgeory(_id uuid, _callid uuid, _channel public.citext) RETURNS TABLE(id uuid)
    LANGUAGE plpgsql
    AS $$
    BEGIN
    RETURN QUERY
    select br.id
    from branch br inner join menuchannel m on m.branchid = br.id where m.menuid = _id and m.channelid = (select nlk.id from namelookup nlk where nlk.name =_channel) and br.isdeleted = false and br.ispublished = true and br.id NOT IN (select branchid from branchavailability where objectid = _callid and branchid = br.id) ;
    END;
    
$$;


--
-- Name: getbranchbyarrayproduct(uuid[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchbyarrayproduct(_id uuid[] DEFAULT NULL::uuid[]) RETURNS TABLE(id uuid, name public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select distinct("bra".id),"bra".name from branch bra INNER JOIN menuproduct menpro ON "menpro".menuid = "bra".menuid INNER JOIN product pro ON "pro".id = "menpro".productid WHERE "pro".id = ANY(_id) and "menpro".isdeleted = false and "menpro".ispublished = true and "bra".isdeleted = false and "bra".ispublished = true ;

END;
$$;


--
-- Name: branch; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.branch (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    name public.citext NOT NULL,
    companyid uuid NOT NULL,
    addressid uuid,
    opentime timestamp without time zone,
    closetime timestamp without time zone,
    status integer DEFAULT 1 NOT NULL,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext,
    phonenumber public.citext NOT NULL,
    countryid uuid NOT NULL,
    addressname public.citext,
    menuid uuid,
    latitude numeric,
    longtitude numeric,
    isautoaccept boolean DEFAULT false NOT NULL,
    isautoprint boolean DEFAULT false NOT NULL,
    printdelay timestamp without time zone,
    delay jsonb,
    copies integer,
    namelanguage jsonb
);


--
-- Name: getbranchbybranchid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchbybranchid(_branchid uuid DEFAULT NULL::uuid) RETURNS SETOF public.branch
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select * from branch br where br.id = _branchid and isdeleted = false and ispublished = true;
END
$$;


--
-- Name: getbranchbyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchbyid(_id uuid DEFAULT NULL::uuid) RETURNS SETOF public.branch
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select * from branch where id = _id and isdeleted = false and ispublished = true;
END;
$$;


--
-- Name: getbranchbyname(public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchbyname(_name public.citext DEFAULT NULL::public.citext) RETURNS SETOF public.branch
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select * from branch where name = _name and isdeleted = false and ispublished = true;
END;
$$;


--
-- Name: getbranchcashiername(uuid[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchcashiername(_ids uuid[] DEFAULT NULL::uuid[]) RETURNS TABLE(id uuid, name public.citext, status integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select branch.id,branch.name,branch.status from branch where branch.id = any(_ids) and isdeleted = false and ispublished = true;
END;
$$;


--
-- Name: getbranchcategories(uuid[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchcategories(_branchid uuid[] DEFAULT NULL::uuid[]) RETURNS TABLE(id uuid, name jsonb, displayorder integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select distinct category.id , category.name , category.displaynumber
from branch 
left join menu on branch.menuid = menu.id 
left join menuproduct on menu.id = menuproduct.menuid 
left join product on product.id = menuproduct.productid
left join category on product.categoryid = category.id
where branch.id =any(_branchid) and menu.isdeleted = false and menu.isavailable = true and menu.ispublished = true and product.isdeleted = false
order by category.displaynumber ;
END;
$$;


--
-- Name: getbranchcategoriesfrommenu(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchcategoriesfrommenu(_branchid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, name jsonb, image public.citext, displaynumber integer, products json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select distinct category.id , category.name as name , category.image , category.displaynumber , to_json( Array( select to_json(json_build_object('id',product.id,'name', product.name ,'image', product.imagepath,'fulldescription', product.fulldescription ,'shortdescription', product.shortdescription ,'price', product.price,'displaynumber',product.displaynumber
))from branch 
left join menu on branch.menuid = menu.id 
left join menuproduct on menu.id = menuproduct.menuid 
left join product on product.id = menuproduct.productid 
where product.isdeleted = false and product.ispublished = true and product.isavailable = true and product.id not in (select distinct unnest(productids) from productavailability where isavailable = false) 
and product.categoryid = category.id and product.id is not null order by product.displaynumber ASC ))::json
from branch 
left join menu on branch.menuid = menu.id 
left join menuproduct on menu.id = menuproduct.menuid 
left join product on product.id = menuproduct.productid 
left join category on product.categoryid = category.id
where branch.id = _branchid and menu.isdeleted = false
and menu.isavailable = true and menu.ispublished = true
and product.ispublished =true and 
product.isavailable = true and product.isdeleted = false
and product.id not in (select distinct unnest(productids) from productavailability where isavailable = false and isdeleted = false and ispublished = true) 
order by category.displaynumber ;
END;
$$;


--
-- Name: getbranchcategoriesfrommenu4(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchcategoriesfrommenu4(_branchid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, name jsonb, image public.citext, displaynumber integer, product json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select cat.id , cat.name as name , CONCAT(cat.image)::citext , cat.displaynumber,to_json(array(select to_json(json_build_object('products',getcategoryavailableitemsfrommenu(cat.id,_branchid)))))
from branch
left join menu on branch.menuid = menu.id
left join menucategories mc on mc.menuid = menu.id
left join category cat on cat.id = mc.categoryid
where branch.id = _branchid and menu.isdeleted = false
and menu.isavailable = true and menu.ispublished = true
and cat.id not in (select objectid from branchavailability where branchid =_branchid)
order by cat.displaynumber;
END;
$$;


--
-- Name: getbranchcategoriesfrommenuforagent(uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchcategoriesfrommenuforagent(_branchid uuid DEFAULT NULL::uuid, _channelid public.citext DEFAULT NULL::public.citext) RETURNS TABLE(id uuid, name jsonb, image public.citext, displaynumber integer, product json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select cat.id , cat.name as name , CONCAT(cat.image)::citext , cat.displaynumber,to_json(array(select to_json(json_build_object('products',getcategoryavailableitemsfrommenuforagent(cat.id,_branchid,_channelid)))))
from branch
left join menu on menu.id = (select menu.id from menu where menu.id = any(select mch.menuid from menuchannel mch where mch.branchid = branch.id and mch.channelid =(select nlp.id from namelookup nlp where nlp.name =_channelid)) and menu.isdeleted = false)
left join menucategories mc on mc.menuid = menu.id
left join category cat on cat.id = mc.categoryid
where branch.id = _branchid and menu.isdeleted = false
and menu.isavailable = true and menu.ispublished = true
and cat.id not in (select bav.objectid from branchavailability bav where bav.branchid =_branchid and bav.channelid = (select  clk.id from public.channellookup clk where clk.name = _channelid))
order by cat.displaynumber;
END;
$$;


--
-- Name: getbranchchartdashboardreport(uuid[], uuid[], timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchchartdashboardreport(_branchids uuid[], _channels uuid[] DEFAULT NULL::uuid[], _from timestamp without time zone DEFAULT NULL::timestamp without time zone, _to timestamp without time zone DEFAULT NULL::timestamp without time zone) RETURNS TABLE(data json)
    LANGUAGE plpgsql
    AS $$
BEGIN
return query 
select to_json(
	array(
		select to_json(
			json_build_object( 
					'branchname',(select branch.name from branch where branch.id = "order".branchid),
					'totalprice', sum(coalesce(nullif("order".totalprice,0),("order".price->>'FinalPrice')::numeric -  ("order".price->>'DeliveryPrice')::numeric)))) from "order"
where "order".branchid = any(_branchids)
and ((_channels is null) or ("order".ordersource=any(_channels)))
and ((_from is null) or ("order".createdat >=  to_char(_from,'YYYY-MM-DD 00:00:00')::timestamp))
and ((_to is null) or ("order".createdat <= to_char(_to,'YYYY-MM-DD 23:59:59')::timestamp)) 
group by "order".branchid));
END;
$$;


--
-- Name: getbranchdeliverycalculatorprice(uuid, numeric); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchdeliverycalculatorprice(_branchid uuid, _distance numeric) RETURNS TABLE(price numeric)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select bc.price from branchcalculator bc where bc.startperiod <= _distance and bc.endperiod > _distance and bc.branchid = _branchid;
END;
$$;


--
-- Name: getbranchdeliverycalculatorprice_ai(uuid, numeric); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchdeliverycalculatorprice_ai(_branchid uuid, _distance numeric) RETURNS TABLE(price numeric)
    LANGUAGE plpgsql
    AS $$

BEGIN
RETURN QUERY
    select bc.price from branchcalculator bc where bc.startperiod <= _distance and bc.endperiod > _distance and bc.branchid = _branchid;
END;
$$;


--
-- Name: getbranchdeliverycalculatorpriceforonlineordering(uuid, numeric); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchdeliverycalculatorpriceforonlineordering(_branchid uuid, _distance numeric) RETURNS TABLE(price numeric)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select bc.price from branchcalculator bc where bc.startperiod <= _distance and bc.endperiod > _distance and bc.branchid = _branchid;
END;
$$;


--
-- Name: getbranchdeliverycharge(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchdeliverycharge(_branchid uuid) RETURNS TABLE(branchid uuid, city public.citext, area public.citext, subarea public.citext, fees numeric)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select  bdc.branchid, bdc.city, bdc.area, bdc.subarea, bdc.fees from branchdeliverycharge bdc;
END;
$$;


--
-- Name: getbranchdeliverychargelabel(uuid, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchdeliverychargelabel(_companyid uuid DEFAULT NULL::uuid, _pagenumber integer DEFAULT 1, _pagesize integer DEFAULT 7) RETURNS TABLE(totalcount bigint, pagecount bigint, data json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select count(brdc1.id) totalcount , ceil(count(brdc1.id)/ _pagesize::decimal)::bigint pagecount ,  
 to_json(
        Array(
            select
                to_json(
                    json_build_object( 'id',branch.id, 
									  'branchname',branch.name,
									  'cityname',brdc.city,
									  'areaname',brdc.area, 
									  'subareaname',brdc.subarea, 
									  'fees',brdc.fees, 
									  'controlid',brdc.id ))
from branchdeliverycharge as brdc
inner join branch on brdc.branchid = branch.id
where branch.companyid = _companyid 
limit _pagesize
OFFSET ((_pagenumber-1) * _pagesize)))
from branchdeliverycharge brdc1
inner join branch on brdc1.branchid = branch.id 
where branch.companyid =_companyid;
END;
$$;


--
-- Name: getbranchdeliverychargenew(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchdeliverychargenew(_id uuid) RETURNS TABLE(id uuid)
    LANGUAGE plpgsql
    AS $$
    BEGIN
    RETURN QUERY
        select branchid from branchdeliverycharge where branchid =any(select id from branch where companyid = _id);       
    END;
$$;


--
-- Name: getbranchdeliverycompany(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchdeliverycompany(_companyid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, name public.citext, deliverycompanyid uuid, deliverycompanyname public.citext, maxdistance integer, priority integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select branch.id, branch.name, deliverycompany.id,trim(both '"' from  (deliverycompany.name->'en')::citext)::citext as deliverycompanyname
,branchdelivery.maxdistance,branchdelivery.priority from branchdelivery inner join branch on branch.id = branchdelivery.branchid
inner join deliverycompany on deliverycompany.id = branchdelivery.deliverycompanyid
where branch.companyid = _companyid;
END;
$$;


--
-- Name: getbranchdeliveryfeesbylabel(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchdeliveryfeesbylabel(_companyid uuid DEFAULT NULL::uuid) RETURNS TABLE(branchid uuid, branchname public.citext, city public.citext, area public.citext, subarea public.citext, fees numeric)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select 
branch.id branchid,
branch.name branchname,
branchdeliverycharge.city city, 
branchdeliverycharge.area area,
branchdeliverycharge.subarea subarea,
branchdeliverycharge.fees fees
from branchdeliverycharge
inner join branch on branchdeliverycharge.branchid = branch.id 
where branch.companyid = _companyid;
END;
$$;


--
-- Name: getbranchdeliveryforview(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchdeliveryforview(_branchid uuid, _companyid uuid) RETURNS TABLE(branchname public.citext, branchid uuid, startperiod numeric, endperiod numeric, price numeric)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
   select b.name, bc.branchid, bc.startperiod, bc.endperiod, bc.price from branchcalculator bc
    inner join branch b on b.id = bc.branchid and b.companyid = _companyid where bc.branchid = _branchid;
END;
$$;


--
-- Name: getbranchdeliverymethods(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchdeliverymethods(_id uuid) RETURNS TABLE(methods jsonb)
    LANGUAGE plpgsql
    AS $$
                  BEGIN
                  RETURN QUERY
                          select to_json(
               jsonb_build_object(
                       'label', (select CASE WHEN count(*) > 0 THEN true ELSE false END from branchdeliverycharge where branchid = any (select id from branch where companyid = _id)),
                       'calculator', (select CASE WHEN count(*) > 0 THEN true ELSE false END from branchcalculator where branchid = any (select id from branch where companyid = _id)),
                       'integration', (select CASE WHEN count(*) > 0 THEN true ELSE false END from branchdelivery where branchid = any (select id from branch where companyid = _id))
                   ))::jsonb
           as methods;
                  END;

$$;


--
-- Name: getbranchdeliverymethodsforonlineordering(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchdeliverymethodsforonlineordering(_id uuid) RETURNS TABLE(methods jsonb)
    LANGUAGE plpgsql
    AS $$
                  BEGIN
                  RETURN QUERY
                           select to_json(
                               jsonb_build_object(
                                      'label',(select CASE WHEN count(*) > 0 THEN (select to_json(array(select to_json(jsonb_build_object( 'id', branchid)) from branchdeliverycharge where branchid =any(select id from branch where companyid = _id)))) ELSE 'false' END from branchdeliverycharge where branchid =any(select id from branch where companyid = _id)),
                                      'calculator',(select CASE WHEN count(*) > 0 THEN (select to_json(array(select  to_json(jsonb_build_object( 'id', branchid)) from branchcalculator where branchid =any(select id from branch where companyid = _id)))) ELSE 'false' END from branchcalculator where branchid =any(select id from branch where companyid = _id)),
                                      'integration',(select CASE WHEN count(*) > 0 THEN (select to_json(array(select  to_json(jsonb_build_object( 'id', branchid)) from branchdelivery where branchid =any(select id from branch where companyid = _id)))) ELSE 'false' END from branchdelivery where branchid =any(select id from branch where companyid = _id))
                                      ))::jsonb
                           as methods;
                  END;

$$;


--
-- Name: getbranchdeliveryview(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchdeliveryview(_companyid uuid) RETURNS TABLE(name public.citext, branchid uuid)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select distinct b.name, bc.branchid from branchcalculator bc inner join branch b on b.id = bc.branchid
    where b.companyid = _companyid;
END;
$$;


--
-- Name: getbranchebranchid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchebranchid(_branchid uuid DEFAULT NULL::uuid) RETURNS SETOF public.branch
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select branch.* from branch  where  "branch".id = _branchid and "branch".isdeleted = false and "branch".ispublished = true;
END
$$;


--
-- Name: getbranches(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranches(pagenumber integer DEFAULT NULL::integer, pagesize integer DEFAULT NULL::integer) RETURNS SETOF public.branch
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select * from branch where isdeleted = false and ispublished=true
LIMIT PageSize
OFFSET ((PageNumber-1) * PageSize);
END;
$$;


--
-- Name: getbranchesbylabeladdresses(uuid, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchesbylabeladdresses(_companyid uuid, _areacodeid integer, _cityid integer, _areaid integer) RETURNS TABLE(id uuid, name public.citext, fees numeric, opentime timestamp without time zone, closetime timestamp without time zone, status integer, addressname public.citext, menuid uuid, latitude numeric, longtitude numeric, phonenumber public.citext, hasactivemenu boolean)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        branch.id,
        branch.name,
        branchsubareafees.fees,
         branch.opentime,
         branch.closetime,
case when ("branch".status = 1) then
case when ("branch".opentime::time < "branch".closetime::time) then
case when (("branch".opentime::time <= ((now() AT TIME ZONE 'Asia/Amman'::text)::time))
		   and ("branch".closetime::time >= (now() AT TIME ZONE 'Asia/Amman'::text)::time) )  then 1 else 0 end
else case when (("branch".closetime::time <= (now() AT TIME ZONE 'Asia/Amman'::text)::time)
		   and ("branch".opentime::time >= (now() AT TIME ZONE 'Asia/Amman'::text)::time) )  then 0 else 1 end
		   end
else 0 end ,
        branch.addressname,
         branch.menuid,
         branch.latitude,
         branch.longtitude,
         branch.phonenumber,
         case when  (
                  select m.isavailable as hasactivemenu
                  from menu m
                  left join  menuchannel mc on m.id = mc.menuid
                   where mc.branchid = branch.id
                     and mc.channelid ='4bba2939-a11f-43eb-845d-2e2b9e23c29d'
                      ) then true
                  else false
                 end as hasactivemenu
    FROM
        public.branch
    LEFT JOIN
        branchsubareafees
        ON branchsubareafees.branchid = branch.id
    WHERE
        branch.companyid = _companyid and branch.isdeleted = false and branch.ispublished = true
        AND branchsubareafees.areacodeid = _areacodeid and branchsubareafees.areaid = _areaid and branchsubareafees.cityid = _cityid;
END;
$$;


--
-- Name: getbranchesforcompany(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchesforcompany(_companyid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, name public.citext, namelanguage jsonb, companyid uuid, addressname public.citext, opentime timestamp without time zone, closetime timestamp without time zone, status integer, countryid uuid, createdat timestamp without time zone, createdby public.citext, latitude numeric, longtitude numeric, phonenumber public.citext, transferbranch json, hasactivemenu boolean, addressid uuid, branchaddressname public.citext, isautoaccept boolean, isautoprint boolean, copies integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select "branch".id,"branch".name,"branch".namelanguage,"branch".companyid,"branch".addressname ,"branch".opentime,"branch".closetime,
case when ("branch".status = 1) then
case when ("branch".opentime::time < "branch".closetime::time) then 
case when (("branch".opentime::time <= ((now() AT TIME ZONE 'Asia/Amman'::text)::time))  
		   and ("branch".closetime::time >= (now() AT TIME ZONE 'Asia/Amman'::text)::time) )  then 1 else 0 end
else case when (("branch".closetime::time <= (now() AT TIME ZONE 'Asia/Amman'::text)::time)  
		   and ("branch".opentime::time >= (now() AT TIME ZONE 'Asia/Amman'::text)::time) )  then 0 else 1 end
		   end
else 0 end ,"branch".countryid,"branch".createdat,"branch".createdby,"branch".latitude,"branch".longtitude,"branch".phonenumber,
 (select to_json(json_build_object(
	 'id',transferbranch.id,
	 'isactive',transferbranch.isactive,
	 'transfertobranchid',transferbranch.transfertobranchid,
   	 'transferedtobranch',(select br.name from branch br where br.id = transferbranch.transfertobranchid ))) from transferbranch 
	 where isactive = true and branchidselected = "branch".id
	 and ((fromdate is null and todate is null) or(fromdate <= (now() AT TIME ZONE 'Asia/Amman'::text)::timestamp) and (todate >= (now() AT TIME ZONE 'Asia/Amman'::text)::timestamp))
) ,
(case when menuid is null then false else (select menu.isavailable from menu where menu.id = branch.menuid and menu.isdeleted = false) end)
, branch.addressid,(select getaddressname(branch.addressid)),branch.isautoaccept,branch.isautoprint,branch.copies
from branch  where  "branch".companyid = _companyid and "branch".isdeleted = false and "branch".ispublished = true;
END
$$;


--
-- Name: getbranchesforcompanynew(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchesforcompanynew(_companyid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, name public.citext, namelanguage jsonb, companyid uuid, addressname public.citext, opentime timestamp without time zone, closetime timestamp without time zone, status integer, countryid uuid, createdat timestamp without time zone, createdby public.citext, latitude numeric, longtitude numeric, phonenumber public.citext, transferbranch json, hasactivemenu boolean, addressid uuid, branchaddressname public.citext, isautoaccept boolean, isautoprint boolean, copies integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select "branch".id,"branch".name,"branch".namelanguage,"branch".companyid,"branch".addressname ,"branch".opentime,"branch".closetime,
case when ("branch".status = 1) then
case when ("branch".opentime::time < "branch".closetime::time) then
case when (("branch".opentime::time <= ((now() AT TIME ZONE 'Asia/Amman'::text)::time))
		   and ("branch".closetime::time >= (now() AT TIME ZONE 'Asia/Amman'::text)::time) )  then 1 else 0 end
else case when (("branch".closetime::time <= (now() AT TIME ZONE 'Asia/Amman'::text)::time)
		   and ("branch".opentime::time >= (now() AT TIME ZONE 'Asia/Amman'::text)::time) )  then 0 else 1 end
		   end
else 0 end ,"branch".countryid,"branch".createdat,"branch".createdby,"branch".latitude,"branch".longtitude,"branch".phonenumber,
 (select to_json(json_build_object(
	 'id',transferbranch.id,
	 'isactive',transferbranch.isactive,
	 'transfertobranchid',transferbranch.transfertobranchid,
   	 'transferedtobranch',(select br.name from branch br where br.id = transferbranch.transfertobranchid ))) from transferbranch
	 where isactive = true and branchidselected = "branch".id
	 and ((fromdate is null and todate is null) or(fromdate <= (now() AT TIME ZONE 'Asia/Amman'::text)::timestamp) and (todate >= (now() AT TIME ZONE 'Asia/Amman'::text)::timestamp))
) ,
(case when (menuid is null and ((select Count(mch.menuid) from menuchannel mch where mch.branchid = branch.id and mch.channelid ='4bba2939-a11f-43eb-845d-2e2b9e23c29d') < 1)) then false
 when (menuid is null and ((select Count(mch.menuid) from menuchannel mch where mch.branchid = branch.id and mch.channelid ='4bba2939-a11f-43eb-845d-2e2b9e23c29d' ) > 0)) then (select menu.isavailable from menu where menu.id = any(select mch.menuid from menuchannel mch where mch.branchid = branch.id and mch.channelid ='4bba2939-a11f-43eb-845d-2e2b9e23c29d') and menu.isdeleted = false)
 else (select menu.isavailable from menu where menu.id = branch.menuid and menu.isdeleted = false) end)
, branch.addressid,(select getaddressname(branch.addressid)),branch.isautoaccept,branch.isautoprint,branch.copies
from branch  where  "branch".companyid = _companyid and "branch".isdeleted = false and "branch".ispublished = true;
END
$$;


--
-- Name: getbranchesforcompanyoperation(uuid[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchesforcompanyoperation(_companyid uuid[]) RETURNS TABLE(id uuid, name public.citext, companyid uuid, addressname public.citext, opentime timestamp without time zone, closetime timestamp without time zone, status integer, countryid uuid, createdat timestamp without time zone, createdby public.citext, latitude numeric, longtitude numeric, phonenumber public.citext, transferbranch json, hasactivemenu boolean)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select "branch".id,CONCAT("branch".name,'-',co.name)::citext,"branch".companyid,"branch".addressname ,"branch".opentime,"branch".closetime,  
case when ("branch".status = 1) then
case when (("branch".opentime::time <= (now() AT TIME ZONE 'Asia/Amman'::text)::time) and ("branch".closetime::time >= (now() AT TIME ZONE 'Asia/Amman'::text)::time))  then 1 else 0 end
else 0 end
 ,"branch".countryid,"branch".createdat,"branch".createdby,"branch".latitude,"branch".longtitude,"branch".phonenumber,
 (select to_json(json_build_object(
	 'id',transferbranch.id,
	 'isactive',transferbranch.isactive,
	 'transfertobranchid',transferbranch.transfertobranchid,
   	 'transferedtobranch',(select br.name from branch br where br.id = transferbranch.transfertobranchid ))) from transferbranch 
	 where isactive = true and branchidselected = "branch".id
	 and ((fromdate is null and todate is null) or(fromdate <= (now() AT TIME ZONE 'Asia/Amman'::text)::timestamp) and (todate >= (now() AT TIME ZONE 'Asia/Amman'::text)::timestamp))
) ,
(case when menuid is null then false else (select menu.isavailable from menu where menu.id = branch.menuid and menu.isdeleted = false) end)
from branch
left join company co on co.id = "branch".companyid
where "branch".companyid = any(_companyid) and "branch".isdeleted = false and "branch".ispublished = true;
END
$$;


--
-- Name: getbranchesids(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchesids(_menuid uuid DEFAULT NULL::uuid, _channelid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select mc.branchid from menuchannel mc where mc.menuid = _menuid and mc.channelid = _channelid ;
END;
$$;


--
-- Name: getbranchesmappedtoashyaeebymenuid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchesmappedtoashyaeebymenuid(_menuid uuid) RETURNS TABLE(id uuid, name public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        mc.branchid AS id,
        b.name AS name
    FROM public.branch b
    JOIN public.menuchannel mc ON b.id = mc.branchid
    JOIN public.ashyaeemappedentities ame ON ame.ishbekid = b.id
    WHERE mc.menuid = _menuid;
END;
$$;


--
-- Name: getbranchesname(uuid[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchesname(_id uuid[] DEFAULT NULL::uuid[]) RETURNS SETOF public.citext
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select name  from branch where id =  any(_id) and isdeleted = false and ispublished = true;
END;
$$;


--
-- Name: getbranchforaddress(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchforaddress(_addressid uuid DEFAULT NULL::uuid, _companyid uuid DEFAULT NULL::uuid) RETURNS TABLE(name public.citext, phonenumber public.citext, companyid uuid, countryid uuid, opentime timestamp without time zone, calculatorprice numeric, closetime timestamp without time zone, addressname public.citext, status integer, id uuid, createdat timestamp without time zone, createdby public.citext, hasactivemenu boolean)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY

--select branchaddress.id, branchaddress.branchid, branchaddress.addressid from branchaddress
--inner join branch on branch.id = branchaddress.branchid
--inner join branchdeliveryaddress on branchdeliveryaddress.branchaddress = branchaddress.addressid
--where branch.companyid = _companyid and branchaddress.addressid = _addressid;

select
branch.name,
branch.phonenumber,
branch.companyid,
branch.countryid,
branch.opentime,
b.fees,
branch.closetime,
branch.addressname,
case when (branch.status = 1) then
case when (branch.opentime::time < branch.closetime::time) then
case when ((branch.opentime::time <= ((now() AT TIME ZONE 'Asia/Amman'::text)::time))
		   and (branch.closetime::time >= (now() AT TIME ZONE 'Asia/Amman'::text)::time) )  then 1 else 0 end
else case when ((branch.closetime::time <= (now() AT TIME ZONE 'Asia/Amman'::text)::time)
		   and (branch.opentime::time >= (now() AT TIME ZONE 'Asia/Amman'::text)::time) )  then 0 else 1 end
		   end
else 0 end ,
branch.id,
branch.createdat,
branch.createdby ,
(case when (menuid is null and ((select Count(mch.menuid) from menuchannel mch where mch.branchid = branch.id and mch.channelid ='4bba2939-a11f-43eb-845d-2e2b9e23c29d') < 1)) then false
 when (menuid is null and ((select Count(mch.menuid) from menuchannel mch where mch.branchid = branch.id and mch.channelid ='4bba2939-a11f-43eb-845d-2e2b9e23c29d' ) > 0)) then (select menu.isavailable from menu where menu.id = any(select mch.menuid from menuchannel mch where mch.branchid = branch.id and mch.channelid ='4bba2939-a11f-43eb-845d-2e2b9e23c29d') and menu.isdeleted = false)
 else (select menu.isavailable from menu where menu.id = branch.menuid and menu.isdeleted = false) end)

from branch
inner join branchdeliverycharge b on branch.id = b.branchid
--inner join branchaddress on branchaddress.branchid = branch.id
--inner join branchdeliveryaddress on branchdeliveryaddress.branchaddress = branchaddress.addressid
where branch.companyid = _companyid and (b.id = _addressid or b.subarea = (select branchdeliverycharge.subarea from branchdeliverycharge where branchdeliverycharge.id = (select labeladdressid from customeraddress where addressid = _addressid)));
--and (select count(branchaddress.id) from branchaddress where branchaddress.addressid = _addressid and branchid = branch.id) >=1
END;
$$;


--
-- Name: getbranchforaddressbylabel(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchforaddressbylabel(_addressid uuid DEFAULT NULL::uuid, _companyid uuid DEFAULT NULL::uuid) RETURNS TABLE(name public.citext, phonenumber public.citext, companyid uuid, countryid uuid, opentime timestamp without time zone, closetime timestamp without time zone, addressname public.citext, status integer, id uuid, createdat timestamp without time zone, createdby public.citext, hasactivemenu boolean)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY

--select branchaddress.id, branchaddress.branchid, branchaddress.addressid from branchaddress
--inner join branch on branch.id = branchaddress.branchid
--inner join branchdeliveryaddress on branchdeliveryaddress.branchaddress = branchaddress.addressid
--where branch.companyid = _companyid and branchaddress.addressid = _addressid;

select 
branch.name, 
branch.phonenumber, 
branch.companyid, 
branch.countryid, 
branch.opentime, 
branch.closetime, 
branch.addressname, 
case when (branch.status = 1) then
case when (branch.opentime::time < branch.closetime::time) then 
case when ((branch.opentime::time <= ((now() AT TIME ZONE 'Asia/Amman'::text)::time))  
		   and (branch.closetime::time >= (now() AT TIME ZONE 'Asia/Amman'::text)::time) )  then 1 else 0 end
else case when ((branch.closetime::time <= (now() AT TIME ZONE 'Asia/Amman'::text)::time)  
		   and (branch.opentime::time >= (now() AT TIME ZONE 'Asia/Amman'::text)::time) )  then 0 else 1 end
		   end
else 0 end ,
branch.id, 
branch.createdat,
branch.createdby ,
(case when menuid is null then false else (select menu.isavailable from menu where menu.id = branch.menuid and menu.isdeleted = false) end)
from branch
inner join branchdeliverycharge b on branch.id = b.branchid
--inner join branchaddress on branchaddress.branchid = branch.id
--inner join branchdeliveryaddress on branchdeliveryaddress.branchaddress = branchaddress.addressid
where branch.companyid = _companyid and (b.id = _addressid or b.id = (select labeladdressid from customeraddress where addressid = _addressid)); 
--and (select count(branchaddress.id) from branchaddress where branchaddress.addressid = _addressid and branchid = branch.id) >=1
END;
$$;


--
-- Name: getbranchforcalculater(uuid, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchforcalculater(_companyid uuid, _latitude double precision, _longtitude double precision) RETURNS TABLE(hasactivemenu boolean, status integer, createdby public.citext, createdat timestamp without time zone, countryid uuid, addressid uuid, addressname public.citext, phonenumber public.citext, name public.citext, id uuid, companyid uuid, latitude numeric, longtitude numeric, opentime timestamp without time zone, closetime timestamp without time zone, isactive integer, distance double precision)
    LANGUAGE plpgsql
    AS $$
    BEGIN
    RETURN QUERY
    select
    (select menu.isavailable from menu where branch.menuid = menu.id and branch.isdeleted = false),
    branch.status, branch.createdby,
    branch.createdat, branch.countryid,
    branch.addressid, branch.addressname,
    branch.phonenumber, branch.name,
    branch.id, branch.companyid,
    branch.latitude, branch.longtitude,
    branch.opentime, branch.closetime,
    case when (branch.status = 1) then
    case when (branch.opentime::time < branch.closetime::time) then
    case when ((branch.opentime::time <= ((now() AT TIME ZONE 'Asia/Amman'::text)::time))
               and (branch.closetime::time >= (now() AT TIME ZONE 'Asia/Amman'::text)::time) )  then 1 else 0 end
    else case when ((branch.closetime::time <= (now() AT TIME ZONE 'Asia/Amman'::text)::time)
               and (branch.opentime::time >= (now() AT TIME ZONE 'Asia/Amman'::text)::time) )  then 0 else 1 end
               end
    else 0 end ,
    distance(branch.latitude, branch.longtitude, _latitude ,_longtitude) distance
    from branch
    inner join branchcalculator b on branch.id = b.branchid
    where branch.companyid = _companyid and branch.latitude is not null and branch.longtitude is not null and branch.isdeleted = false
    order by distance asc;

    END;
    $$;


--
-- Name: getbranchforcategorybymenuid(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchforcategorybymenuid(_id uuid, _callid uuid) RETURNS TABLE(id uuid, name public.citext, isavailable boolean)
    LANGUAGE plpgsql
    AS $$
    BEGIN
    RETURN QUERY
    select br.id,br.name,
    case when (br.id in (select branchid from branchavailability where objectid = _callid and branchid = br.id)) then false else true end
    from branch br inner join menuchannel m on m.branchid = br.id where m.menuid = _id and m.channelid = (select nlk.id from namelookup nlk where nlk.name ='callcenter') and br.isdeleted = false and br.ispublished = true ;

    END;

$$;


--
-- Name: getbranchforcategorybymenuidandchannel(uuid, uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchforcategorybymenuidandchannel(_id uuid, _callid uuid, _channel public.citext) RETURNS TABLE(id uuid)
    LANGUAGE plpgsql
    AS $$
    BEGIN
    RETURN QUERY
    select br.id
    from branch br inner join menuchannel m on m.branchid = br.id where m.menuid = _id and m.channelid = (select nlk.id from namelookup nlk where nlk.name =_channel) and br.isdeleted = false and br.ispublished = true 
    and br.id NOT IN (select branchid from branchavailability where objectid = _callid and branchid = br.id)
    ;
    END;
    
$$;


--
-- Name: getbranchfordistance(uuid, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchfordistance(_companyid uuid, _latitude double precision, _longtitude double precision) RETURNS TABLE(hasactivemenu boolean, status integer, createdby public.citext, createdat timestamp without time zone, countryid uuid, addressid uuid, addressname public.citext, phonenumber public.citext, name public.citext, id uuid, companyid uuid, latitude numeric, longtitude numeric, opentime timestamp without time zone, closetime timestamp without time zone, isactive integer, distance double precision, calculatorprice numeric, integrateddeliveries uuid[])
    LANGUAGE plpgsql
    AS $$
    BEGIN
    RETURN QUERY
    select
        que.hasactivemenu ,
        que.status ,
        que.createdby ,
        que.createdat ,
        que.countryid ,
        que.addressid ,
        que.addressname ,
        que.phonenumber ,
        que.name,
        que.id ,
        que.companyid ,
        que.latitude ,
        que.longtitude ,
        que.opentime ,
        que.closetime ,
        que.isactive ,
        que.distance ,
       (select getbranchdeliverycalculatorprice(que.id ,(que.distance::numeric) ) limit 1),
       (select array_agg(deliverycompanyid)::uuid[] from branchdelivery where branchid = que.id and ((maxdistance::numeric) >= (que.distance::numeric)))
    from getbranchfordistancemain(_companyid,_latitude,_longtitude) que
    where (((select getbranchdeliverycalculatorprice(que.id, (que.distance::numeric))) is not null)
               or
           (select count(*) from branchdelivery bd where bd.branchid = que.id and que.distance <= (maxdistance::numeric)) > 0
           )
    order by  distance;
    END;
$$;


--
-- Name: getbranchfordistance_ai(uuid, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchfordistance_ai(_companyid uuid, _latitude double precision, _longtitude double precision) RETURNS TABLE(hasactivemenu boolean, status integer, createdby public.citext, createdat timestamp without time zone, countryid uuid, addressid uuid, addressname public.citext, phonenumber public.citext, name public.citext, id uuid, companyid uuid, latitude numeric, longtitude numeric, opentime timestamp without time zone, closetime timestamp without time zone, isactive integer, distance double precision, calculatorprice numeric, integrateddeliveries uuid[])
    LANGUAGE plpgsql
    AS $$
    BEGIN
    RETURN QUERY
    select
        que.hasactivemenu ,
        que.status ,
        que.createdby ,
        que.createdat ,
        que.countryid ,
        que.addressid ,
        que.addressname ,
        que.phonenumber ,
        que.name,
        que.id ,
        que.companyid ,
        que.latitude ,
        que.longtitude ,
        que.opentime ,
        que.closetime ,
        que.isactive ,
        que.distance ,
       (select getbranchdeliverycalculatorprice_ai(que.id ,(que.distance::numeric) ) limit 1),
       (select array_agg(deliverycompanyid)::uuid[] from branchdelivery where branchid = que.id and ((maxdistance::numeric) >= (que.distance::numeric)))
    from getbranchfordistancemain_ai(_companyid,_latitude,_longtitude) que
    where (((select getbranchdeliverycalculatorprice_ai(que.id, (que.distance::numeric))) is not null)
               or
           (select count(*) from branchdelivery bd where bd.branchid = que.id and que.distance <= (maxdistance::numeric)) > 0
           )
    order by  distance;
    END;

$$;


--
-- Name: getbranchfordistancemain(uuid, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchfordistancemain(_companyid uuid, _latitude double precision, _longtitude double precision) RETURNS TABLE(hasactivemenu boolean, status integer, createdby public.citext, createdat timestamp without time zone, countryid uuid, addressid uuid, addressname public.citext, phonenumber public.citext, name public.citext, id uuid, companyid uuid, latitude numeric, longtitude numeric, opentime timestamp without time zone, closetime timestamp without time zone, isactive integer, distance double precision)
    LANGUAGE plpgsql
    AS $$
    BEGIN
    RETURN QUERY
    select
    (select menu.isavailable from menu where menu.id = (select menu.id from menu where menu.id = any(select mch.menuid from menuchannel mch where mch.branchid = branch.id and mch.channelid =(select nlk.id from namelookup nlk where nlk.name ='callcenter')) and menu.isdeleted = false) and branch.isdeleted = false),
    branch.status, branch.createdby,
    branch.createdat, branch.countryid,
    branch.addressid, branch.addressname,
    branch.phonenumber, branch.name,
    branch.id, branch.companyid,
    branch.latitude, branch.longtitude,
    branch.opentime, branch.closetime,
    case when (branch.status = 1) then
    case when (branch.opentime::time < branch.closetime::time) then
        case when ((branch.opentime::time <= ((now() AT TIME ZONE 'Asia/Amman'::text)::time)) and (branch.closetime::time >= (now() AT TIME ZONE 'Asia/Amman'::text)::time) )  then 1 else 0 end
        else case when ((branch.closetime::time <= (now() AT TIME ZONE 'Asia/Amman'::text)::time) and (branch.opentime::time >= (now() AT TIME ZONE 'Asia/Amman'::text)::time) )  then 0 else 1 end
    end
    else 0 end ,
    distance(branch.latitude, branch.longtitude, _latitude ,_longtitude) distanation
    from branch
        where branch.companyid = _companyid
        and branch.latitude is not null
        and branch.longtitude is not null
        and branch.isdeleted = false

    order by distance asc;

    END;
    
$$;


--
-- Name: getbranchfordistancemain_ai(uuid, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchfordistancemain_ai(_companyid uuid, _latitude double precision, _longtitude double precision) RETURNS TABLE(hasactivemenu boolean, status integer, createdby public.citext, createdat timestamp without time zone, countryid uuid, addressid uuid, addressname public.citext, phonenumber public.citext, name public.citext, id uuid, companyid uuid, latitude numeric, longtitude numeric, opentime timestamp without time zone, closetime timestamp without time zone, isactive integer, distance double precision)
    LANGUAGE plpgsql
    AS $$
    BEGIN
    RETURN QUERY
    select
    (select menu.isavailable from menu where menu.id = (select menu.id from menu where menu.id = any(select mch.menuid from menuchannel mch where mch.branchid = branch.id and mch.channelid =(select nlk.id from namelookup nlk where nlk.name ='callcenter')) and menu.isdeleted = false) and branch.isdeleted = false),
    branch.status, branch.createdby,
    branch.createdat, branch.countryid,
    branch.addressid, branch.addressname,
    branch.phonenumber, branch.name,
    branch.id, branch.companyid,
    branch.latitude, branch.longtitude,
    branch.opentime, branch.closetime,
    case when (branch.status = 1) then
    case when (branch.opentime::time < branch.closetime::time) then
        case when ((branch.opentime::time <= ((now() AT TIME ZONE 'Asia/Amman'::text)::time)) and (branch.closetime::time >= (now() AT TIME ZONE 'Asia/Amman'::text)::time) )  then 1 else 0 end
        else case when ((branch.closetime::time <= (now() AT TIME ZONE 'Asia/Amman'::text)::time) and (branch.opentime::time >= (now() AT TIME ZONE 'Asia/Amman'::text)::time) )  then 0 else 1 end
    end
    else 0 end ,
    distance_ai(branch.latitude, branch.longtitude, _latitude ,_longtitude) distanation
    from branch
        where branch.companyid = _companyid
        and branch.latitude is not null
        and branch.longtitude is not null
        and branch.isdeleted = false

    order by distance asc;

    END;
    
$$;


--
-- Name: getbranchfordistancemainbybranch(uuid, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchfordistancemainbybranch(_branchid uuid, _latitude double precision, _longtitude double precision) RETURNS TABLE(addressname public.citext, phonenumber public.citext, name public.citext, id uuid, companyid uuid, latitude numeric, longtitude numeric, opentime timestamp without time zone, closetime timestamp without time zone, isactive integer, distance double precision)
    LANGUAGE plpgsql
    AS $$
    BEGIN
    RETURN QUERY
    select branch.addressname,
    branch.phonenumber, branch.name,
    branch.id, branch.companyid,
    branch.latitude, branch.longtitude,
    branch.opentime, branch.closetime,
    case when (branch.status = 1) then
    case when (branch.opentime::time < branch.closetime::time) then
        case when ((branch.opentime::time <= ((now() AT TIME ZONE 'Asia/Amman'::text)::time)) and (branch.closetime::time >= (now() AT TIME ZONE 'Asia/Amman'::text)::time) )  then 1 else 0 end
        else case when ((branch.closetime::time <= (now() AT TIME ZONE 'Asia/Amman'::text)::time) and (branch.opentime::time >= (now() AT TIME ZONE 'Asia/Amman'::text)::time) )  then 0 else 1 end
    end
    else 0 end ,
    distance(branch.latitude, branch.longtitude, _latitude ,_longtitude) distanation
    from branch
        where branch.id = _branchid
        and branch.latitude is not null
        and branch.longtitude is not null
        and branch.isdeleted = false;

    END;
    
$$;


--
-- Name: getbranchforspecificcompanies(uuid[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchforspecificcompanies(_companyids uuid[]) RETURNS TABLE(id uuid, name public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select branch.id , concat(branch.name,' - ' ,company.name)::citext from branch 
 inner join company on branch.companyid = company.id
 where branch.companyid =any(_companyids) and branch.isdeleted = false;
END;
$$;


--
-- Name: getbranchidbytalabatorderid(public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchidbytalabatorderid(_talabatorderid public.citext) RETURNS SETOF uuid
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select ord.branchid
 from "order" ord where ord.referencenumber->>'Talabatdelivery' = _talabatorderid;
END;
$$;


--
-- Name: getbranchidorderid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchidorderid(_orderid uuid) RETURNS TABLE(branchid uuid)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select ord.branchid from "order" ord where ord.id = _orderid;
END;
$$;


--
-- Name: getbranchinfoformobile(uuid[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchinfoformobile(branchids uuid[]) RETURNS SETOF jsonb
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select to_json( Array( select to_json(json_build_object(
'id' , br.id,
'name', to_json(json_build_object(
'ar' , br.name,
'en',br.name)),
'status' , br.status,
'opentime' , br.opentime,
'closetime' , br.closetime,
'menuid' , br.menuid,
'latitude' , br.latitude,
'longtitude' , br.longtitude

))    from branch br where br.id =ANY(branchids))) ::jsonb;
END;
$$;


--
-- Name: getbranchmenuforcareemjson(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchmenuforcareemjson(_branchid uuid) RETURNS TABLE(menu json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN query

select row_to_json(getbranchmenuforcareemobject(_branchid));

END;
$$;


--
-- Name: getbranchmenuforcareemjson_careem(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchmenuforcareemjson_careem(_branchid uuid) RETURNS TABLE(menu json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN query

select row_to_json(getbranchmenuforcareemobject_careem(_branchid));

END;
$$;


--
-- Name: getbranchmenuforcareemobject(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchmenuforcareemobject(_branchid uuid) RETURNS TABLE(catalog json, categories json, items json, groups json, options json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN query
select getcatalogforcareemdto(_branchid), 
getcategoriesforcareemdto(((select menu.id from menu where menu.id = any(select mch.menuid from menuchannel mch where mch.branchid = _branchid and mch.channelid =(select nlp.id from namelookup nlp where nlp.name ='callcenter')) and menu.isdeleted = false))), 
getitemsforcareemdto((select getmenucategoryids((select menu.id from menu where menu.id = (select mch.menuid from menuchannel mch where mch.branchid = _branchid and mch.channelid =(select nlp.id from namelookup nlp where nlp.name ='callcenter')) and menu.isdeleted = false))),_branchid),
getgroupsforcareemdto((select array_agg(productid) from menuproduct where menuid = (select menu.id from menu where menu.id = (select mch.menuid from menuchannel mch where mch.branchid = _branchid and mch.channelid =(select nlp.id from namelookup nlp where nlp.name ='callcenter')) and menu.isdeleted = false))), 
getoptionsforcareemdto((select array_agg(productid) from menuproduct where menuid = (select menu.id from menu where menu.id = (select mch.menuid from menuchannel mch where mch.branchid = _branchid and mch.channelid =(select nlp.id from namelookup nlp where nlp.name ='callcenter')) and menu.isdeleted = false)));
END;
$$;


--
-- Name: getbranchmenuforcareemobject_careem(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchmenuforcareemobject_careem(_branchid uuid) RETURNS TABLE(catalog json, categories json, items json, groups json, options json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN query
select getcatalog_careem(_branchid),
getcategories_careem(((select menu.id from menu where menu.id = any(select mch.menuid from menuchannel mch where mch.branchid = _branchid and mch.channelid =(select nlp.id from namelookup nlp where nlp.name ='careem')) and menu.isdeleted = false))),
getitems_careem((select getmenucategoryids_careem((select menu.id from menu where menu.id = (select mch.menuid from menuchannel mch where mch.branchid = _branchid and mch.channelid =(select nlp.id from namelookup nlp where nlp.name ='careem')) and menu.isdeleted = false))),_branchid),
getgroups_careem((select array_agg(productid) from menuproduct where menuid = (select menu.id from menu where menu.id = (select mch.menuid from menuchannel mch where mch.branchid = _branchid and mch.channelid =(select nlp.id from namelookup nlp where nlp.name ='careem')) and menu.isdeleted = false)))
,
getoptions_careem((select array_agg(productid) from menuproduct where menuid = (select menu.id from menu where menu.id = (select mch.menuid from menuchannel mch where mch.branchid = _branchid and mch.channelid =(select nlp.id from namelookup nlp where nlp.name ='careem')) and menu.isdeleted = false))
           ,_branchid);
END;
$$;


--
-- Name: getbranchmenuintegrationbycompanyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchmenuintegrationbycompanyid(_id uuid) RETURNS SETOF public.branch
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select * from branch b where b.isdeleted = false and b.companyid = _id ;
END;
$$;


--
-- Name: getbranchname(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchname(_id uuid DEFAULT NULL::uuid) RETURNS SETOF public.citext
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select name  from branch where id = _id and isdeleted = false and ispublished = true;
END;
$$;


--
-- Name: getbranchnamethathavedeliverycompany(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchnamethathavedeliverycompany() RETURNS TABLE(id uuid, name public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY

select branch.id, concat(branch.name , ' - ', company.name)::citext from branch 
inner join company on branch.companyid = company.id
where (select count(branchdelivery.id) from  branchdelivery where branchdelivery.branchid = branch.id )>0;

END;
$$;


--
-- Name: getbranchorderhistory(uuid[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchorderhistory(_branchids uuid[]) RETURNS TABLE(branchorderid public.citext, id uuid, iscanceled boolean, ordersource public.citext, deliverytype public.citext, createdat timestamp without time zone, currentstatus public.citext, statuscolor public.citext, nextstatus uuid, isfirst boolean, islast boolean)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select  "order".branchorderid, "order".id,"order".iscanceled,getlookupname("order".ordersource),getdeliverycompanyname("order".deliverytype),
"order".createdat,
case when "order".isdeclined=false then (select st.status from orderstatuspossibilities st where st.id ="order".currentstatus) else 'declined' end
,case when "order".isdeclined=false then (select st.color from orderstatuspossibilities st where st.id ="order".currentstatus) else 'red' end ,pos.nextstatus , pos.isfirststatus, pos.islaststatus
from "order"
inner join orderstatuspossibilities pos on "order".currentstatus =pos.id

--"order".createdat <= now()::date-'1 day'::interval
--"order".createdat::date = (now() AT TIME ZONE 'Asia/Amman'::text)::date and  this condition was writte after the WHERE directly
 where "order".branchid = Any (_branchids) and
       (pos.isfirststatus is null
            or pos.isfirststatus != true or
        pos.status = 'Created' ) order by createdat desc;
END;
$$;


--
-- Name: getbranchorderhistory(uuid[], integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchorderhistory(_branchids uuid[], _pagenumber integer DEFAULT 1, _pagesize integer DEFAULT 5) RETURNS TABLE(totalcount bigint, branchorderid public.citext, id uuid, name public.citext, iscanceled boolean, ordersource public.citext, deliverytype public.citext, createdat timestamp without time zone, currentstatus public.citext, statuscolor public.citext, nextstatus uuid, isfirst boolean, islast boolean)
    LANGUAGE plpgsql
    AS $$
                  BEGIN
                  RETURN QUERY
                  select(
                  select count("order".id) from "order"
                                           inner join orderstatuspossibilities o on "order".currentstatus = o.id
                                           where "order".branchid = Any(_branchids) and(o.isfirststatus is null or o.isfirststatus != true or  o.status = 'Created' )
                                           ) AS totalcount,
                    "order".branchorderid, "order".id, cus.name ,"order".iscanceled,getlookupname("order".ordersource),getdeliverycompanyname("order".deliverytype),
                  "order".createdat,
                  case when "order".isdeclined=false then (select st.status from orderstatuspossibilities st where st.id ="order".currentstatus) else 'declined' end
                  ,case when "order".isdeclined=false then (select st.color from orderstatuspossibilities st where st.id ="order".currentstatus) else 'red' end ,pos.nextstatus , pos.isfirststatus, pos.islaststatus
                  from "order"
                  inner join orderstatuspossibilities pos on "order".currentstatus =pos.id
                  inner join customer cus on cus.id = "order".customerid

                  --"order".createdat <= now()::date-'1 day'::interval
                  --"order".createdat::date = (now() AT TIME ZONE 'Asia/Amman'::text)::date and  this condition was writte after the WHERE directly
                   where "order".branchid = Any (_branchids) and
                         (pos.isfirststatus is null
                              or pos.isfirststatus != true or
                          pos.status = 'Created' ) order by createdat desc
                      limit _pagesize
                      OFFSET ((_pagenumber-1) * _pagesize);
                  END;
$$;


--
-- Name: getbranchprinter(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchprinter(_branchid uuid) RETURNS SETOF public.printers
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
--USE
select * from printers where branchid = _branchid   ;
END;
$$;


--
-- Name: getbranchprintercategory(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchprintercategory(_id uuid) RETURNS TABLE(categoryinfo json, id uuid, name public.citext, type public.citext, categoryids uuid[])
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY

--use
select              to_json(
                            Array(
                                select
                                    to_json(
                                        json_build_object(
											 'id',
                                            cat.id,
                                            'name',
                                            cat.name
                                        )
                                    )
                                from category cat  
								where cat.id =any(pr.categoryids)
                            )
                        ),pr.id,pr.name,pr.type,pr.categoryids from printers pr where branchid = _id; END;
$$;


--
-- Name: getbranchprinters(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchprinters(_branchid uuid) RETURNS TABLE(id uuid, name public.citext, type json, categoryids json, channel json, paymentstatus json, isautoprint boolean, copies bigint)
    LANGUAGE plpgsql
    AS $$

    
BEGIN
RETURN QUERY

--USE
select vp.id,vp.name,
to_json( Array( select to_json(json_build_object('name',pr.types)) from printers pr where pr.printerid = vp.id LIMIT 1)),
to_json( Array( select to_json(json_build_object('id',ca.id,'name',ca.name)) from category ca where ca.id IN (select unnest(prs.categoryids) from printers prs where prs.printerid = vp.id ))),
to_json( Array( select to_json(json_build_object('id',nl.id,'name',nl.name)) from namelookup nl where nl.id IN (select unnest(prs.channel) from printers prs where prs.printerid = vp.id ))),
to_json( Array( select to_json(json_build_object('name',pr.paymentstatus)) from printers pr where pr.printerid = vp.id LIMIT 1)),
(select pr1.autoprint from printers pr1 where pr1.printerid = vp.id LIMIT 1),
(select pr1.noofcopy from printers pr1 where pr1.printerid = vp.id LIMIT 1) from viewprinter vp where vp.branchid =_branchid ;
END
$$;


--
-- Name: getbranchprinterscategory(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchprinterscategory(_branchid uuid) RETURNS TABLE(id uuid, name public.citext, type public.citext, categoryids json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY

--USE
select pr.id,vp.name,pr.type,to_json( Array( select to_json(json_build_object('id',ca.id,'name',ca.name)) from category ca where ca.id =any(pr.categoryids))) from viewprinter vp INNER JOIN printers pr ON pr.printerid = vp.id where vp.branchid =_branchid and pr.type = 'Kitchen' ;
END
$$;


--
-- Name: getbranchprintersettings(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchprintersettings(_id uuid) RETURNS TABLE(id uuid, name public.citext, isautoaccept boolean, isautoprint boolean, delay jsonb, copies integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
--USE
 select br.id , br.name, br.isautoaccept, br.isautoprint, br.delay, br.copies from branch br where br.id= _id and isdeleted = false ;
END;
$$;


--
-- Name: branchtemplate; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.branchtemplate (
    branchid uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    type public.citext NOT NULL,
    islogo boolean,
    isrestaurantname boolean,
    isphonenumber boolean,
    isbranchname boolean,
    isorderinfo boolean,
    isproductinfo boolean,
    isdeleted boolean DEFAULT false NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext,
    isordertype boolean,
    isordersource boolean,
    isscheduletime boolean,
    iscreatetime boolean,
    isordernote boolean,
    isdeliveryfees boolean,
    isorderprice boolean,
    istaxvalue boolean,
    istotal boolean,
    iscustomername boolean,
    iscustomerphone boolean,
    iscustomeraddress boolean,
    isdeliverynote boolean,
    istaxnumber boolean,
    isattribute boolean,
    issubattribute boolean,
    isproductnote boolean,
    isordernumber boolean,
    paid boolean DEFAULT false NOT NULL,
    taxnumbervalue public.citext
);


--
-- Name: getbranchprintertemplate(uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchprintertemplate(_branchid uuid, _type public.citext) RETURNS SETOF public.branchtemplate
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
--USE
select * from branchtemplate where type = _type and branchid = _branchid;
END;
$$;


--
-- Name: getbranchsalesexcelreport(uuid, timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchsalesexcelreport(_companyid uuid, _fromtime timestamp without time zone DEFAULT NULL::timestamp without time zone, _totime timestamp without time zone DEFAULT NULL::timestamp without time zone) RETURNS TABLE(branchname public.citext, orderscount integer, acceptedorderscount integer, declinedorderscount integer, acceptedordersubtotalvalue numeric, declinedordersubtotalvalue numeric, acceptedordervalue numeric, declinedordervalue numeric, deliveryorderscount integer, nondeliveryorderscount integer, deliveryorderstotal numeric, nondeliveryorderstotal numeric)
    LANGUAGE plpgsql
    AS $$

    BEGIN
    RETURN QUERY
        select
    b.name ,
    (select coalesce(count(*) ,0)::integer from "order" o where branchid = b.id and ((_fromtime is null) or( _fromtime <= o.createdat)) and ((_totime is null) or( _totime >= o.createdat))) as ordersCount,
    (select coalesce(count(*) ,0)::integer from "order" o where branchid = b.id and isdeclined !=true and ((_fromtime is null) or( _fromtime <= o.createdat)) and ((_totime is null) or( _totime >= o.createdat))) acceptedOrdersCount,
    (select coalesce(count(*) ,0)::integer from "order" o where branchid = b.id and isdeclined =true and ((_fromtime is null) or( _fromtime <= o.createdat)) and ((_totime is null) or( _totime >= o.createdat)))declinedOrdersCount,
    (select coalesce(sum((price->>'SubTotal')::numeric) ,0)::numeric from "order" o where branchid = b.id and isdeclined !=true and ((_fromtime is null) or( _fromtime <= o.createdat)) and ((_totime is null) or( _totime >= o.createdat))) as AcceptedSubTotalValue,
    (select coalesce(sum((price->>'SubTotal')::numeric) ,0)::numeric from "order" o where branchid = b.id and isdeclined =true and ((_fromtime is null) or( _fromtime <= o.createdat)) and ((_totime is null) or( _totime >= o.createdat))) as DeclinedSubTotalValue,
    (select coalesce(sum((price->>'Total')::numeric) ,0)::numeric from "order" o where branchid = b.id and isdeclined !=true and ((_fromtime is null) or( _fromtime <= o.createdat)) and ((_totime is null) or( _totime >= o.createdat))) as AcceptedTotalValue,
    (select coalesce(sum((price->>'Total')::numeric) ,0)::numeric from "order" o where branchid = b.id and isdeclined =true and ((_fromtime is null) or( _fromtime <= o.createdat)) and ((_totime is null) or( _totime >= o.createdat))) as DeclinedTotalValue,
    (select coalesce(count(*) ,0)::integer from "order" o where branchid = b.id and (select COUNT(deliverycompany.id)  from deliverycompany where deliverycompany.id = o.deliverytype)>0 and ((_fromtime is null) or( _fromtime <= o.createdat)) and ((_totime is null) or( _totime >= o.createdat))) DeliveryOrdersCount ,
    (select coalesce(count(*) ,0)::integer from "order" o where branchid = b.id and (select COUNT(deliverycompany.id)  from deliverycompany where deliverycompany.id = o.deliverytype) =0 and ((_fromtime is null) or( _fromtime <= o.createdat)) and ((_totime is null) or( _totime >= o.createdat))) NonDeliveryOrdersCount,
    (select coalesce(sum((price->>'Total')::numeric) ,0)::numeric from "order" o where branchid = b.id and (select COUNT(deliverycompany.id)  from deliverycompany where deliverycompany.id = o.deliverytype)>0 and ((_fromtime is null) or( _fromtime <= o.createdat)) and ((_totime is null) or( _totime >= o.createdat))) DeliveryOrdersTotalValue ,
    (select coalesce(sum((price->>'Total')::numeric) ,0)::numeric from "order" o where branchid = b.id and (select COUNT(deliverycompany.id)  from deliverycompany where deliverycompany.id = o.deliverytype) =0 and ((_fromtime is null) or( _fromtime <= o.createdat)) and ((_totime is null) or( _totime >= o.createdat))) NonDeliveryOrdersTotalValue
from branch b
where b.companyid = _companyid;
    END;
$$;


--
-- Name: getbranchtemplatebyid(uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchtemplatebyid(_id uuid, _type public.citext) RETURNS SETOF public.branchtemplate
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY

--use
 select * from branchtemplate where branchid=_id and type=_type and isdeleted = false ;
END;
$$;


--
-- Name: getbranchtemplateforpiad(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbranchtemplateforpiad(_id uuid) RETURNS TABLE(piad boolean)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select brt.paid from branchtemplate brt WHERE brt.branchid = _id and brt.type = 'Cashier' ;
END;
$$;


--
-- Name: getbrandsid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbrandsid(_companyid uuid) RETURNS TABLE(brandid public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN

    return query
select brandids.brandid
from (select distinct talabatbrandid as brandid from talabatcredential t
left join branch on branch.id = t.ishbekbranchid
where companyid =_companyid)as brandids;
END;
$$;


--
-- Name: getbrandsmenus(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getbrandsmenus(_companyid uuid) RETURNS TABLE(brandid public.citext, istaxable boolean, requestbody json)
    LANGUAGE plpgsql
    AS $$
BEGIN
return query

    select
        brandids.brandid,
        brandids.istaxable as istaxable,
        getrestaurntmenuwithbrandid(_companyid,brandids.brandid,brandids.istaxable)
    from (select distinct t.talabatbrandid as brandid, t.istaxable as istaxable from talabatcredential t left join branch on branch.id = t.ishbekbranchid where branch.companyid =_companyid ) as brandids;
END;
$$;


--
-- Name: getcallparentstatuses(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcallparentstatuses() RETURNS TABLE(id public.citext, name public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select status as id , status as name from callsubmission where parentstatus is null   ;
END
$$;


--
-- Name: getcallreport(uuid, timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcallreport(_id uuid, _from timestamp without time zone DEFAULT NULL::timestamp without time zone, _to timestamp without time zone DEFAULT NULL::timestamp without time zone) RETURNS TABLE(id uuid, status public.citext, substatus public.citext, notes public.citext, customerphone public.citext, createdat timestamp without time zone, createdby public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
return query
select cl.id , cl.status , cl.substatus , cl.notes,cl.customerphone, cl.createdat , cl.createdby from calllog cl
         where companyid = _id
            and ((_from is null) or (cl.createdat >= _from))
            and ((_to is null) or (cl.createdat <= _to));
END
$$;


--
-- Name: getcallsubstatuses(public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcallsubstatuses(_parentstatus public.citext) RETURNS TABLE(id public.citext, name public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select status as id , status as name from callsubmission where parentstatus = _parentstatus;
END
$$;


--
-- Name: getcatalog(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcatalog(_menuid uuid) RETURNS TABLE(catalog json)
    LANGUAGE plpgsql
    AS $$

BEGIN
RETURN query
 select json_build_object('id' ,menu.id , 'name', menu.name , 'category_ids',(select array_agg(categoryid)from menucategories join category c on c.id = menucategories.categoryid where menucategories.menuid = menu.id and c.isdeleted = false  ) )
   from menu
where menu.id = _menuid and menu.isdeleted = false;
END;
$$;


--
-- Name: getcatalog_careem(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcatalog_careem(_branchid uuid) RETURNS TABLE(catalog json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN query
 select json_build_object('id' ,menu.id , 'name', menu.name , 'category_ids',(select array_agg(categoryid)from menucategories join category c on c.id = menucategories.categoryid where menucategories.menuid = menu.id and c.isdeleted = false  ) ) from branch
inner join menu on ( menu.id = (select menu.id from menu where menu.id = any(select mch.menuid from menuchannel mch where mch.branchid = _branchid and mch.channelid =(select nlp.id from namelookup nlp where nlp.name ='careem')) and menu.isdeleted = false) )
where branch.id = _branchid and menu.isdeleted = false;
--branch.menuid = menu.id or
END;
$$;


--
-- Name: getcatalogforcareemdto(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcatalogforcareemdto(_branchid uuid) RETURNS TABLE(catalog json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN query
 select json_build_object('id' ,menu.id , 'name', menu.name , 'category_ids',(select array_agg(categoryid)from menucategories join category c on c.id = menucategories.categoryid where menucategories.menuid = menu.id and c.isdeleted = false  ) ) from branch
inner join menu on ( menu.id = (select menu.id from menu where menu.id = any(select mch.menuid from menuchannel mch where mch.branchid = _branchid and mch.channelid =(select nlp.id from namelookup nlp where nlp.name ='callcenter')) and menu.isdeleted = false) )
where branch.id = _branchid and menu.isdeleted = false;
--branch.menuid = menu.id or
END;
$$;


--
-- Name: getcategories(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcategories(_menuid uuid) RETURNS TABLE(categories json)
    LANGUAGE plpgsql
    AS $$

BEGIN
RETURN query
 select to_json(array(select to_json(json_build_object('id',c.id ,'deleted', c.isdeleted ,'name',(case when (c.name->>'ar' is not null )then c.name->>'ar' else (case when (c.name->>'en' is not null) THEN c.name->>'en' ELSE '' END )   end ),
													   'name_localized',
													   case when (c.name->>'ar' is null and c.name->>'en' is null) then json_build_object('en',''   ,   'ar','')::jsonb
		 													when (c.name->>'ar' is not null and c.name->>'en' is null) then json_build_object('en','','ar',c.name->>'ar')::jsonb
		 													when (c.name->>'ar' is null and c.name->>'en' is not null) then json_build_object('en',c.name->>'en', 'ar','')::jsonb
		 													when (c.name->>'ar' is not null and c.name->>'en' is not null) then c.name :: jsonb
														end,
													   'description','',
													   'description_localized',json_build_object('en','','ar',''),
													   'priority', displaynumber, 'items',
     (select array_agg(product.id) from product where product.categoryid =c.id and product.isdeleted = false  and product.id in (select productid from menuproduct where menuproduct.menuid = _menuid)))
)from menucategories
inner join category c on c.id = menucategories.categoryid
where menucategories.menuid = _menuid and c.isdeleted = false
     order by c.displaynumber
     ));

END;
$$;


--
-- Name: getcategories_careem(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcategories_careem(_menuid uuid) RETURNS TABLE(categories json)
    LANGUAGE plpgsql
    AS $$

BEGIN
RETURN query
 select to_json(array(select to_json(json_build_object('id',c.id ,'deleted', c.isdeleted ,'name',(case when (c.name->>'ar' is not null )then c.name->>'ar' else (case when (c.name->>'en' is not null) THEN c.name->>'en' ELSE '' END )   end ),
													   'name_localized',
													   case when (c.name->>'ar' is null and c.name->>'en' is null) then json_build_object('en',''   ,   'ar','')::jsonb
		 													when (c.name->>'ar' is not null and c.name->>'en' is null) then json_build_object('en','','ar',c.name->>'ar')::jsonb
		 													when (c.name->>'ar' is null and c.name->>'en' is not null) then json_build_object('en',c.name->>'en', 'ar','')::jsonb
		 													when (c.name->>'ar' is not null and c.name->>'en' is not null) then c.name :: jsonb
														end,
													   'description','',
													   'description_localized',json_build_object('en','','ar',''),
													   'priority', displaynumber, 'items',
     (select array_agg(product.id) from product where product.categoryid =c.id and product.isdeleted = false  and product.id in (select productid from menuproduct where menuproduct.menuid = _menuid)))
)from menucategories
inner join category c on c.id = menucategories.categoryid
where menucategories.menuid = _menuid and c.isdeleted = false
     order by c.displaynumber
     ))
;

--call createattributemapd(_menuid);


END;
$$;


--
-- Name: getcategoriesforcareemdto(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcategoriesforcareemdto(_menuid uuid) RETURNS TABLE(categories json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN query
 select to_json(array(select to_json(json_build_object('id',c.id ,'deleted', c.isdeleted ,'name',(case when (c.name->>'ar' is not null )then c.name->>'ar' else (case when (c.name->>'en' is not null) THEN c.name->>'en' ELSE '' END )   end ),
													   'name_localized',
													   case when (c.name->>'ar' is null and c.name->>'en' is null) then json_build_object('en',''   ,   'ar','')::jsonb
		 													when (c.name->>'ar' is not null and c.name->>'en' is null) then json_build_object('en','','ar',c.name->>'ar')::jsonb
		 													when (c.name->>'ar' is null and c.name->>'en' is not null) then json_build_object('en',c.name->>'en', 'ar','')::jsonb
		 													when (c.name->>'ar' is not null and c.name->>'en' is not null) then c.name :: jsonb
														end,
													   'description','',
													   'description_localized',json_build_object('en','','ar',''),
													   'priority', displaynumber, 'items',
     (select array_agg(product.id) from product where product.categoryid =c.id and product.isdeleted = false  and product.id in (select productid from menuproduct where menuproduct.menuid = _menuid)))
)from menucategories
inner join category c on c.id = menucategories.categoryid
where menucategories.menuid = _menuid and c.isdeleted = false
     order by c.displaynumber
     ))
;

--call createattributemapd(_menuid);

END;
$$;


--
-- Name: getcategoriesname(uuid[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcategoriesname(_ids uuid[] DEFAULT NULL::uuid[]) RETURNS TABLE(categories json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select to_json(Array(select to_json( json_build_object('id' , c.id , 'name' , 
c.name))from category c where c.id = any(_ids)));
END;
$$;


--
-- Name: getcategory(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcategory(_id uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, name jsonb, image public.citext, children json, createdat timestamp without time zone, createdby public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select c.id , c.name, c.image,  
to_json( Array( select to_json(json_build_object(
'id' , cc.id,
'name',cc.name,
'image' , cc.image,
'createdat' , cc.createdat,
'createdby' , cc.createdby
))	from category cc where cc.parentcategoryid = c.id and cc.isdeleted = false and cc.ispublished = true 
)), c.createdat,c.createdby from category c where c.id = _id and isdeleted = false and ispublished = true;
END;
$$;


--
-- Name: getcategoryavailableitemsfrommenu(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcategoryavailableitemsfrommenu(_categoryid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, name jsonb, image public.citext, description jsonb, shortdescription jsonb, price jsonb, displaynumber integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select distinct product.id , product.name , concat(getimagepath(product.imagepath),product.imagepath)::citext as image , product.fulldescription , product.shortdescription , product.price,product.displaynumber
from branch 
left join menu on branch.menuid = menu.id 
left join menuproduct on menu.id = menuproduct.menuid 
left join product on product.id = menuproduct.productid 
where product.isdeleted = false and product.ispublished = true and product.isavailable = true and product.id not in (select distinct unnest(productids) from productavailability where isavailable = false) 
and product.categoryid = _categoryid and product.id is not null order by product.displaynumber ASC;
END;
$$;


--
-- Name: getcategoryavailableitemsfrommenu(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcategoryavailableitemsfrommenu(_categoryid uuid DEFAULT NULL::uuid, _branchid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, name jsonb, image public.citext, description jsonb, shortdescription jsonb, price jsonb, displaynumber integer, discountinfo jsonb)
    LANGUAGE plpgsql
    AS $$

BEGIN
RETURN QUERY
select product.id , product.name , concat(getimagepath(product.imagepath),product.imagepath)::citext as image , product.fulldescription , product.shortdescription , product.price,product.displaynumber,
                (select to_json( array(select row_to_json(getnowdiscountsforproducts(_productid := product.id, _branchid := _branchid, _channelid := (select nlk.id from namelookup nlk where nlk.name ='callcenter'))))))::jsonb

from branch
left join menu on  menu.id = (select menu.id from menu where menu.id = any(select mch.menuid from menuchannel mch where mch.branchid = branch.id and mch.channelid =(select nlk.id from namelookup nlk where nlk.name ='callcenter')) and menu.isdeleted = false)
left join menuproduct on menu.id = menuproduct.menuid
left join product on product.id = menuproduct.productid
where branch.id = _branchid and product.isdeleted = false and product.ispublished = true and product.isavailable = true
and product.id not in (select objectid from branchavailability where branchid =_branchid)
and product.categoryid = _categoryid and product.id is not null
order by product.displaynumber ASC;
END;
$$;


--
-- Name: getcategoryavailableitemsfrommenu1(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcategoryavailableitemsfrommenu1(_categoryid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, name jsonb, image public.citext, description jsonb, shortdescription jsonb, price jsonb, displaynumber integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select distinct product.id , product.name , product.imagepath as image , product.fulldescription , product.shortdescription , product.price,product.displaynumber
from branch 
left join menu on branch.menuid = menu.id 
left join menuproduct on menu.id = menuproduct.menuid 
left join product on product.id = menuproduct.productid 
where product.isdeleted = false and product.ispublished = true and product.isavailable = true and product.id not in (select distinct unnest(productids) from productavailability where isavailable = false) 
and product.categoryid = _categoryid and product.id is not null order by product.displaynumber ASC;
END;
$$;


--
-- Name: getcategoryavailableitemsfrommenu6(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcategoryavailableitemsfrommenu6(_categoryid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, name jsonb, image public.citext, description jsonb, shortdescription jsonb, price jsonb, displaynumber integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select distinct product.id , product.name , product.imagepath as image , product.fulldescription , product.shortdescription , product.price,product.displaynumber
from branch 
left join menu on branch.menuid = menu.id 
left join menuproduct on menu.id = menuproduct.menuid 
left join product on product.id = menuproduct.productid 
where product.isdeleted = false and product.ispublished = true and product.isavailable = true and product.id not in (select distinct unnest(productids) from productavailability where isavailable = false) 
and product.categoryid = _categoryid and product.id is not null order by product.displaynumber ASC;
END;
$$;


--
-- Name: getcategoryavailableitemsfrommenuforagent(uuid, uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcategoryavailableitemsfrommenuforagent(_categoryid uuid DEFAULT NULL::uuid, _branchid uuid DEFAULT NULL::uuid, _channelid public.citext DEFAULT NULL::public.citext) RETURNS TABLE(id uuid, name jsonb, image public.citext, thumbimage public.citext, description jsonb, shortdescription jsonb, price jsonb, displaynumber integer, discountinfo jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select product.id , product.name , concat(getimagepath(product.imagepath),product.imagepath)::citext as image ,  concat(getimagepath(product.thumbimage),product.thumbimage)::citext as thumbimage , product.fulldescription , product.shortdescription , product.price,product.displaynumber,
                (select to_json( array(select row_to_json(getnowdiscountsforproducts(_productid := product.id, _branchid := _branchid, _channelid := (select nlk.id from namelookup nlk where nlk.name =_channelid))))))::jsonb

from branch
left join menu on  menu.id = (select menu.id from menu where menu.id = any(select mch.menuid from menuchannel mch where mch.branchid = branch.id and mch.channelid =(select nlp.id from namelookup nlp where nlp.name =_channelid)) and menu.isdeleted = false)
left join menuproduct on menu.id = menuproduct.menuid
left join product on product.id = menuproduct.productid
where branch.id = _branchid and product.isdeleted = false and product.ispublished = true and product.isavailable = true
and product.id not in (select bav.objectid from branchavailability bav where bav.branchid =_branchid and bav.channelid = (select  clk.id from public.channellookup clk where clk.name = _channelid))
and product.categoryid = _categoryid and product.id is not null
order by product.displaynumber ASC;
END;
$$;


--
-- Name: getcategoryavailableitemsfrommenunew(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcategoryavailableitemsfrommenunew(_categoryid uuid DEFAULT NULL::uuid, _branchid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, name jsonb, image public.citext, description jsonb, shortdescription jsonb, price jsonb, displaynumber integer, discountinfo jsonb, preptimemin integer, preptimehour integer, isavailable boolean)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select product.id , product.name ,CONCAT(getimagepathurl(product.imagepath),product.imagepath)::citext , product.fulldescription , product.shortdescription , product.price,product.displaynumber,
                (select to_json( array(select row_to_json(getnowdiscountsforproducts(_productid := product.id, _branchid := _branchid, _channelid := (select nlk.id from namelookup nlk where nlk.name ='MobileApp'))))))::jsonb,
                product.min,product.hour,product.isavailable

from branch
left join menu on branch.menuid = menu.id
left join menuproduct on menu.id = menuproduct.menuid
left join product on product.id = menuproduct.productid
where branch.id = _branchid and product.isdeleted = false and product.ispublished = true and product.isavailable = true and product.id not in (select distinct unnest(productids) from productavailability where productavailability.isavailable = false and productavailability.isdeleted = false and productavailability.ispublished = true)
and product.categoryid = _categoryid and product.id is not null order by product.displaynumber ASC;
END;
$$;


--
-- Name: getcategorybyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcategorybyid(_id uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, name public.citext, createdat timestamp without time zone, createdby public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select category.id, category.name,category.createdat, category.createdby 
 from category where category.id = _id and isdeleted = false and ispublished = true;
END;
$$;


--
-- Name: getcategorybymenuid(uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcategorybymenuid(_id uuid, _languagecode public.citext DEFAULT 'en'::public.citext) RETURNS TABLE(id uuid, name jsonb, branches jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select cat.id, cat.name,
(select to_json( array(select row_to_json(getbranchforcategorybymenuid(_id := _id,_callid := cat.id)))))::jsonb

from category cat inner join menucategories mcat on mcat.categoryid = cat.id
where mcat.menuid = _id and cat.isdeleted = false and cat.ispublished = true;
END;
$$;


--
-- Name: getcategorybymenuidishbekinterface(uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcategorybymenuidishbekinterface(_id uuid, _channel public.citext) RETURNS TABLE(id uuid, name jsonb, external_pos_id public.citext, branches uuid[], products uuid[])
    LANGUAGE plpgsql
    AS $$

BEGIN
RETURN QUERY
select cat.id, cat.name,cat.external_pos_id,
ARRAY(select getbranchavailabilitybycatgeory(_id := _id,_callid := cat.id,_channel := _channel))
--(select to_json( array(select row_to_json(getbranchforcategorybymenuidandchannel(_id := _id,_callid := cat.id,_channel := _channel)))))::jsonb
,ARRAY(select pro.id from product pro where pro.categoryid = cat.id) 
from category cat inner join menucategories mcat on mcat.categoryid = cat.id
where mcat.menuid = _id and cat.isdeleted = false and cat.ispublished = true;
END;
$$;


--
-- Name: getcategorycustomer(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcategorycustomer() RETURNS TABLE(id integer, text public.citext)
    LANGUAGE plpgsql
    AS $$

BEGIN
RETURN QUERY
select lk.id::integer,lk.name from lookup lk;
END;
$$;


--
-- Name: getcategoryname(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcategoryname(_id uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, name jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select c.id ,c.name from category c where c.id = _id;
END;
$$;


--
-- Name: getcategoryproducts(uuid[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcategoryproducts(_categoryids uuid[] DEFAULT NULL::uuid[]) RETURNS TABLE(id uuid)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select product.id as productid from product where product.categoryid = ANY(_categoryids) and isavailable = true and isdeleted = false and ispublished = true;
END;
$$;


--
-- Name: getcategorytag(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcategorytag() RETURNS TABLE(id uuid, name public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select namelookup.id,namelookup.name from namelookup where tabletype = 'categoryTag';

END;
$$;


--
-- Name: getchannelbyname(public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getchannelbyname(_channel public.citext) RETURNS TABLE(channelid uuid)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
   SELECT nlm.id FROM namelookup nlm  where  nlm.name = _channel and nlm.isdeleted = false and tabletype = 'ordersource';
END;
$$;


--
-- Name: getchannelchart(uuid[], uuid[], timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getchannelchart(_branchids uuid[], _channels uuid[] DEFAULT NULL::uuid[], _from timestamp without time zone DEFAULT NULL::timestamp without time zone, _to timestamp without time zone DEFAULT NULL::timestamp without time zone) RETURNS TABLE(data json)
    LANGUAGE plpgsql
    AS $$
BEGIN
return query 
select to_json(array(select to_json(json_build_object('Channel',"order".ordersource,'name',(select name from namelookup where namelookup.id = "order".ordersource),'totalprice',sum(coalesce(nullif("order".totalprice,0),("order".price->>'FinalPrice')::numeric -  ("order".price->>'DeliveryPrice')::numeric)))) from "order"
where "order".branchid  = any(_branchids) 
and ((_channels is null) or ("order".ordersource=any(_channels)))
and ((_from is null) or ("order".createdat >=  to_char(_from,'YYYY-MM-DD 00:00:00')::timestamp))
and ((_to is null) or ("order".createdat <= to_char(_to,'YYYY-MM-DD 23:59:59')::timestamp))					 
group by "order".ordersource));
END
$$;


--
-- Name: getchannelmenucategory(uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getchannelmenucategory(_branchid uuid DEFAULT NULL::uuid, _channel public.citext DEFAULT NULL::public.citext) RETURNS TABLE(id uuid, name jsonb, image public.citext, displaynumber integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select cat.id , cat.name as name , CONCAT(getimagepath(),cat.image)::citext , cat.displaynumber
from branch 
left join menu on menu.id = (select menu.id from menu where menu.id = any(select mch.menuid from menuchannel mch where mch.branchid = branch.id and mch.channelid =(select nlp.id from namelookup nlp where nlp.name =_channel)) and menu.isdeleted = false)
left join menucategories mc on mc.menuid = menu.id
left join category cat on cat.id = mc.categoryid
where branch.id = _branchid and menu.isdeleted = false
and menu.isavailable = true and menu.ispublished = true 
and (cat.id != any(select objectid FROM branchavailability WHERE branchid =_branchid )
     or (select objectid FROM branchavailability WHERE branchid =_branchid ) is null)
order by cat.displaynumber;
END;
$$;


--
-- Name: getchannelmenuviews(uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getchannelmenuviews(_companyid uuid DEFAULT NULL::uuid, _channel public.citext DEFAULT NULL::public.citext) RETURNS TABLE(id uuid, name public.citext, isavailable boolean, branch uuid[], channel json, product json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select mn.id,mn.name,mn.isavailable,
ARRAY(select br.id 
      from branch br
      inner join menuchannel mch on mch.branchid = br.id
      where (br.menuid = mn.id or mch.menuid = mn.id) 
      and mn.isdeleted = false 
      and mn.ispublished = true
     )branches,
        
--to_json( Array( select to_json(json_build_object('id' ,
    --(CASE WHEN br.id IS NULL THEN mch.branchid ELSE br.id END)
    --,'name',
    --(CASE WHEN br.id IS NULL THEN (select br1.name from branch br1 where br1.id = mch.branchid) ELSE br.name END)
   -- ,'location' ,
    --(CASE WHEN br.id IS NULL THEN (select br1.addressname from branch br1 where br1.id = mch.branchid)  ELSE br.addressname END)
   -- ))
   --             from branch br
   --                 left join menuchannel mch on mch.branchid = br.id
	--	where (br.menuid = mn.id or mch.menuid = mn.id) and mn.isdeleted = false and mn.ispublished = true GROUP BY br.id,mch.branchid )) branches,

        to_json( Array( select to_json(json_build_object('id' , mch.channelid ,'name', nlk.name,'issync',(select mis.issync from menuintegratiosync mis where mis.channelid = mch.channelid and mis.menuid = mn.id ) )) from menuchannel mch left join namelookup nlk on nlk.id = mch.channelid
		where mch.menuid = mn.id and mn.isdeleted = false and mn.ispublished = true and nlk.isdeleted = false and nlk.ispublished=true group by mch.channelid,nlk.name )) channel,
		to_json( Array( select to_json(json_build_object('id' , product.id,'name', product.name,'isavailable' , product.ispublished,'image' , concat(getimagepath(product.imagepath),product.imagepath)::citext))	from product product
		where product.id in (select productid from menuproduct where menuid = mn.id) and product.isdeleted = false  )) products
		from menu mn
		where mn.id = any(select menu.id from menu where menu.id = any(select mch.menuid from menuchannel mch where mch.branchid = any( select b.id from branch b where b.companyid = _companyid) and mch.channelid =(select nlp.id from namelookup nlp where nlp.name =_channel)) and menu.isdeleted = false) and mn.companyid = _companyid and mn.isdeleted = false and mn.ispublished = true;
		END;
$$;


--
-- Name: getchannelorderview(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getchannelorderview(_orderid uuid) RETURNS TABLE(id uuid, branchorderid public.citext, price jsonb, currentstatus public.citext, ordersource uuid, ordersourcename public.citext, deliveryname public.citext, scheduled timestamp without time zone, deliverytype uuid, customerid uuid, branchid uuid, notes public.citext, numberofpeople public.citext, totalprice numeric, deliveryprice numeric, deliveryaddress uuid, subtotalprice numeric, referencenumber public.citext, totalpreparingtime public.citext, deliverystatus public.citext, paymenttype public.citext, createdat timestamp without time zone, createdby public.citext, branchname public.citext, customername public.citext, customerdateofbirth date, customerphoneno public.citext, customerphoneno2 public.citext, customeremail public.citext, customerimage public.citext, customerchannel uuid, customerloyalitypoints numeric, customerfb public.citext, customertwitter public.citext, customerinstagram public.citext, customerlastorderdate date, customerisblocked boolean, customernotes public.citext, customercreatedat timestamp without time zone, customercreatedby public.citext, products json, address json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select
    ord.id,
    ord.branchorderid,
    ord.price,
    getorderstatus(ord.currentstatus),
    ord.ordersource,
	getlookupname(ord.ordersource),
	case when (ord.deliverytype = 'ebf23c72-7003-4804-b981-727ef616e1d5')
	    then (select getlocaldeliveryname(ord.branchid))
	    else (Select getdeliverycompanyname(ord.deliverytype))
        end,
	ord.scheduled,
    ord.deliverytype,
    ord.customerid,
    ord.branchid,
    ord.notes,
	ord.numberofpeople,
    ord.totalprice,
    ord.deliveryprice,
    ord.deliveryaddress,
    ord.subtotalprice,
    ord.referencenumber2,
    ord.totalpreparingtime,
    ord.deliverystatus,
    ord.paymenttype,
    ord.createdat,
    ord.createdby,
	getbranchname(ord.branchid),
    customer.name,
    customer.dateofbirth,
    customer.phoneno,
    customer.phoneno2,
    customer.email,
    customer.image,
    customer.channel,
    customer.loyalitypoints,
    customer.fb,
    customer.twitter,
    customer.instagram,
    customer.lastorderdate,
    customer.isblocked,
    customer.notes,
    customer.createdat,
    customer.createdby,
    to_json(
        Array(
            select
                to_json(
                    json_build_object(
                        'id',
                        ordpr.id,
                        'orderid',
                        ordpr.orderid,
                        'productid',
                        ordpr.productid,
                        'productname',
                        prd.name,
                        'img',
                        prd.imagepath,
						'count',
						ordpr.itemcount,
						'createdat',
						prd.createdat,
						'createdby',
						prd.createdby,
                        'price',
                        ordpr.price,
                        'attributes',
                        to_json(
                            Array(
                                select
                                    to_json(
                                        json_build_object(
                                            'id',
                                            ordpratt.id,
                                            'orderproductid',
                                            ordpratt.orderproductid,
                                            'attributeid',
                                            ordpratt.attributeid,
                                            'attributename',
                                             prdatt.name,
                                            'pricesubtotal',
                                            ordpratt.pricesubtotal,
                                            'pricetaxvalue',
                                            ordpratt.pricetaxvalue,
                                            'pricetaxpercentage',
                                            ordpratt.pricetaxpercentage,
											'values',(ordpratt.children)::json,
                                            'notes',
                                            ordpratt.notes,
											'createdat',
											ordpratt.createdat,
											'createdby',
											ordpratt.createdby
                                        )
                                    )
                                from
                                    orderproductattribute ordpratt
                                    left join productattribute prdatt on ordpratt.attributeid = prdatt.id
								where ordpratt.orderproductid = ordpr.id
                            )
                        ),
                        'pricesubtotal',
                        ordpr.pricesubtotal,
                        'pricetaxvalue',
                        ordpr.pricetaxvalue,
                        'pricetaxpercentage',
                        ordpr.pricetaxpercentage,
                        'notes',
                        ordpr.notes
                    )
                )
            from
                orderproduct ordpr
                inner join product prd on ordpr.productid = prd.id
			where ordpr.orderid = ord.id
        )
    ) products,
    (select 
     to_json(
         json_build_object( 
             'id', addr.addressid,
             'name', json_build_object('en', addr.name, 'ar' , addr.name),
             'details', addr.details,
             'latitude', addr.latitude, 
             'longtitude', addr.longtitude,
             'buildingno', addr.buildingno, 
             'streetno', addr.streetname ))
     from customeraddress addr where addr.addressid = ord.deliveryaddress)
from
    "order" ord
    left join customer on ord.customerid = customer.id
where
    ord.id = _orderid;
END;
$$;


--
-- Name: getchannelproductishbekidbyposid(public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getchannelproductishbekidbyposid(_id public.citext) RETURNS TABLE(id uuid)
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN QUERY 
   select pro.id from product pro where pro.external_pos_id = _id;

END;
$$;


--
-- Name: getchannelproductname(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getchannelproductname(_id uuid) RETURNS TABLE(name jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN QUERY 
   select pro.name from product pro where pro.id = _id;

END;
$$;


--
-- Name: getchannelsfordiscount(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getchannelsfordiscount() RETURNS TABLE(id uuid, name public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select distinct(nlk.id),nlk.name from namelookup nlk where tabletype = 'ordersource' and isdeleted = false and ispublished=true;
END
$$;


--
-- Name: getchannelsformenu(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getchannelsformenu(_companyid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, name public.citext, integration boolean)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select nlk.id,nlk.name,true from namelookup nlk INNER JOIN companyactiveintegrations cai on cai.channelid = nlk.id
  where nlk.tabletype = 'ordersource' and nlk.isdeleted = false and nlk.ispublished=true and cai.isactive = true GROUP BY nlk.id
 UNION
 SELECT nlk1.id,nlk1.name,false FROM namelookup nlk1 where nlk1.name = 'callcenter'
 UNION
 SELECT nlk1.id,nlk1.name,false FROM namelookup nlk1 where nlk1.name = 'OnlineOrdering'
 UNION
 SELECT nlk1.id,nlk1.name,false FROM namelookup nlk1 where nlk1.name = 'Chatbot'
 UNION
 SELECT nlk1.id,nlk1.name,false FROM namelookup nlk1 where nlk1.name = 'mobile';
END
$$;


--
-- Name: getchanneltopsellingitem(uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getchanneltopsellingitem(_companyid uuid, _channel public.citext) RETURNS TABLE(id uuid, categoryid uuid, imagepath public.citext, createdat timestamp without time zone, price jsonb, description jsonb, name jsonb, shortdescription jsonb, sku public.citext, fulldescription jsonb, isavailable boolean, producttags jsonb, istopselling boolean)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    select p.id,p.categoryid,CONCAT(getimagepathurl(p.imagepath),p.imagepath)::citext,p.createdat,p.price,p.description,p.name,
    p.shortdescription,p.sku,p.fulldescription,p.isavailable,p.producttags,p.istopselling
    from product p 
    WHERE p.id = any(select mp.productid from menuproduct mp 
                     INNER JOIN menu m ON m.id = mp.menuid 
                     WHERE m.id = (select distinct(mch.menuid)  from menuchannel mch inner join menu m1 on m1.id = mch.menuid where m1.companyid = _companyid and mch.channelid = (select nlp.id from namelookup nlp where nlp.name =_channel))
                     and m.companyid =_companyid and m.isdeleted = false and m.ispublished = true )
    and p.isdeleted = false and p.isavailable = true and p.istopselling = true order by p.createdat desc ;
END;
$$;


--
-- Name: getcheckauthcustomer(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcheckauthcustomer(_id uuid, _companyid uuid) RETURNS TABLE(id uuid)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select "customer".id from customer 
left join restaurantcustomer rc on rc.customerid = "customer".id 
WHERE rc.isactive = true and "customer".id=_id and rc.restaurantid =_companyid AND "customer".isdeleted = false AND "customer".ispublished = true ;
END; 
$$;


--
-- Name: getcities(public.citext, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcities(_languagecode public.citext, pagenumber integer DEFAULT NULL::integer, pagesize integer DEFAULT NULL::integer) RETURNS TABLE(id uuid, name public.citext, countryid uuid, countryname public.citext, createdat timestamp without time zone, createdby public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select  
city.id, getlocalizationvalue(_languagecode , 'cityName' ,city.id , 1) as "cityName",
city.countryid ,getlocalizationvalue(_languagecode , 'countryName' ,city.countryid , 1) as "countryName",  city.createdat, city.createdby 
from city where isdeleted = false and ispublished = true and 
(select result from getlocalizationvalue(_languagecode , 'cityName' ,city.id , 1)  )is not null and 
(select result from getlocalizationvalue(_languagecode , 'countryName' ,city.countryid , 1)) is not null 

LIMIT pagesize
OFFSET ((pagenumber-1) * pagesize);

END;
$$;


--
-- Name: getcitiesandareasexceltemplatedata(integer, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcitiesandareasexceltemplatedata(_cityid integer, _companyid uuid) RETURNS TABLE(cityname public.citext, cityid integer, areaname public.citext, areaid bigint, subareaname public.citext, areacodeid integer, id uuid)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
        select
        ic.name_en as "CityName",
        ic.cityid as "CityId",
        ia.name as "AreaName",
        ia.areaid as "AreaId",
        csa.name as "SubAreaName",
        csa.areacode as "AreaCodeId",
        csa.id as "Id"
    from ishbekcities ic
        left join ishbekareas ia on ia.cityid = ic.cityid
        left join companysubarea csa on csa.areaid = ia.areaid and csa.companyid = _companyid
    where ic.cityid = _cityid and ic.ispublished = true and ia.ispublished = true ORDER BY csa.areacode asc ;
END;
$$;


--
-- Name: getclientintegrationbycompanyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getclientintegrationbycompanyid(_id uuid DEFAULT NULL::uuid) RETURNS TABLE(companyid uuid, companyname public.citext, intcompanyid uuid, intcompanyname public.citext, createdat timestamp without time zone, createdby public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select ci.companyid, c.name, ci.intcompanyid, ci.name, ci.createdat, ci.createdby from clientintegration ci
 inner join company c on ci.intcompanyid = c.id
 where ci.companyid = _id and ci.isdeleted = false and ci.ispublished = true;
END;
$$;


--
-- Name: getclientintegrationbyintcompanyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getclientintegrationbyintcompanyid(_id uuid DEFAULT NULL::uuid) RETURNS TABLE(companyid uuid, companyname public.citext, intcompanyid uuid, intcompanyname public.citext, createdat timestamp without time zone, createdby public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select ci.companyid, c.name, ci.intcompanyid, ci.name, ci.createdat, ci.createdby from clientintegration ci
 inner join company c on ci.intcompanyid = c.id
 where ci.intcompanyid = _id and ci.isdeleted = false and ci.ispublished = true;
END;
$$;


--
-- Name: company; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.company (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    name public.citext NOT NULL,
    logo character varying,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext,
    selectedlanguage public.citext DEFAULT 'en'::public.citext NOT NULL
);


--
-- Name: getcompanies(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanies(pagenumber integer DEFAULT NULL::integer, pagesize integer DEFAULT NULL::integer) RETURNS SETOF public.company
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select * from company
where ((select count(orderstatuspossibilities.id) from orderstatuspossibilities where companyid = company.id ) >0);
END;
$$;


--
-- Name: getcompanies_ai(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanies_ai() RETURNS TABLE(id uuid, name public.citext, phone public.citext, branchesjson json)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    select c.id , c.name , ci.value::citext , (
    select to_json(array( select to_json(json_build_object(
        'id',b.id,
        'name',b.name,
        'opentime', b.opentime,
        'closetime', b.closetime,
        'latitude',b.latitude,
        'longitude',b.longtitude,
        'isactive',case when(b.status) = 1 then true else false end
        )
    ) from branch b where b.companyid= c.id and b.isdeleted =false
        )) )From companyactiveintegrations cai
         join company c on cai.companyid = c.id
         left join companyinfo ci on ci.companyid = c.id and ci.type = 'phone' 
         where cai.channelid = '79401a8a-0d53-4988-a08d-31d1b3514919'; -- chatbot source
END;
$$;


--
-- Name: getcompaniesbasedondeliverycompanyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompaniesbasedondeliverycompanyid(delivery_company_id uuid DEFAULT NULL::uuid) RETURNS TABLE(companyid uuid, companyname public.citext, branchname public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        company.id AS companyid,
        company.name AS companyname,
        branch.name AS branchname
    FROM
        deliverycompany
    JOIN
        public.branchdelivery ON deliverycompany.id = branchdelivery.deliverycompanyid
    JOIN
        public.branch ON branchdelivery.branchid = branch.id
    JOIN
        public.company ON branch.companyid = company.id
    WHERE
        deliverycompany.id = delivery_company_id
    ORDER BY
        company.name;
END;
$$;


--
-- Name: getcompaniesbranchs(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompaniesbranchs() RETURNS TABLE(id uuid, name public.citext, logo character varying, ispublished boolean, branchs bigint)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select  "company".id,"company".name,"company".logo,"company".ispublished,COUNT("branch".id) as branchs
from company
left join branch on branch.companyid = company.id 
where branch.isdeleted = false and branch.ispublished = true
--and ((select count(orderstatuspossibilities.id) from orderstatuspossibilities where companyid = company.id ) >0)
and company.isdeleted = false
GROUP BY "company".id;
END;
$$;


--
-- Name: getcompaniesinfo(public.citext, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompaniesinfo(_languagecode public.citext DEFAULT 'en'::public.citext, _pagenumber integer DEFAULT NULL::integer, _pagesize integer DEFAULT NULL::integer) RETURNS TABLE(id uuid, companyid uuid, type integer, value public.citext, createdby public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select companyinfo.id , companyinfo.companyid , companyinfo.type, getvalue(_languagecode, 'companyInfo' ,companyinfo.id , 1),companyinfo.createdby
 from companyinfo where isdeleted = false and ispublished = true
LIMIT _pagesize
OFFSET ((_pagenumber-1) * _pagesize);
END;
$$;


--
-- Name: getcompanyaddress(public.citext, uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanyaddress(keyword public.citext, cityid uuid, _companyid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, name public.citext, price numeric, minprice numeric)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY

select distinct address.id, concat( case when (cityar.value  is not null) then cityar.value else cityen.value end ,' - ',area.value,' - ',subarea.value)::citext as name ,branchdeliveryaddress.maxdeliverycost as price ,branchdeliveryaddress.mindeliverycost minprice  from address 
inner join branchaddress on branchaddress.addressid = address.id
inner join(
        SELECT distinct addressid , MAX(deliverycost) maxdeliverycost , min(deliverycost) mindeliverycost 
        FROM branchdeliveryaddress
	inner join branchaddress on branchdeliveryaddress.branchaddress = branchaddress.id
        GROUP BY (addressid)
    )AS branchdeliveryaddress on branchdeliveryaddress.addressid = branchaddress.addressid
inner join branch on branch.id = branchaddress.branchid 
left join languageresourcee cityen on (address.cityname = cityen.objectid and cityen.languagecode = 'en')
left join languageresourcee cityar on (address.cityname = cityar.objectid and cityar.languagecode = 'ar')
--left join languageresourcee city on address.cityname = city.objectid
left join languageresourcee area on address.areaname = area.objectid
left join languageresourcee subarea on address.subareaname = subarea.objectid
where 
(( keyword is null ) or 
((subarea.value) like  concat('%', (keyword) , '%')) or
((area.value) like  concat('%', (keyword) , '%')) or
((cityar.value) like  concat('%', (keyword) , '%'))or
((cityen.value) like  concat('%', (keyword) , '%')))
and address.cityname = cityid and area.value is not null and subarea.value is not null and branch.companyid = _companyid;
END;
$$;


--
-- Name: getcompanybycategoryid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanybycategoryid(_id uuid) RETURNS TABLE(id uuid)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select category.companyid from category where category.id = _id and category.isdeleted = false and category.ispublished = true;
END;
$$;


--
-- Name: getcompanybyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanybyid(_id uuid DEFAULT NULL::uuid) RETURNS SETOF public.company
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select * from company where id = _id and isdeleted = false and ispublished = true;
END;
$$;


--
-- Name: getcompanybyphone_ai(public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanybyphone_ai(_phone public.citext) RETURNS TABLE(id uuid)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
(select companyid from companyinfo where type = 'phone' and value like(concat('%',_phone,'%')) order by createdat desc limit 1);
END;
$$;


--
-- Name: getcompanycategories(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanycategories(_companyid uuid) RETURNS TABLE(id uuid, displaynumber integer, name jsonb, image public.citext, parentcategoryid uuid, createdat timestamp without time zone, categorytagid uuid, categorytagname public.citext, createdby public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select category.id, category.displaynumber,
category.name, category.image, category.parentcategoryid , category.createdat, category.categorytag,(select namelookup.name from namelookup where namelookup.id = category.categorytag) ,category.createdby 
from category where category.companyid = _companyid and category.isdeleted = false and category.ispublished = true
order by displaynumber asc;
END;
$$;


--
-- Name: getcompanycategorybyid(uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanycategorybyid(_id uuid, _languagecode public.citext DEFAULT 'en'::public.citext) RETURNS TABLE(id uuid, name jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select category.id, category.name
from category where category.companyid = _id and category.isdeleted = false and category.ispublished = true
;
END;
$$;


--
-- Name: getcompanychannelnotification(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanychannelnotification(_id uuid) RETURNS TABLE(id uuid, subject public.citext, startdate date, starttime time without time zone, urgent boolean, priority integer, createdat timestamp without time zone)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY

select notification.id,notification.subject,notification.startdate,notification.starttime,notification.urgent,notification.priority,notification.createdat from notification where notification.isdeleted = false;

END;
$$;


--
-- Name: getcompanychannels(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanychannels(_companyid uuid) RETURNS TABLE(companyid uuid, channelid uuid, isactive boolean, name public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select cc.companyid, cc.channelid, cc.isactive, clp.name
    from companychannels cc
    inner join channellookup clp on clp.id = cc.channelid
    where cc.companyid = _companyid ;

END;
$$;


--
-- Name: getcompanychatservice(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanychatservice(_companyid uuid) RETURNS SETOF public.citext
    LANGUAGE plpgsql
    AS $$

BEGIN
RETURN QUERY
    select name from companywaapiservicechat where companyid = _companyid;
END;
$$;


--
-- Name: getcompanycities(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanycities(_companyid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, name public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY

select distinct address.cityname as cityid, case when (cityar.value  is not null) then cityar.value else cityen.value end name from address
inner join branchaddress on branchaddress.addressid = address.id
inner join branch on branch.id = branchaddress.branchid 
left join languageresourcee cityen on (address.cityname = cityen.objectid and cityen.languagecode = 'en')
left join languageresourcee cityar on (address.cityname = cityar.objectid and cityar.languagecode = 'ar')
where branch.companyid = _companyid;
END;
$$;


--
-- Name: restaurantpaymentcredentials; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.restaurantpaymentcredentials (
    rid uuid NOT NULL,
    marchentname public.citext NOT NULL,
    username public.citext NOT NULL,
    password public.citext NOT NULL,
    marchent public.citext NOT NULL,
    authid public.citext,
    marchentapplepay public.citext
);


--
-- Name: getcompanycredentailsbyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanycredentailsbyid(_id uuid DEFAULT NULL::uuid) RETURNS SETOF public.restaurantpaymentcredentials
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select * from restaurantpaymentcredentials where rid = _id;
END;
$$;


--
-- Name: getcompanycustomerorders(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanycustomerorders(_customerid uuid, _companyid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, createdat timestamp without time zone, totalprice numeric, channelname public.citext, deliverytype public.citext, deliveryprice numeric, currentstatus public.citext, statuscolor public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select ord.id ,ord.createdat , ord.totalprice ,getlookupname(ord.channelid),getdeliveryname(ord.deliverytype) ,ord.deliveryprice, getorderstatus(ord.currentstatus) , getorderstatuscolor(ord.currentstatus) from "order" ord where isdeleted = false and ispublished=true and customerid = _customerid and branchid in(select distinct branch.id from branch where companyid= _companyid) ;
END;
$$;


--
-- Name: getcompanycutomersbycompanyforddl(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanycutomersbycompanyforddl(_companyid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, name public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select distinct c.id , concat(c.name ,' - ', c.phoneno)::citext from customer c
inner join "order" o on o.customerid = c.id
where o.branchid = any(select b.id from branch b where b.companyid = _companyid);
END;
$$;


--
-- Name: getcompanydeletedbranches(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanydeletedbranches(_companyid uuid) RETURNS SETOF public.branch
    LANGUAGE plpgsql
    AS $$
begin
    return query
        select * from branch where companyid = _companyid and deletedat is true;
END;
$$;


--
-- Name: getcompanyfaq(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanyfaq(_companyid uuid) RETURNS TABLE(id uuid, question public.citext, answer1 public.citext, answer2 public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    
    select faq.id, faq.question,faq.answer1,faq.answer2 from companyfaq faq where companyid = _companyid and isdeleted = false order by createdat desc;
END;
$$;


--
-- Name: getcompanyfaq_ai(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanyfaq_ai(_companyid uuid) RETURNS TABLE(id uuid, question public.citext, answer1 public.citext, answer2 public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    
    select faq.id, faq.question,faq.answer1,faq.answer2 from companyfaq faq where companyid = _companyid and isdeleted = false order by createdat desc;
END;
$$;


--
-- Name: getcompanyfirstorder(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanyfirstorder(_companyid uuid, _ordersource uuid) RETURNS TABLE(branchname public.citext, branchfisrtorder timestamp without time zone)
    LANGUAGE plpgsql
    AS $$
begin
    return query
        select        B.name           as branchname,
                      min(O.createdat) as branchfisrtorder

        from "order" O
                 JOIN branch B ON O.branchid = B.id
        where branchid IN (SELECT id
                           from branch
                           where companyid = _companyid)
          and ordersource = _ordersource
        GROUP BY B.name
        ORDER BY branchfisrtorder DESC;
END;
$$;


--
-- Name: getcompanyid(public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanyid(_companyname public.citext) RETURNS TABLE(_companyid uuid)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select id from company where name = _companyname and isdeleted = false;
END;
$$;


--
-- Name: getcompanyidbybranchid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanyidbybranchid(_branchid uuid) RETURNS TABLE(companyid uuid)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select b.companyid from branch b where b.id = _branchid;
END;
$$;


--
-- Name: getcompanyidbyinstanceid(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanyidbyinstanceid(_instanceid integer) RETURNS TABLE(companyid uuid, integrationtype public.citext)
    LANGUAGE plpgsql
    AS $$

BEGIN
RETURN QUERY
    select wc.companyid,wc.integrationtype from waapiclients wc where wc.instanceid = _instanceid;
END;
$$;


--
-- Name: getcompanyidbyphone(public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanyidbyphone(_phonenumber public.citext) RETURNS SETOF uuid
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select companyid from companyinfo where type = 'phone' and value = _phonenumber and isdeleted = false and ispublished = true;
END;
$$;


--
-- Name: getcompanyidbyphonenumber(public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanyidbyphonenumber(_phonenumber public.citext) RETURNS SETOF uuid
    LANGUAGE plpgsql
    AS $$
BEGIN
 RETURN QUERY
    SELECT companyid
    FROM viciphonenumber
    WHERE companyphone = _phonenumber;
END;
$$;


--
-- Name: getcompanyinfobyid(uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanyinfobyid(_id uuid DEFAULT NULL::uuid, _languagecode public.citext DEFAULT NULL::public.citext) RETURNS TABLE(id uuid, value public.citext, companyid uuid, type integer, createdat timestamp without time zone, createdby public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select  companyinfo.id , getvalue(_languagecode , 'companyInfo' , companyinfo.id , 1),  companyinfo.companyid , companyinfo.type , companyinfo.createdat  , companyinfo.createdby
from companyinfo where companyinfo.id = _id and isdeleted = false and ispublished = true;

END;
$$;


--
-- Name: getcompanyinformationbyid(uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanyinformationbyid(_companyid uuid DEFAULT NULL::uuid, _languagecode public.citext DEFAULT NULL::public.citext) RETURNS TABLE(logo character varying, info json, name public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select  company.logo,( select to_json(array(select to_json(json_build_object(coi.type,coi.value)) 
from companyinfo coi inner join company co 
on coi.companyid = co.id
where coi.companyid = _companyid and coi.isdeleted = false and coi.ispublished = true))), (select co.name from companyinfo coi inner join company co 
on coi.companyid = co.id
where coi.companyid = _companyid and coi.isdeleted = false and coi.ispublished = true limit 1) from company where company.id = _companyid 
;
END;
$$;


--
-- Name: getcompanylanguages(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanylanguages(_companyid uuid) RETURNS TABLE(id uuid, name public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select id,value from companyinfo where companyid =_companyid and type = 'language' and isdeleted = false ;
END;
$$;


--
-- Name: getcompanylastorder(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanylastorder(_companyid uuid, _ordersource uuid) RETURNS TABLE(branchname public.citext, branchfisrtorder timestamp without time zone)
    LANGUAGE plpgsql
    AS $$
begin
    return query
        select        B.name           as branchname,
                      max(O.createdat) as branchfisrtorder

        from "order" O
                 JOIN branch B ON O.branchid = B.id
        where branchid IN (SELECT id
                           from branch
                           where companyid = _companyid)
          and ordersource = _ordersource
        GROUP BY B.name
        ORDER BY branchfisrtorder DESC;
END;
$$;


--
-- Name: getcompanylogo(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanylogo(_id uuid) RETURNS TABLE(registrationphoto character varying, name public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
--select logo from company where id = '382bf1d5-de11-4d19-bbbd-a2a53d80b428' limit 1;
select (o.registrationphoto::varchar),c.name from orderconfig o inner join company c on o.companyid = c.id where companyid = _id limit 1;
END;
$$;


--
-- Name: getcompanymenu_ai(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanymenu_ai(_companyid uuid) RETURNS TABLE(menuid uuid, branchids uuid[], branchnames public.citext[], menujson json)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    select
           m2.menuid,
    array_agg(b.id),
       array_agg(b.name),
       getmenujson(m2.menuid)
from company c
inner join companyactiveintegrations c2 on c.id = c2.companyid
inner join branch b on c.id= b.companyid
inner join menuchannel m2 on b.id = m2.branchid and m2.channelid = '79401a8a-0d53-4988-a08d-31d1b3514919'
inner join menu m on m2.menuid= m.id and m.isavailable = true
where c2.channelid ='79401a8a-0d53-4988-a08d-31d1b3514919'
and c.id = _companyid
group by m2.menuid;
END;
$$;


--
-- Name: getcompanymenuurl(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanymenuurl(_companyid uuid) RETURNS TABLE(restaurantdomain public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
   SELECT orderconfig.restaurantdomain FROM orderconfig  where  orderconfig.companyid = _companyid;
END;
$$;


--
-- Name: getcompanymenuurl_ai(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanymenuurl_ai(_companyid uuid) RETURNS TABLE(restaurantdomain public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
   SELECT orderconfig.restaurantdomain FROM orderconfig  where  orderconfig.companyid = _companyid;
END;
$$;


--
-- Name: getcompanyname(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanyname(_id uuid DEFAULT NULL::uuid) RETURNS SETOF public.citext
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select name from company where id = _id and isdeleted = false and ispublished = true;
END;
$$;


--
-- Name: getcompanynamefortalabat(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanynamefortalabat(_id uuid) RETURNS SETOF public.citext
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select co.name from company co 
 inner join branch br
 on br.companyid = co.id 
 where br.id =  _id and br.isdeleted = false limit 1; 
 
END;
$$;


--
-- Name: getcompanynewaddress(public.citext, public.citext, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanynewaddress(keyword public.citext, cityid public.citext, _companyid uuid DEFAULT NULL::uuid) RETURNS TABLE(name public.citext, id uuid)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY

select CONCAT(brd.area,'-',brd.subarea)::citext as name,brd.id from branchdeliverycharge brd
                                                                  where brd.city = cityid and brd.companyid = _companyid;
END;
$$;


--
-- Name: getcompanyofferimage(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanyofferimage(_companyid uuid DEFAULT NULL::uuid) RETURNS SETOF public.citext
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
SELECT CONCAT(getimagepathurl(imagepath),imagepath)::citext FROM offerimage WHERE companyid = _companyid and ispublished = 'true' and isdeleted = 'false';
END;
$$;


--
-- Name: getcompanypayment(uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanypayment(_companyid uuid DEFAULT NULL::uuid, _paymenttype public.citext DEFAULT NULL::public.citext) RETURNS TABLE(id uuid, name text)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select companyinfo.id, companyinfo.value from companyinfo where companyid = _companyid and type = _paymenttype ;

END;
$$;


--
-- Name: getcompanypohneidserivce(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanypohneidserivce(_id uuid DEFAULT NULL::uuid) RETURNS SETOF public.citext
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select  cs.whatsappcompanyid
from companyservices cs where cs.companyid = _id and cs.serviceid = '31270387-ac3b-4ed2-99ba-da040a5eec74';

END;
$$;


--
-- Name: getcompanyposintegration(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanyposintegration(_companyid uuid) RETURNS TABLE(id uuid, intcompany uuid)
    LANGUAGE plpgsql
    AS $$

BEGIN
RETURN QUERY
    select posi.companyid,posi.integrationcompanyid from posintegration posi where posi.companyid= (select b.companyid from branch b where b.id = (select branchid from "order" ord where ord.id = _companyid)) or posi.companyid = _companyid;
		END;
$$;


--
-- Name: getcompanyposintegrationbycompanyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanyposintegrationbycompanyid(_companyid uuid) RETURNS TABLE(integrationcompanyid uuid, name public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
        select pos.integrationcompanyid, ic.name from posintegration pos
        inner join integrationcompany ic on ic.id = pos.integrationcompanyid where companyid = _companyid;
	END;
$$;


--
-- Name: product; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.product (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    categoryid uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    imagepath public.citext,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext,
    price jsonb DEFAULT '{"careem": 0, "mobile": 0, "online": 0, "default": 0, "talabat": 0, "callcenter": 0, "priceTaxPercentage": 0}'::jsonb,
    description jsonb,
    name jsonb NOT NULL,
    shortdescription jsonb NOT NULL,
    sku public.citext,
    fulldescription jsonb,
    isavailable boolean DEFAULT true NOT NULL,
    hour integer,
    min integer,
    displaynumber integer DEFAULT 1,
    isoffer boolean,
    producttags jsonb,
    istopselling boolean DEFAULT false NOT NULL,
    branchprice jsonb,
    aliasname jsonb DEFAULT '{}'::jsonb,
    aliasdescription jsonb DEFAULT '{}'::jsonb,
    thumbimage public.citext,
    external_pos_id public.citext
);


--
-- Name: getcompanyproductswithoutvalidation(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanyproductswithoutvalidation(_companyid uuid DEFAULT NULL::uuid) RETURNS SETOF public.product
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY

select * from product where product.categoryid
IN(select category.id from category where category.companyid = _companyid )
and product.isdeleted = false ;
END;
$$;


--
-- Name: companyreports; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.companyreports (
    companyid uuid,
    link public.citext,
    reporttype public.citext,
    createdby public.citext,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text)
);


--
-- Name: getcompanyreportsbycompanyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanyreportsbycompanyid(_id uuid) RETURNS SETOF public.companyreports
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select * from companyreports where companyid = _id order by createdat desc limit 10;
END;
$$;


--
-- Name: getcompanyserviceid(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanyserviceid(_companyid uuid, _serviceid uuid) RETURNS SETOF public.citext
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select cs.whatsappid from companyservices cs where cs.companyid = _companyid and cs.serviceid = _serviceid ;
END;
$$;


--
-- Name: getcompanyservices(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanyservices(_companyid uuid) RETURNS TABLE(companyid uuid, serviceid uuid, isactive boolean, name public.citext, phonenumber public.citext, whatsappid public.citext, whatsappcompanyid public.citext, availablebalance bigint, chargebalance bigint, counrtycode public.citext, charlengthar bigint, charlengthen bigint)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select  (select c.id from company c where c.id = _companyid),nlm.id,cs.isactive,nlm.name,cs.phonenumber, cs.whatsappid, cs.whatsappcompanyid, cs.availablebalance, cs.chargebalance, cs.counrtycode, cs.charlengthar, cs.charlengthen
    from namelookup nlm 
    left join companyservices cs on (cs.serviceid = nlm.id and cs.companyid = _companyid)
    where nlm.tabletype = 'service'  ;
--       and cc.isactive = true;
END;
$$;


--
-- Name: getcompanysubandareasexceltemplatedata(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanysubandareasexceltemplatedata(_branchid uuid) RETURNS TABLE(id uuid, cityid integer, areaid bigint, areacodeid integer, subareaname public.citext, fees numeric, branchname public.citext, areaname public.citext, cityname public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
        SELECT saf.id As "Id",
            csa.cityid   AS "CityId",
               ia.areaid    AS "AreaId",
               csa.areacode AS "AreaCodeId",
               csa.name     AS "SubAreaName",
               saf.fees     AS "Fees",
               b.name       AS "BranchName",
               ia.name      AS "AreaName",
               ic.name_en   AS "CityName"
        from companysubarea csa
                 inner join branch b on b.id = _branchid
                 inner join ishbekareas ia on ia.cityid = csa.cityid and ia.areaid = csa.areaid
                 inner join  ishbekcities ic on ia.cityid = ic.cityid
                 LEFT JOIN public.branchsubareafees saf
                           ON saf.areacodeid = csa.areacode and csa.areaid = saf.areaid and csa.cityid = saf.cityid  AND saf.branchid = _branchid
        where csa.companyid = b.companyid
        ORDER BY b.createdat DESC;
END;
$$;


--
-- Name: getcompanysubarea(uuid, bigint); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanysubarea(_companyid uuid, _areaid bigint) RETURNS TABLE(id uuid, companyid uuid, cityid integer, areaid bigint, name public.citext, areacode integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select
           csa.id,
           csa.companyid,
           csa.cityid,
           csa.areaid ,
           csa.name,
           csa.areacode
    from companysubarea csa where csa.companyid = _companyid and csa.areaid = _areaid;

END;
$$;


--
-- Name: getcompanyuserview(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanyuserview(_companyid uuid) RETURNS TABLE(id uuid, branches public.citext[], username public.citext, usertype public.citext, phonenumber numeric, isactive boolean)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select companyuser.id, array(select getbranchesname(companyuser.branchid))as branches, companyuser.username, companyuser.usertype, companyuser.phonenumber, companyuser.isactive from companyuser
where companyid=_companyid;
END;
$$;


--
-- Name: whatsapptemplate; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.whatsapptemplate (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    name public.citext NOT NULL,
    companyid uuid NOT NULL,
    tlanguage public.citext,
    status public.citext,
    whatsapptemplateid public.citext,
    category public.citext,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    deletedat timestamp without time zone,
    deletedby public.citext,
    components jsonb,
    servicename public.citext DEFAULT 'whatsapp'::public.citext
);


--
-- Name: getcompanywaapitemplate(public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanywaapitemplate(_tempname public.citext) RETURNS SETOF public.whatsapptemplate
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select * from whatsapptemplate wt where wt.name = _tempname;
END;
$$;


--
-- Name: getcompanywhatsapptemplate(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanywhatsapptemplate(_id uuid) RETURNS SETOF public.whatsapptemplate
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select * from whatsapptemplate wt where wt.companyid = _id;
END;
$$;


--
-- Name: getcompanywhatsapptemplatemessage(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcompanywhatsapptemplatemessage(_id uuid) RETURNS SETOF public.whatsapptemplate
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select * from whatsapptemplate wt where wt.companyid = _id and status = 'APPROVED';
END;
$$;


--
-- Name: getcomplainbyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcomplainbyid(_customerid uuid) RETURNS TABLE(id uuid, customerid uuid, branchname public.citext, status public.citext, createdat timestamp without time zone, category public.citext, subcategory public.citext, details public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select generalcomplain.id , generalcomplain.customerid , branch.name , generalcomplain.status , generalcomplain.createdat , generalcomplain.category,generalcomplain.subcategory , generalcomplain.details from generalcomplain
 inner join branch on branch.id = generalcomplain.branchid where generalcomplain.customerid = _customerid and generalcomplain.isdeleted = false and generalcomplain.ispublished =true;
END;
$$;


--
-- Name: namelookup; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.namelookup (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    tabletype public.citext NOT NULL,
    name public.citext NOT NULL,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext,
    referenceid uuid
);


--
-- Name: getcomplaincategories(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcomplaincategories() RETURNS SETOF public.namelookup
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select * from namelookup where isdeleted = false and ispublished = true and tabletype= 'complaincategory';
END;
$$;


--
-- Name: getcomplaincategoriestree(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcomplaincategoriestree() RETURNS TABLE(id uuid, category public.citext, subcategory jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select com.id,com.name,to_json( Array( select to_json(
json_build_object(
'id' , cc.id,
'name', cc.name,
'referenceid', cc.referenceid
))	from namelookup cc where cc.tabletype = 'complainsubcategory' and cc.referenceid = com.id
))::jsonb from namelookup com where com.tabletype = 'complaincategory';
END;
$$;


--
-- Name: getcomplainsubcategories(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcomplainsubcategories() RETURNS SETOF public.namelookup
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select * from namelookup where isdeleted = false and ispublished = true and tabletype= 'complainsubcategory';
END;
$$;


--
-- Name: getcomplainsubcategories(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcomplainsubcategories(_categoryid uuid DEFAULT NULL::uuid) RETURNS SETOF public.namelookup
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select * from namelookup where referenceid = _categoryid and isdeleted = false and ispublished = true and tabletype= 'complainsubcategory';
END;
$$;


--
-- Name: getcomplainsubcategorybyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcomplainsubcategorybyid(_referenceid uuid DEFAULT NULL::uuid) RETURNS TABLE(value public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select  name  from namelookup where tabletype = 'complainsubcategory' and referenceid = _referenceid;
END;
$$;


--
-- Name: coupon; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.coupon (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    offerid uuid,
    coupontype integer,
    minprice numeric,
    maxprice numeric,
    minquantity integer,
    maxquantity integer,
    couponvalue numeric,
    isunlimited boolean DEFAULT false NOT NULL,
    numberofuses integer,
    customerids uuid[],
    code public.citext,
    fromdate timestamp without time zone,
    todate timestamp without time zone,
    fromtime timestamp without time zone,
    totime timestamp without time zone,
    newprice numeric,
    ispercentage boolean,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext
);


--
-- Name: getcouponbyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcouponbyid(_id uuid) RETURNS SETOF public.coupon
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select * from coupon where isdeleted = false and ispublished=true and id = _id;
END;
$$;


--
-- Name: getcoupons(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcoupons(_pagenumber integer DEFAULT NULL::integer, _pagesize integer DEFAULT NULL::integer) RETURNS SETOF public.coupon
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select * from coupon where isdeleted = false and ispublished=true 
LIMIT _pagesize
OFFSET ((_pagenumber-1) * _pagesize);
END;
$$;


--
-- Name: getcurrentstatus(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcurrentstatus(_orderid uuid DEFAULT NULL::uuid) RETURNS TABLE(islaststatus boolean)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select os.islaststatus from "order" o inner join orderstatuspossibilities os on o.currentstatus=os.id where o.id =_orderid;

END;
$$;


--
-- Name: getcustomeraddress(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomeraddress(_customerid uuid) RETURNS TABLE(latitude numeric, longtitude numeric, name public.citext, details public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select customeraddress.latitude,customeraddress.longtitude,customeraddress.name,customeraddress.details from customeraddress where customerid =_customerid and customeraddress.latitude is not null and customeraddress.longtitude is not null;
END;
$$;


--
-- Name: getcustomeraddressbycompany(uuid, uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomeraddressbycompany(_companyid uuid, _addressid uuid DEFAULT NULL::uuid, _customerid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, name public.citext, subareaid uuid, subareaname public.citext, areaid uuid, areaname public.citext, cityid uuid, cityname public.citext, countryid uuid, countryname public.citext, latitude numeric, longtitude numeric, buildingno public.citext, streetno public.citext, note public.citext, details public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select  ad.id ,cad.name , ad.subareaname ,
getlocalizationvalue('ar' , 'subareaName' ,ad.subareaname , 1),
ad.areaname, getlocalizationvalue('ar' , 'areaName' ,ad.areaname , 1), 
ad.cityname ,getlocalizationvalue('ar' , 'cityName' ,ad.cityname , 1), 
ad.countryname, getlocalizationvalue('ar' , 'countryname' ,ad.countryname , 1), 
ad.latitude , ad.longtitude ,
 cad.buildingno , cad.streetname ,
cad.notes , cad.details
from customeraddress cad
inner join address ad on ad.id= cad.addressid
inner join branchaddress on branchaddress.addressid = ad.id
inner join branch on branch.id = branchaddress.branchid 
where ad.id = _addressid and cad.customerid=_customerid and branch.companyid = _companyid and ad.isdeleted = false and ad.ispublished = true;

END;
$$;


--
-- Name: getcustomeraddressbycoords(uuid, numeric, numeric); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomeraddressbycoords(_customerid uuid, _lat numeric, _long numeric) RETURNS TABLE(addressid uuid)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select customeraddress.addressid from customeraddress
where customerid = _customerid and latitude = _lat
and longtitude = _long;
END;
$$;


--
-- Name: getcustomeraddressbyphonenumber(public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomeraddressbyphonenumber(_phonenumber public.citext) RETURNS TABLE(id uuid, name public.citext, phoneno public.citext, phoneno2 public.citext, address json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select "customer".id,"customer".name,"customer".phoneno,"customer".phoneno2,
 to_json(
        Array(
            select
                to_json(
                    json_build_object(
                        'id',
                        cad.addressid,
                        'name',
                        cad.name,
						'buildingno',
						cad.buildingno,
						'streetname',
						cad.streetname,
							'details',
						cad.details,
						'city',
						(select getlocalizationvalue('en',ad.cityname)),
						'areaname',
						(select getlocalizationvalue('en',ad.areaname)),
						'subareaname',
						(select getlocalizationvalue('en',ad.subareaname))
						)
					)
			   from customeraddress cad
			inner join address ad on ad.id = cad.addressid
			)
          ) 
from customer WHERE ("customer".phoneno like(concat('%',_phonenumber,'%')) OR "customer".phoneno2 like(concat('%',_phonenumber,'%'))) AND "customer".isdeleted = 'false' AND "customer".ispublished = 'true';
END;
$$;


--
-- Name: getcustomeraddresses(uuid, uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomeraddresses(_customerid uuid, _companyid uuid, _channelid uuid) RETURNS TABLE(id uuid, companyid uuid, customerid uuid, ishbekcityid integer, ishbekareaid bigint, preferedsubarea public.citext, name public.citext, lat double precision, lng double precision, street public.citext, buildingnumber public.citext, otherdetails public.citext, notes public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select
        a.id,
        a.companyid,
        a.customerid,
        a.ishbekcityid,
        a.ishbekareaid, a.preferedsubarea, a.name, a.lat, a.lng, a.street, a.buildingnumber, a.otherdetails, a.notes
        from addresses a
        where a.companyid = _companyid and a.customerid = _customerid and creationsource = _channelid and isdeleted is false;
END;
$$;


--
-- Name: getcustomeraddressesandinfobyphone(public.citext, uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomeraddressesandinfobyphone(_phonenumber public.citext, _companyid uuid, _channelid uuid) RETURNS TABLE(customerid uuid, customername public.citext, customerphone public.citext, fullphonenumber public.citext, countrycode public.citext, isblocked boolean, addresses json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
SELECT
    c.id              AS "CustomerId",
    c.name            AS "CustomerName",
    c.phoneno         AS "CustomerPhone",
    c.fullphonenumber AS "FullPhoneNumber",
    c.countrycode     AS "CountryCode",
    bl.isapproved     AS "IsBlocked",
    (
        SELECT json_agg(
            json_build_object(
                'addressId', a.id,
                'companyId', a.companyid,
                'customerId', a.customerid,
                'ishbekCityId', a.ishbekcityid,
                'ishbekAreaId', a.ishbekareaid,
                'preferedSubArea', a.preferedsubarea,
                'name', a.name,
                'lat', a.lat,
                'lng', a.lng,
                'street', a.street,
                'buildingNumber', a.buildingnumber,
                'otherDetails', a.otherdetails,
                'notes', a.notes,
                'city', a.ishbekcityid,
                'subareaid' ,a.subareaid
             )
        )
        FROM (
            SELECT a.*
            FROM addresses a
            LEFT JOIN ishbekcities ic ON ic.cityid = a.ishbekcityid
            WHERE a.customerid = c.id
            AND a.companyid = _companyid
            AND a.creationsource = _channelid
            AND A.isdeleted = false
            ORDER BY a.createdat DESC
            LIMIT 5
        ) AS a
    ) AS "Addresses"
FROM customer c
left join blacklist bl on c.id = bl.customerid and bl.companyid = _companyid
WHERE c.phoneno = _phonenumber ;

END;
$$;


--
-- Name: getcustomeraddressforonlineorder(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomeraddressforonlineorder(_customerid uuid) RETURNS TABLE(latitude numeric, longtitude numeric, name public.citext, details public.citext, addressid uuid)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select customeraddress.latitude,customeraddress.longtitude,customeraddress.name,customeraddress.details,customeraddress.addressid from customeraddress where customerid =_customerid and customeraddress.latitude is not null and customeraddress.longtitude is not null;
END;
$$;


--
-- Name: getcustomeraddressgeo(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomeraddressgeo() RETURNS TABLE(addressid uuid, latitude numeric, longtitude numeric)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select ca.addressid,ca.latitude,ca.longtitude from customeraddress ca where georeflected != true and ca.latitude is not null and ca.longtitude is not null;
END;
$$;


--
-- Name: getcustomeraddressreports(timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomeraddressreports(_fromtime timestamp without time zone DEFAULT NULL::timestamp without time zone, _totime timestamp without time zone DEFAULT NULL::timestamp without time zone) RETURNS TABLE(addressid uuid, addressname public.citext, countrycode public.citext, phoneno public.citext, customername public.citext, details public.citext, streetname public.citext, buildingno public.citext, departmentno public.citext, latitude numeric, longtitude numeric, totalorder bigint)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
SELECT ca.addressid,ca.name as addressname,cu.countrycode,cu.phoneno,cu.name as customername,ca.details,ca.streetname,ca.buildingno,ca.departmentno,ca.latitude,ca.longtitude,(select COUNT(ord.id) from "order" ord where ord.deliveryaddress = ca.addressid ) as totalorder 
FROM customeraddress ca LEFT JOIN customer cu on cu.id = ca.customerid WHERE ((_fromtime is null) or( _fromtime <= cu.createdat))
and ((_totime is null) or( _totime >= cu.createdat));
END;
$$;


--
-- Name: getcustomeraddressreports(uuid, timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomeraddressreports(_companyid uuid, _fromtime timestamp without time zone DEFAULT NULL::timestamp without time zone, _totime timestamp without time zone DEFAULT NULL::timestamp without time zone) RETURNS TABLE(addressid uuid, addressname public.citext, phoneno public.citext, customername public.citext, details public.citext, streetname public.citext, buildingno public.citext, departmentno public.citext, latitude numeric, longtitude numeric, totalorder bigint)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
SELECT distinct ca.addressid,ca.name as addressname,cu.phoneno,cu.name as customername,ca.details,ca.streetname,ca.buildingno,ca.departmentno,ca.latitude,ca.longtitude,(select COUNT(ord.id) from "order" ord where ord.deliveryaddress = ca.addressid ) as totalorder
FROM customeraddress ca
LEFT JOIN customer cu on cu.id = ca.customerid
inner join "order" o  on o.deliveryaddress = ca.addressid and o.branchid = any(select id from branch where companyid = _companyid)
WHERE ((_fromtime is null) or( _fromtime <= cu.createdat))
and ((_totime is null) or( _totime >= cu.createdat))
and ca.name is not null;
END;
$$;


--
-- Name: customerbillingdetails; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.customerbillingdetails (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    customerid uuid NOT NULL,
    firstname public.citext NOT NULL,
    lastname public.citext NOT NULL,
    email public.citext NOT NULL,
    postalcode public.citext NOT NULL,
    country public.citext NOT NULL,
    provinance public.citext NOT NULL,
    city public.citext NOT NULL,
    street public.citext NOT NULL,
    buildingnumber public.citext NOT NULL,
    createdat timestamp(6) without time zone DEFAULT now() NOT NULL,
    createdby public.citext DEFAULT 'SYSTEM'::public.citext NOT NULL,
    updatedat timestamp(6) without time zone,
    updatedby public.citext DEFAULT ''::public.citext,
    deletedat timestamp(6) without time zone,
    deletedby public.citext DEFAULT ''::public.citext,
    ipaddress public.citext DEFAULT '0.0.0.0'::public.citext NOT NULL
);


--
-- Name: getcustomerbillingdetail(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomerbillingdetail(_customerid uuid) RETURNS SETOF public.customerbillingdetails
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
   select * from customerbillingdetails where customerid = _customerid order by createdat desc limit 1;
 END;
$$;


--
-- Name: getcustomerbycategory(uuid, integer[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomerbycategory(_companyid uuid, _id integer[]) RETURNS TABLE(phone public.citext, name public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select cs.fullphonenumber,cs.name from customer cs inner join restaurantcustomer rc on rc.customerid = cs.id where rc.restaurantid =_companyid and rc.currentstatus = any(_id);
END
$$;


--
-- Name: getcustomerbyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomerbyid(_id uuid) RETURNS TABLE(id uuid, name public.citext, phoneno public.citext, phoneno2 public.citext, lastorderdate date, email public.citext, fb public.citext, twitter public.citext, instagram public.citext, notes public.citext, isblocked boolean, isverify boolean, createdat timestamp without time zone, fullphonenumber public.citext, address json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select "customer".id,"customer".name,"customer".phoneno,"customer".phoneno2,"customer".Lastorderdate,"customer".Email,"customer".Fb,"customer".Twitter,"customer".Instagram,"customer".Notes,"customer".Isblocked,"customer".isverify,"customer".Createdat,"customer".fullphonenumber,
 to_json(
        Array(
            select
                to_json(
                    json_build_object(
                        'id',
                        customeraddress.addressid,
                        'name',
                        customeraddress.name,
						'latitude',
                        customeraddress.latitude,
						'longtitude',
                        customeraddress.longtitude,
						'streetname',
                        customeraddress.streetname,
						'buildingno',
                        customeraddress.buildingno,
						'departmentno',
                        customeraddress.departmentno,
						'details',
                        customeraddress.details,
						'notes',
                        customeraddress.notes
						)
					)
			       from customeraddress
					where customeraddress.customerid = "customer".id and customeraddress.isdeleted = 'false' 
			)
          ) address
from customer WHERE "customer".id = _id AND "customer".isdeleted = 'false' AND "customer".ispublished = 'true';
END;
$$;


--
-- Name: getcustomercheck(public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomercheck(_phonenumber public.citext) RETURNS TABLE(id uuid, name public.citext, phoneno public.citext, phoneno2 public.citext, lastorderdate date, email public.citext, fb public.citext, twitter public.citext, instagram public.citext, notes public.citext, isblocked boolean, isverify boolean, createdat timestamp without time zone, fullphonenumber public.citext, address json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select "customer".id,"customer".name,"customer".phoneno,"customer".phoneno2,"customer".Lastorderdate,"customer".Email,"customer".Fb,"customer".Twitter,"customer".Instagram,"customer".Notes,"customer".Isblocked,"customer".isverify,"customer".Createdat,"customer".fullphonenumber,
 to_json(
        Array(
            select
                to_json(
                    json_build_object(
                        'id',
                        customeraddress.addressid,
                        'name',
                        customeraddress.name,
						'latitude',
                        customeraddress.latitude,
						'longtitude',
                        customeraddress.longtitude,
						'streetname',
                        customeraddress.streetname,
						'buildingno',
                        customeraddress.buildingno,
						'departmentno',
                        customeraddress.departmentno,
						'details',
                        customeraddress.details,
						'notes',
                        customeraddress.notes
						)
					)
			       from customeraddress
					where customeraddress.customerid = "customer".id and customeraddress.isdeleted = 'false' 
			)
          ) address
from customer WHERE "customer".fullphonenumber = _phonenumber AND "customer".isdeleted = 'false' AND "customer".ispublished = 'true';
END;
$$;


--
-- Name: getcustomercompanycheck(public.citext, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomercompanycheck(_phonenumber public.citext, _companyid uuid) RETURNS TABLE(id uuid, name public.citext, phoneno public.citext, phoneno2 public.citext, lastorderdate date, email public.citext, fb public.citext, twitter public.citext, instagram public.citext, notes public.citext, isblocked boolean, isverify boolean, createdat timestamp without time zone, fullphonenumber public.citext, address json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select "customer".id,"customer".name,"customer".phoneno,"customer".phoneno2,"customer".Lastorderdate,"customer".Email,"customer".Fb,"customer".Twitter,"customer".Instagram,"customer".Notes,"customer".Isblocked,"customer".isverify,"customer".Createdat,"customer".fullphonenumber,
 to_json(
        Array(
            select
                to_json(
                    json_build_object(
                        'id',
                        customeraddress.addressid,
                        'name',
                        customeraddress.name,
						'latitude',
                        customeraddress.latitude,
						'longtitude',
                        customeraddress.longtitude,
						'streetname',
                        customeraddress.streetname,
						'buildingno',
                        customeraddress.buildingno,
						'departmentno',
                        customeraddress.departmentno,
						'details',
                        customeraddress.details,
						'notes',
                        customeraddress.notes
						)
					)
			       from customeraddress
					where customeraddress.customerid = "customer".id and customeraddress.isdeleted = false 
			)
          ) address
from customer left join restaurantcustomer rc on rc.customerid = "customer".id  WHERE rc.isactive = true and rc.restaurantid =_companyid and "customer".fullphonenumber = _phonenumber AND "customer".isdeleted = false AND "customer".ispublished = true;
END;
$$;


--
-- Name: getcustomercompanydetails(public.citext, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomercompanydetails(_phonenumber public.citext, _companyid uuid) RETURNS TABLE(id uuid, name public.citext, phoneno public.citext, phoneno2 public.citext, lastorderdate date, email public.citext, fb public.citext, twitter public.citext, instagram public.citext, notes public.citext, isblocked boolean, createdat timestamp without time zone, address json)
    LANGUAGE plpgsql
    AS $$

BEGIN
RETURN QUERY
select "customer".id,"customer".name,"customer".phoneno,"customer".phoneno2,"customer".Lastorderdate,"customer".Email,"customer".Fb,"customer".Twitter,"customer".Instagram,"customer".Notes,"customer".Isblocked,"customer".Createdat,
 to_json(
        Array(
            select
                to_json(
                    json_build_object(
                        'id',
                        customeraddress.addressid,
                        'name',
                        customeraddress.name,
						'englishcityname',
						getvaluelocalization('en' , 'cityName' ,address.cityname , 1),
						'arabiccityname',
						getvaluelocalization('ar' , 'cityName' ,address.cityname , 1),
						'englishareaname',
						getvaluelocalization('en' , 'areaname' ,address.areaname , 1),
						'arabicareaname',
						getvaluelocalization('ar' , 'areaname' ,address.areaname , 1),
						'englishsubareaname',
						getvaluelocalization('en' , 'subareaname' ,address.subareaname , 1),
						'arabicsubareaname',
						getvaluelocalization('ar' , 'subareaname' ,address.subareaname , 1)
						)
					)
			       from customeraddress
                   left join address on address.id = customeraddress.addressid
					where customeraddress.customerid = "customer".id and customeraddress.isdeleted = false

			)
          ) address
from customer LEFT JOIN restaurantcustomer rc ON rc.customerid = "customer".id  WHERE rc.restaurantid = _companyid and rc.isactive = true and ("customer".phoneno like(concat('%',_phonenumber,'%')) OR "customer".phoneno2 like(concat('%',_phonenumber,'%'))) AND "customer".isdeleted = 'false' AND "customer".ispublished = 'true';
END;
$$;


--
-- Name: getcustomercompanyorders(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomercompanyorders(_customerid uuid, _companyid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, ordersource uuid, ordersourcename public.citext, branchorderid public.citext, createdat timestamp without time zone, iscanceled boolean, totalprice numeric, channelname public.citext, deliverytype public.citext, deliveryprice numeric, currentstatus public.citext, statuscolor public.citext, islast boolean, deliverycompany text, isdeclined boolean, branchid uuid, branchname public.citext, deliverystatus public.citext, scheduled boolean)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select ord.id,
       ord.ordersource,
       getlookupname(ord.ordersource),
       ord.branchorderid,
       ord.createdat,
       ord.iscanceled,
       ord.totalprice,
       getlookupname(ord.channelid),
       getdeliveryname(ord.deliverytype),
       ord.deliveryprice,
       getorderstatus(ord.currentstatus),
       getorderstatuscolor(ord.currentstatus),
       ordstatus.islaststatus,
       delcom.name::json->>'en',
       ord.isdeclined,
       branch.id,
       branch.name as branchname,
       ord.deliverystatus,
       CASE
    when "ord".scheduled is not null  then true
    else false
  END
        from "order"
    ord
inner join branch on ord.branchid = branch.id
left join orderstatuspossibilities ordstatus ON ordstatus.id = ord.currentstatus
left join deliverycompany delcom ON delcom.id = ord.deliverytype
where ord.isdeleted = false and ord.ispublished=true and ord.customerid = _customerid
and ( ( _companyid is null ) or ( branch.companyid =_companyid) )
order by createdat desc limit 10;
END;
$$;


--
-- Name: getcustomercompanyorders_ai(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomercompanyorders_ai(_customerid uuid, _companyid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, ordersource uuid, ordersourcename public.citext, branchorderid public.citext, createdat timestamp without time zone, iscanceled boolean, totalprice numeric, channelname public.citext, deliverytype public.citext, deliveryprice numeric, currentstatus public.citext, statuscolor public.citext, islast boolean, deliverycompany text, isdeclined boolean)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select ord.id, ord.ordersource, getlookupname(ord.ordersource) , ord.branchorderid, ord.createdat,ord.iscanceled , ord.totalprice ,getlookupname(ord.channelid),getdeliveryname(ord.deliverytype) ,ord.deliveryprice, getorderstatus(ord.currentstatus) , getorderstatuscolor(ord.currentstatus),ordstatus.islaststatus,delcom.name::json->>'en' ,ord.isdeclined
        from "order"
    ord
inner join branch on ord.branchid = branch.id
left join orderstatuspossibilities ordstatus ON ordstatus.id = ord.currentstatus
left join deliverycompany delcom ON delcom.id = ord.deliverytype
where ord.isdeleted = false and ord.ispublished=true and ord.customerid = _customerid
and ( ( _companyid is null ) or ( branch.companyid =_companyid) )
order by createdat desc;
END;
$$;


--
-- Name: getcustomercompanyordersforonline(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomercompanyordersforonline(_customerid uuid, _companyid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, ordersource uuid, ordersourcename public.citext, branchorderid public.citext, createdat timestamp without time zone, iscanceled boolean, totalprice numeric, channelname public.citext, deliverytype public.citext, deliveryprice numeric, currentstatus public.citext, statuscolor public.citext, islast boolean, deliverycompany text, isdeclined boolean)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select ord.id, ord.ordersource, getlookupname(ord.ordersource) , ord.branchorderid, ord.createdat,ord.iscanceled , ord.totalprice ,getlookupname(ord.channelid),getdeliveryname(ord.deliverytype) ,ord.deliveryprice, getorderstatus(ord.currentstatus) , getorderstatuscolor(ord.currentstatus),ordstatus.islaststatus,delcom.name::json->>'en'
    ,ord.isdeclined

from "order"

    ord
inner join branch on ord.branchid = branch.id
left join orderstatuspossibilities ordstatus ON ordstatus.id = ord.currentstatus
left join deliverycompany delcom ON delcom.id = ord.deliverytype
where
--ord.isdeleted = false and ord.ispublished=true and
--and ( ( _companyid is null ) or ( branch.companyid =_companyid) ) JMS comminted this code
--order by createdat desc;
ord.isdeleted = false and ord.ispublished = true and -- jms added these two columns
ord.customerid = _customerid and ord.branchid = any(select br.id from branch br where br.companyid = (select cm.id from company cm where cm.id = _companyid))
    order by ord.createdat desc;
END;
$$;


--
-- Name: chatconversation; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.chatconversation (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    companyid uuid NOT NULL,
    phonenumberfrom public.citext NOT NULL,
    phonenumberto public.citext NOT NULL,
    chattype public.citext NOT NULL,
    chatsource public.citext NOT NULL,
    serialized public.citext NOT NULL,
    isviewed boolean DEFAULT true NOT NULL,
    isdelivered boolean DEFAULT true NOT NULL,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext,
    textbody text,
    chatbotsource public.citext
);


--
-- Name: getcustomerconversation(public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomerconversation(_phonenumber public.citext) RETURNS SETOF public.chatconversation
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY

--USE
 select * from chatconversation where phonenumberfrom = _phonenumber ;
END;
$$;


--
-- Name: getcustomerdetails(public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomerdetails(_phonenumber public.citext) RETURNS TABLE(id uuid, name public.citext, phoneno public.citext, phoneno2 public.citext, lastorderdate date, email public.citext, fb public.citext, twitter public.citext, instagram public.citext, notes public.citext, isblocked boolean, createdat timestamp without time zone, address json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select "customer".id,"customer".name,"customer".phoneno,"customer".phoneno2,"customer".Lastorderdate,"customer".Email,"customer".Fb,"customer".Twitter,"customer".Instagram,"customer".Notes,"customer".Isblocked,"customer".Createdat,
 to_json(
        Array(
            select
                to_json(
                    json_build_object(
                        'id',
                        customeraddress.addressid,
                        'name',
                        customeraddress.name,
						'englishcityname',
						getvaluelocalization('en' , 'cityName' ,address.cityname , 1),
						'arabiccityname',
						getvaluelocalization('ar' , 'cityName' ,address.cityname , 1),
						'englishareaname',
						getvaluelocalization('en' , 'areaname' ,address.areaname , 1),
						'arabicareaname',
						getvaluelocalization('ar' , 'areaname' ,address.areaname , 1),
						'englishsubareaname',
						getvaluelocalization('en' , 'subareaname' ,address.subareaname , 1),
						'arabicsubareaname',
						getvaluelocalization('ar' , 'subareaname' ,address.subareaname , 1)
						)
					)
			       from customeraddress
                   left join address on address.id = customeraddress.addressid
					where customeraddress.customerid = "customer".id

			)
          ) address
from customer WHERE ("customer".phoneno like(concat('%',_phonenumber,'%')) OR "customer".phoneno2 like(concat('%',_phonenumber,'%'))) AND "customer".isdeleted = 'false' AND "customer".ispublished = 'true';
END;
$$;


--
-- Name: getcustomerdetailsbyphone_ai(public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomerdetailsbyphone_ai(_phonenumber public.citext) RETURNS TABLE(id uuid, name public.citext, phoneno public.citext, phoneno2 public.citext, lastorderdate date, email public.citext, fb public.citext, twitter public.citext, instagram public.citext, notes public.citext, isblocked boolean, createdat timestamp without time zone, address json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select "customer".id,"customer".name,"customer".phoneno,"customer".phoneno2,"customer".Lastorderdate,"customer".Email,"customer".Fb,"customer".Twitter,"customer".Instagram,"customer".Notes,"customer".Isblocked,"customer".Createdat,
 to_json(
        Array(
            select
                to_json(
                    json_build_object(
                        'id',
                        customeraddress.addressid,
                        'name',
                        customeraddress.name,
						'latitude',
                        customeraddress.latitude,
						'longtitude',
                        customeraddress.longtitude,
						'streetname',
                        customeraddress.streetname,
						'buildingno',
                        customeraddress.buildingno,
						'departmentno',
                        customeraddress.departmentno,
						'details',
                        customeraddress.details,
						'notes',
                        customeraddress.notes
						)
					)
			       from customeraddress
					where customeraddress.customerid = "customer".id and customeraddress.isdeleted = 'false' 
			)
          ) address
from customer WHERE ("customer".phoneno like(concat('%',_phonenumber,'%')) OR "customer".phoneno2 like(concat('%',_phonenumber,'%'))) AND "customer".isdeleted = 'false' AND "customer".ispublished = 'true';
END;
$$;


--
-- Name: getcustomerdetailscompany(uuid[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomerdetailscompany(_customerid uuid[] DEFAULT NULL::uuid[]) RETURNS TABLE(customer json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select to_json(array(
select json_build_object( 
'customerid',cr.id,
'customername',cr.name,
'customeremail',cr.email,
'customerphone',cr.phoneno,
'channel', (select  array_agg(distinct nl.name) from namelookup nl 
inner join "order" ord on ord.ordersource = nl.id 
inner join customer crr on crr.id = ord.customerid where crr.id = cr.id),
'canceledorder', (select count(iscanceled) from "order" where iscanceled = true and customerid = cr.id limit 1),
'totalorderamount',(select sum(totalprice) from "order" where customerid = cr.id limit 1),  
'firstorderdate',(select createdat from "order" where "order".customerid = cr.id order by createdat  limit 1) ,
'lastorderdate',(select createdat from "order" where "order".customerid = cr.id order by createdat desc limit 1),
'numberoforders',(select count(ord.id) from "order" ord
inner join customer crr on crr.id = ord.customerid
where crr.id = cr.id limit 1),
'numberofpickuporders',(select count(id) from "order" where deliverytype ='3b9f60af-a9d4-4bae-b267-f73b48ff06fc' and customerid = cr.id limit 1),
'numberofdineinorders',(select count(id) from "order" where deliverytype ='7f78870b-910a-4ece-9a78-f630c4a8df65' and customerid = cr.id limit 1),
'numberofdeliveryorders',(select count(id) from "order" where deliverytype ='cfaca9cd-25cc-4e9a-a798-3d5496dde9f1' and customerid = cr.id limit 1), 
'favouritebranch',(select branch.name from "order"
inner join branch on "order".branchid = branch.id
where "order".customerid=  cr.id
group by (branch.name)
having count("order".branchid)=(
select max(mycount) from
(select count("order".branchid) mycount,branch.name from "order" inner join branch on "order".branchid = branch.id 
where "order".customerid = cr.id
group by (branch.name) 
) as favouritebranch) limit 1),
'favouriteitem',(select prd.name->>'en' from orderproduct ordprd 
inner join "order" ord on ordprd.orderid = ord.id
inner join product prd on prd.id = ordprd.productid
where ord.customerid = cr.id
group by (prd.name)
having count(ord.id) =(
select max(maxproductcount) from
(
select count(ord.id) maxproductcount,prd.name 
from "order" ord inner join orderproduct ordprd on ord.id = ordprd.orderid
inner join product prd on prd.id = ordprd.productid
where ord.customerid =  cr.id
group by (prd.name)) as favouriteitem) limit 1),
'isblocked',(select isblocked from customer cr
where cr.id =  cr.id limit 1),
'customertype',(SELECT CASE 
 WHEN (select "order".createdat::date
from customer crrr inner join "order" on crrr.id = "order".customerid
where crrr.id = cr.id
order by "order".createdat desc limit 1) < (select (now()::date) - interval '1 month')
               THEN 'absent'
  WHEN (select "order".createdat::date
from customer crrr inner join "order" on crrr.id = "order".customerid
where crrr.id = cr.id
order by "order".createdat limit 1) >= (select (now()::date) - interval '1 month')
               THEN 'new'
  WHEN (select "order".createdat::date
from customer crrr inner join "order" on crrr.id = "order".customerid
where crrr.id = cr.id
order by "order".createdat  limit 1) <= (select (now()::date) - interval '1 month') 
 and (select "order".createdat::date
from customer crrr inner join "order" on crrr.id = "order".customerid
where crrr.id = cr.id
order by "order".createdat desc limit 1) >= (select (now()::date) - interval '1 month')
               THEN 'normal'
       END as customerorderstatus),
'numberofcomplaints',(select count(crr.id) from orderfollowup ordfoloup
inner join customer crr on ordfoloup.customerid = crr.id
where crr.id = cr.id limit 1)    
) from customer cr
where cr.id =any(_customerid)
));
END;
$$;


--
-- Name: getcustomerheaderstatus(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomerheaderstatus(_companyid uuid) RETURNS TABLE(count bigint, status public.citext, statusnum bigint)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select coalesce(count(currentstatus),0),
       coalesce(rl.rname,l.name) as status, l.id as statusnum  from lookup l
                                           left join rlookup rl on (l.id =rl.sid and  rl.rid =_companyid)
                                           left join  restaurantcustomer  rc on (rc.currentstatus = l.id and  rc.restaurantid =_companyid)
group by currentstatus , rl.rname,l.name,l.id
order by l.id;
END
$$;


--
-- Name: getcustomeridsbyphonenumbers(public.citext[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomeridsbyphonenumbers(_phonenumbers public.citext[]) RETURNS uuid[]
    LANGUAGE plpgsql
    AS $$
DECLARE
    customerids uuid[];
    _phonenumber citext;
BEGIN
    customerids := ARRAY[]::uuid[];
    FOREACH _phonenumber IN ARRAY _phonenumbers
    LOOP
        customerids := customerids || ARRAY(
            SELECT id
            FROM customer
            WHERE (phoneno ILIKE concat('%', _phonenumber, '%') OR phoneno2 ILIKE concat('%', _phonenumber, '%'))
              AND isdeleted = 'false'
              AND ispublished = 'true'
        );
    END LOOP;
    RETURN customerids;
END;
$$;


--
-- Name: getcustomerinfobyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomerinfobyid(_id uuid) RETURNS TABLE(id uuid, name public.citext, customername public.citext, customerphone public.citext, phoneno public.citext, phoneno2 public.citext, lastorderdate date, email public.citext, fb public.citext, twitter public.citext, instagram public.citext, notes public.citext, isblocked boolean, createdat timestamp without time zone, verifycodetime timestamp without time zone, verifycode public.citext, fullphonenumber public.citext, address json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select "customer".id,"customer".name,"customer".name,"customer".phoneno,"customer".phoneno,"customer".phoneno2,"customer".Lastorderdate,"customer".Email,"customer".Fb,"customer".Twitter,"customer".Instagram,"customer".Notes,"customer".Isblocked,"customer".Createdat,"customer".verifycodetime,"customer".verifycode,"customer".fullphonenumber,
 to_json(
        Array(
            select
                to_json(
                    json_build_object(
                        'id',
                        customeraddress.addressid,
                        'name',
                        customeraddress.name,
						'englishcityname',
						getvaluelocalization('en' , 'cityName' ,address.cityname , 1),
						'arabiccityname',
						getvaluelocalization('ar' , 'cityName' ,address.cityname , 1),
						'englishareaname',
						getvaluelocalization('en' , 'areaname' ,address.areaname , 1),
						'arabicareaname',
						getvaluelocalization('ar' , 'areaname' ,address.areaname , 1),
						'englishsubareaname',
						getvaluelocalization('en' , 'subareaname' ,address.subareaname , 1),
						'arabicsubareaname',
						getvaluelocalization('ar' , 'subareaname' ,address.subareaname , 1)
						)
					)
			       from customeraddress
                   left join address on address.id = customeraddress.addressid
					where customeraddress.customerid = "customer".id
			        
			)
          ) address
from customer WHERE customer.id =_id AND "customer".isdeleted = 'false' AND "customer".ispublished = 'true';
END;
$$;


--
-- Name: getcustomerinfobyid_ai(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomerinfobyid_ai(_id uuid) RETURNS TABLE(id uuid, name public.citext, customername public.citext, customerphone public.citext, phoneno public.citext, phoneno2 public.citext, lastorderdate date, email public.citext, fb public.citext, twitter public.citext, instagram public.citext, notes public.citext, isblocked boolean, createdat timestamp without time zone, verifycode public.citext, address json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select "customer".id,"customer".name,"customer".name,"customer".phoneno,"customer".phoneno,"customer".phoneno2,"customer".Lastorderdate,"customer".Email,"customer".Fb,"customer".Twitter,"customer".Instagram,"customer".Notes,"customer".Isblocked,"customer".Createdat,"customer".verifycode,
 to_json(
        Array(
            select
                to_json(
                    json_build_object(
                        'id',
                        customeraddress.addressid,
                        'name',
                        customeraddress.name,
						'latitude',
                        customeraddress.latitude,
						'longtitude',
                        customeraddress.longtitude,
						'streetname',
                        customeraddress.streetname,
						'buildingno',
                        customeraddress.buildingno,
						'departmentno',
                        customeraddress.departmentno,
						'details',
                        customeraddress.details,
						'notes',
                        customeraddress.notes
						)
					)
			       from customeraddress
					where customeraddress.customerid = "customer".id and customeraddress.isdeleted = 'false' 
			)
          ) address
from customer WHERE customer.id =_id AND "customer".isdeleted = 'false' AND "customer".ispublished = 'true';
END;
$$;


--
-- Name: getcustomerinfobyidinterfaceapi(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomerinfobyidinterfaceapi(_id uuid) RETURNS TABLE(id uuid, name public.citext, customername public.citext, customerphone public.citext, phoneno public.citext, phoneno2 public.citext, lastorderdate date, email public.citext, fb public.citext, twitter public.citext, instagram public.citext, notes public.citext, isblocked boolean, createdat timestamp without time zone, verifycodetime timestamp without time zone, verifycode public.citext, fullphonenumber public.citext, address json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select "customer".id,"customer".name,"customer".name,"customer".phoneno,"customer".phoneno,"customer".phoneno2,"customer".Lastorderdate,"customer".Email,"customer".Fb,"customer".Twitter,"customer".Instagram,"customer".Notes,"customer".Isblocked,"customer".Createdat,"customer".verifycodetime,"customer".verifycode,"customer".fullphonenumber,
 to_json(
        Array(
            select
                to_json(
                    json_build_object(
                        'id',
                        customeraddress.addressid,
                        'name',
                        customeraddress.name,
						'latitude',
                        customeraddress.latitude,
						'longtitude',
                        customeraddress.longtitude,
						'streetname',
                        customeraddress.streetname,
						'buildingno',
                        customeraddress.buildingno,
						'departmentno',
                        customeraddress.departmentno,
						'details',
                        customeraddress.details
						)
					)
			       from customeraddress
                   left join address on address.id = customeraddress.addressid
					where customeraddress.customerid = "customer".id and customeraddress.isdeleted = false   
			)
          ) address
from customer WHERE customer.id =_id AND "customer".isdeleted = 'false' AND "customer".ispublished = 'true';
END;
$$;


--
-- Name: order; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public."order" (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    branchorderid public.citext,
    scheduled timestamp without time zone,
    deliverytype uuid,
    customerid uuid NOT NULL,
    branchid uuid NOT NULL,
    notes public.citext,
    totalprice numeric NOT NULL,
    deliveryprice numeric,
    deliveryaddress uuid,
    subtotalprice numeric NOT NULL,
    totalpreparingtime public.citext,
    deliverystatus public.citext,
    paymenttype public.citext NOT NULL,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext,
    ordersource uuid,
    channelid uuid,
    currentstatus uuid,
    iscanceled boolean DEFAULT false NOT NULL,
    iscomplained boolean DEFAULT false NOT NULL,
    isedited boolean DEFAULT false NOT NULL,
    isdeclined boolean DEFAULT false NOT NULL,
    reminder timestamp without time zone,
    numberofpeople public.citext,
    referencenumber jsonb DEFAULT '{}'::jsonb NOT NULL,
    isseen timestamp without time zone,
    price jsonb,
    deliverytrackinglink public.citext,
    responsetime jsonb,
    referencenumber2 public.citext,
    ishbekserial bigint NOT NULL,
    isready boolean DEFAULT false
);


--
-- Name: getcustomerlastorder(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomerlastorder(_customerid uuid) RETURNS SETOF public."order"
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 SELECT * from "order" where createdat = ( SELECT MAX (createdat) FROM "order");
END;
$$;


--
-- Name: getcustomerorderreport(uuid, timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomerorderreport(_companyid uuid, _fromtime timestamp without time zone DEFAULT NULL::timestamp without time zone, _totime timestamp without time zone DEFAULT NULL::timestamp without time zone) RETURNS TABLE(name public.citext, phoneno public.citext, firstorderdate public.citext, totalorder bigint, totalacceptedorder bigint, totaldeclineorder bigint, totalcanceledorder bigint, ordervalue numeric, callcenter bigint, talabat bigint, careem bigint, online bigint, mobile bigint, chatbot bigint)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select
    distinct c.name,
    c.phoneno,
    (select min(of.createdat)::citext from "order" of where (((_fromtime is null) or( _fromtime <= of.createdat)) and ((_totime is null) or( _totime >= of.createdat)) and of.customerid = c.id and of.branchid = any(select id from branch where companyid =_companyid ))),
    count(o.id) totalordercount,
    (select count(oa.id) from "order" oa where (((_fromtime is null) or( _fromtime <= oa.createdat)) and ((_totime is null) or( _totime >= oa.createdat)) and oa.customerid = c.id and oa.branchid = any(select id from branch where companyid =_companyid ) and oa.isdeclined != true)) accepted ,
    (select count(od.id) from "order" od where (((_fromtime is null) or( _fromtime <= od.createdat)) and ((_totime is null) or( _totime >= od.createdat)) and od.customerid = c.id and od.branchid = any(select id from branch where companyid =_companyid ) and od.isdeclined = true)) declined,
    (select count(od.id) from "order" od where (((_fromtime is null) or( _fromtime <= od.createdat)) and ((_totime is null) or( _totime >= od.createdat)) and od.customerid = c.id and od.branchid = any(select id from branch where companyid =_companyid ) and od.iscanceled = true))canceled,
    (select coalesce(sum(((price->>'Total')::numeric)),0)  from "order" od where (((_fromtime is null) or( _fromtime <= od.createdat)) and ((_totime is null) or( _totime >= od.createdat)) and od.customerid = c.id and od.branchid = any(select id from branch where companyid =_companyid and od.isdeclined != true and od.iscanceled != true))) totalvalue,
    (select count(oa.id)  from "order" oa where (((_fromtime is null) or( _fromtime <= oa.createdat)) and ((_totime is null) or( _totime >= oa.createdat)) and oa.customerid = c.id and oa.branchid = any(select id from branch where companyid =_companyid ) and (select nlk.name  from namelookup nlk where nlk.id = oa.ordersource )= 'callcenter')) callcenter,
    (select count(oa.id)  from "order" oa where (((_fromtime is null) or( _fromtime <= oa.createdat)) and ((_totime is null) or( _totime >= oa.createdat)) and oa.customerid = c.id and oa.branchid = any(select id from branch where companyid =_companyid ) and (select nlk.name  from namelookup nlk where nlk.id = oa.ordersource )= 'talabat'))talabat,
    (select count(oa.id)  from "order" oa where (((_fromtime is null) or( _fromtime <= oa.createdat)) and ((_totime is null) or( _totime >= oa.createdat)) and oa.customerid = c.id and oa.branchid = any(select id from branch where companyid =_companyid ) and (select nlk.name  from namelookup nlk where nlk.id = oa.ordersource )= 'careem')) careem,
    (select count(oa.id)  from "order" oa where (((_fromtime is null) or( _fromtime <= oa.createdat)) and ((_totime is null) or( _totime >= oa.createdat)) and oa.customerid = c.id and oa.branchid = any(select id from branch where companyid =_companyid ) and (select nlk.name  from namelookup nlk where nlk.id = oa.ordersource )= 'OnlineOrdering')) OnlineOrdering,
    (select count(oa.id)  from "order" oa where (((_fromtime is null) or( _fromtime <= oa.createdat)) and ((_totime is null) or( _totime >= oa.createdat)) and oa.customerid = c.id and oa.branchid = any(select id from branch where companyid =_companyid ) and (select nlk.name  from namelookup nlk where nlk.id = oa.ordersource )= 'MobileApp')) MobileApp,
    (select count(oa.id)  from "order" oa where (((_fromtime is null) or( _fromtime <= oa.createdat)) and ((_totime is null) or( _totime >= oa.createdat)) and oa.customerid = c.id and oa.branchid = any(select id from branch where companyid =_companyid ) and (select nlk.name  from namelookup nlk where nlk.id = oa.ordersource )= 'Chatbot')) Chatbot
    from "order" o
    join customer c on o.customerid = c.id
         where
             (((_fromtime is null) or( _fromtime <= o.createdat)) and
             ((_totime is null) or( _totime >= o.createdat)) and
             o.branchid = any(select id from branch where companyid = _companyid))
        group by  c.phoneno,c.name , c.id;

END;
$$;


--
-- Name: getcustomerorders(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomerorders(_customerid uuid, _branchid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, createdat timestamp without time zone, totalprice numeric, channelname public.citext, deliverytype public.citext, deliveryprice numeric, currentstatus public.citext, statuscolor public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select ord.id ,ord.createdat , ord.totalprice ,getlookupname(ord.channelid),getdeliveryname(ord.deliverytype) ,ord.deliveryprice, getorderstatus(ord.currentstatus) , getorderstatuscolor(ord.currentstatus) from "order" ord where isdeleted = false and ispublished=true and customerid = _customerid and ( ( _branchid is null ) or ( branchid = _branchid) );

END;
$$;


--
-- Name: getcustomerorderscompanyallchannel(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomerorderscompanyallchannel(_customerid uuid, _companyid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, branchname public.citext, createdat timestamp without time zone, iscanceled boolean, totalprice numeric, channelname public.citext, deliverytype public.citext, deliveryprice numeric, currentstatus public.citext, statuscolor public.citext, islast boolean, deliverycompany public.citext, customeraddress json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select ordr.id ,branch.name,ordr.createdat,ordr.iscanceled , ordr.totalprice ,getlookupname(ordr.ordersource),getdeliveryname(ordr.deliverytype) ,ordr.deliveryprice, getorderstatus(ordr.currentstatus) , getorderstatuscolor(ordr.currentstatus),ordstatus.islaststatus,(delcom.name::json->>'en')::citext,to_json(json_build_object(
'id' , ca.addressid,
'name',ca.name,
'streetname' , ca.streetname,
'buildingno' , ca.buildingno,
'departmentno' , ca.departmentno,
'details' , ca.details,
'latitude' , ca.latitude,
'longtitude' , ca.longtitude

))
from "order"
ordr 
inner join branch on ordr.branchid = branch.id
left join orderstatuspossibilities ordstatus ON ordstatus.id = ordr.currentstatus
left join deliverycompany delcom ON delcom.id = ordr.deliverytype
LEFT JOIN customeraddress ca ON ca.addressid = ordr.deliveryaddress
where ordr.isdeleted = false and ordr.ispublished=true and ordr.customerid = _customerid
and ( ( _companyid is null ) or ( branch.companyid =_companyid) ) order by ordr.createdat desc;

END;
$$;


--
-- Name: getcustomerorderscompanybychannel(uuid, public.citext, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomerorderscompanybychannel(_customerid uuid, _channel public.citext, _companyid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, branchname public.citext, createdat timestamp without time zone, iscanceled boolean, totalprice numeric, channelname public.citext, deliverytype public.citext, deliveryprice numeric, currentstatus public.citext, statuscolor public.citext, islast boolean, deliverycompany public.citext, customeraddress json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select ordr.id ,branch.name,ordr.createdat,ordr.iscanceled , ordr.totalprice ,getlookupname(ordr.ordersource),getdeliveryname(ordr.deliverytype) ,ordr.deliveryprice, getorderstatus(ordr.currentstatus) , getorderstatuscolor(ordr.currentstatus),ordstatus.islaststatus,(delcom.name::json->>'en')::citext,to_json(json_build_object(
'id' , ca.addressid,
'name',ca.name,
'streetname' , ca.streetname,
'buildingno' , ca.buildingno,
'departmentno' , ca.departmentno,
'details' , ca.details,
'latitude' , ca.latitude,
'longtitude' , ca.longtitude

))
from "order"
ordr 
inner join branch on ordr.branchid = branch.id
left join orderstatuspossibilities ordstatus ON ordstatus.id = ordr.currentstatus
left join deliverycompany delcom ON delcom.id = ordr.deliverytype
LEFT JOIN customeraddress ca ON ca.addressid = ordr.deliveryaddress
where ordr.ordersource = (select nlk.id from namelookup nlk where nlk.name = _channel) and ordr.isdeleted = false and ordr.ispublished=true and ordr.customerid = _customerid
and ( ( _companyid is null ) or ( branch.companyid =_companyid) ) order by ordr.createdat desc;

END;
$$;


--
-- Name: getcustomerpointlog(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomerpointlog(_customerid uuid, _companyid uuid) RETURNS TABLE(crid uuid, createdat timestamp without time zone, amount double precision, customerid uuid, restaurantid uuid)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY

    select pl.crid,
           pl.createdat,
           pl.amount,
           pl.customerid,
           pl.restaurantid from pointlog pl
    where pl.restaurantid = _companyid and pl.customerid = _customerid;


END
$$;


--
-- Name: getcustomerregistrationids(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomerregistrationids(_companyid uuid, _customerid uuid) RETURNS TABLE(registrationid public.citext, paymentbrand public.citext, bincountry public.citext, lastfourdigit public.citext, expirymonth public.citext, expiryyear public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select
        cpd.registrationid,
        cpd.paymentbrand,
        cpd.bincountry,
        cpd.lastfourdigit,
        cpd.expirymonth,
        cpd.expiryyear
    from customerpaymentdetail cpd where cpd.customerid = _customerid and cpd.companyid = _companyid and customerid != '00000000-0000-0000-0000-000000000000';
END;
$$;


--
-- Name: getcustomers(uuid, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomers(_companyid uuid, _status integer DEFAULT NULL::integer, _pagenumber integer DEFAULT 1, _pagesize integer DEFAULT 10) RETURNS TABLE(totalcount bigint, pagecount bigint, data json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select
    count(rc1.customerid) totalcount,
    ceil(count(rc1.customerid)/ _pagesize::decimal)::bigint pagecount,
    to_json(Array( select to_json(json_build_object(
                                  'customerid', rc.customerid,
                                  'customername',cd.name,
                                  'phonenumber',cd.phonenumber,
                                  'currentpoints',rc.currentpoints,
                                  'lastpointdate',(rc.lastpointdate ::date),
                                  --'currentstatus',rc.currentstatus,
                                  'lookupname',(select coalesce( rl.rname, l.name) from lookup l
                                                left join rlookup rl on (l.id = rl.sid and rl.rid = _companyid)
                                                                                   where l.id = rc.currentstatus
                                              ),
                                  --'rlookupname',rlk.rname,
                                  'channelname',(
                                  SELECT array_agg(distinct c.name) from pointlog
                                      join channellookup c on pointlog.channelid = c.id
                                                           where pointlog.crid = rc.id)
                              ))
from restaurantcustomer rc
        inner join lookup lk on rc.currentstatus = lk.id
        left join rlookup rlk on (lk.id = rlk.sid and rlk.rid = _companyid)
        inner join customerdetail cd on cd.customerid = rc.customerid
    where rc.restaurantid = _companyid and ((_status is null) or rc.currentstatus = _status)
    limit _pagesize
    OFFSET ((_pagenumber-1) * _pagesize)))
    from restaurantcustomer rc1  where rc1.restaurantid = _companyid;
END
$$;


--
-- Name: getcustomers(uuid, integer, integer, integer, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomers(_companyid uuid, _status integer DEFAULT NULL::integer, _pagenumber integer DEFAULT 1, _pagesize integer DEFAULT 10, _searchterm public.citext DEFAULT NULL::public.citext) RETURNS TABLE(totalcount bigint, pagecount bigint, data json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select
    count(rc1.customerid) totalcount,
    ceil(count(rc1.customerid)/ _pagesize::decimal)::bigint pagecount,
    to_json(Array( select to_json(json_build_object(
                                  'customerid', rc.customerid,
                                  'customername',cd.name,
                                  'phonenumber',cd.phoneno,
                                  'currentpoints',rc.currentpoints,
                                  'lastpointdate',(rc.lastpointdate ::date),
                                  --'currentstatus',rc.currentstatus,
                                  'lookupname',(select coalesce( rl.rname, l.name) from lookup l
                                                left join rlookup rl on (l.id = rl.sid and rl.rid = _companyid)
                                                                                   where l.id = rc.currentstatus
                                              ),
                                  --'rlookupname',rlk.rname,
                                  'channelname',(
                                  SELECT array_agg(distinct c.name) from pointlog
                                      join channellookup c on pointlog.channelid = c.id
                                                           where pointlog.crid = rc.id)
                              ))
from restaurantcustomer rc
        inner join lookup lk on rc.currentstatus = lk.id
        left join rlookup rlk on (lk.id = rlk.sid and rlk.rid = _companyid)
        inner join customer cd on cd.id = rc.customerid
    where rc.restaurantid = _companyid and ((_status is null) or rc.currentstatus = _status)
       and ( cd.name like concat('%',_searchterm,'%') or  cd.phoneno like concat('%',_searchterm,'%'))
        order by rc.createdat desc
    limit _pagesize
    OFFSET ((_pagenumber-1) * _pagesize)))
    from restaurantcustomer rc1  where rc1.restaurantid = _companyid;
END
$$;


--
-- Name: getcustomersbycompanyid(uuid, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomersbycompanyid(_id uuid DEFAULT NULL::uuid, _pagesize integer DEFAULT NULL::integer, _pagenumber integer DEFAULT NULL::integer) RETURNS TABLE(id uuid, nooforders bigint, noofcompalins bigint, name public.citext, phoneno public.citext, email public.citext, channel uuid, loyalitypoints numeric, isblocked boolean)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY

SELECT distinct("cus".id),COUNT("ord".id) as NoOfOrders,COUNT("ordfoll".id) as NoOfCompalins, "cus".name, "cus".phoneno,"cus".email,"cus".channel, "cus".loyalitypoints,"cus".isblocked
 FROM customer as cus inner JOIN "order" ord ON "ord".customerid = "cus".id inner join branch on branch.id = "ord".branchid inner join company on branch.companyid = company.id  LEFT JOIN branch bra ON "bra".id = "ord".branchid LEFT JOIN company com ON "com".id = "bra".companyid LEFT JOIN orderfollowup ordfoll ON ("ordfoll".id = "ord".id and "ordfoll".ordercase ='Complain') WHERE "com".id = _id  GROUP BY "cus".id LIMIT _pagesize OFFSET ((_pagenumber-1) * _pagesize);

 END;
$$;


--
-- Name: getcustomerscompanydetailsbyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomerscompanydetailsbyid(_id uuid DEFAULT NULL::uuid) RETURNS TABLE(allcustomers bigint, newcustomers bigint, loyalcustomers bigint, absentcustomers bigint, complains bigint)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY

select COUNT(DISTINCT "cus".id) as allcustomers
,count(DISTINCT "cus".id) FILTER (WHERE "cus".createdat >= current_date at time zone 'UTC' - interval '1 month') as newcustomers
,count(DISTINCT "cus".id) FILTER (WHERE "cus".loyalitypoints > 0) as loyalcustomers
,count(DISTINCT "cus".id) FILTER (WHERE "cus".createdat < current_date at time zone 'UTC' - interval '1 month') as absentcustomers
,count(DISTINCT "ordfoll".id) FILTER (WHERE "ordfoll".ordercase = 'Complain') as complains
FROM customer cus LEFT JOIN "order" ord ON "ord".customerid = "cus".id
LEFT JOIN orderfollowup ordfoll ON "ordfoll".id = "ord".id
LEFT JOIN branch bra ON "bra".id = "ord".branchid
LEFT JOIN company com ON "com".id = "bra".companyid
WHERE "com".id = _id;
 END;
$$;


--
-- Name: getcustomerstatuslog(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomerstatuslog(_customerid uuid, _companyid uuid) RETURNS TABLE(crid uuid, status integer, previousstatus integer, createdat timestamp without time zone, customerid uuid, restaurantid uuid)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY

    select sl.crid,
           sl.status,
           sl.previousstatus,
           sl.createdat,
           sl.customerid,
           sl.restaurantid from statuslog sl
    where sl.restaurantid = _companyid and sl.customerid = _customerid;


END
$$;


--
-- Name: getcustomrdetailsbycompanyidandcustomerid(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getcustomrdetailsbycompanyidandcustomerid(_customerid uuid, _companyid uuid) RETURNS TABLE(id uuid, name public.citext, phoneno public.citext, countrycode public.citext, phoneno2 public.citext, lastorderdate date, email public.citext, fb public.citext, twitter public.citext, instagram public.citext, notes public.citext, createdat timestamp without time zone)
    LANGUAGE plpgsql
    AS $$

BEGIN
RETURN QUERY

select c.id,
       c.name,
       c.phoneno,
       c.countrycode,
       c.phoneno2,
       c.Lastorderdate,
       c.Email,
       c.Fb,
       c.Twitter,
       c.Instagram,
       c.Notes,
       c.Createdat
from restaurantcustomer rc inner join customer c on c.id = rc.customerid
WHERE  _customerid =  c.id and rc.restaurantid = _companyid AND c.isdeleted = 'false' AND c.ispublished = 'true';
END;
$$;


--
-- Name: getdailyreportfordashboard(uuid[], uuid[], timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getdailyreportfordashboard(_branchids uuid[], _channels uuid[] DEFAULT NULL::uuid[], _from timestamp without time zone DEFAULT NULL::timestamp without time zone, _to timestamp without time zone DEFAULT NULL::timestamp without time zone) RETURNS TABLE(hour public.citext, avgamount double precision, avgcount double precision)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN query
 select logicbase.dayname ,
        sum/(select count from daycount(_dayname := logicbase.dayname, _from := _from, _to := _to))::double precision,
        count/(select count from daycount(_dayname := logicbase.dayname, _from := _from, _to := _to))::double precision
 from ( select to_char(createdat::date, 'Day')::citext as dayname,
        sum(totalprice) sum,
        count(id)::double precision count
 from "order"
where
 "order".branchid  =any(_branchids)
and ((_channels is null) or ("order".ordersource=any(_channels)))
and ((_from is null) or ("order".createdat >= (to_char(_from::date,'YYYY-MM-DD 00:00:00')::timestamp)))
and ((_to is null) or ("order".createdat <= _to::date+'1 day' ::interval -'1 second' ::interval))
group by to_char(createdat::date, 'Day')) logicbase;
END;
$$;


--
-- Name: getdashboardchart(public.citext, uuid[], timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getdashboardchart(_reporttype public.citext, _branchids uuid[], _from timestamp without time zone DEFAULT NULL::timestamp without time zone, _to timestamp without time zone DEFAULT NULL::timestamp without time zone) RETURNS TABLE(totalorder bigint, totalprice numeric, totaldeliveryprice numeric, subtotalprice numeric, totaliscanceled bigint, totaliscomplained bigint, totalisdeclined bigint, data json)
    LANGUAGE plpgsql
    AS $$
BEGIN
 -- getting totalvalue and count hourly for branch 
if(_reporttype = 'hourly') then return query 
select COUNT("order".id),SUM("order".totalprice),SUM("order".deliveryprice),SUM("order".subtotalprice)
,count( case when "order".iscanceled = true then "order".iscanceled end)
,count( case when "order".iscomplained = true then "order".iscomplained end)
,count( case when "order".isdeclined = true then "order".isdeclined end) , to_json( Array( select to_json(json_build_object(
 'labels',concat(to_char(to_char(ord.createdat,'YYYY-MM-DD HH24:00:00')::timestamp,'HH AM '),to_char(to_char(ord.createdat,'YYYY-MM-DD HH24:00:00')::timestamp,'Dy')),
 'orderscount',count(ord.id),
 'ordersamount',sum(ord.totalprice)
))from "order" ord 
where branchid =any(_branchids)
GROUP BY(to_char(createdat,'YYYY-MM-DD HH24:00:00')::timestamp) 
order by (to_char(createdat,'YYYY-MM-DD HH24:00:00')::timestamp) desc limit 24))
from "order"
where branchid =any(_branchids) 
and ((_from is null) or ("order".createdat >= _from))
and ((_to is null) or ("order".createdat <= _to));

-- getting totalvalue and count Daily for branch 
else if(_reporttype = 'daily') then return query
select COUNT("order".id),SUM("order".totalprice),SUM("order".deliveryprice),SUM("order".subtotalprice)
,count( case when "order".iscanceled = true then "order".iscanceled end)
,count( case when "order".iscomplained = true then "order".iscomplained end)
,count( case when "order".isdeclined = true then "order".isdeclined end) , to_json( Array( select to_json(json_build_object(
 'labels',concat(to_char(ord.createdat::date,'Dy '),to_char(ord.createdat::date,'DD-Mon ')),
 'orderscount',count(ord.id),
 'ordersamount',sum(ord.totalprice)
))from "order" ord 
where branchid =any(_branchids)
GROUP BY(createdat::date) 
order by (createdat::date) desc limit 7))
from "order"
where branchid  =any(_branchids) 
and ((_from is null) or ("order".createdat >=  to_char(_from,'YYYY-MM-DD 00:00:00')::timestamp))
and ((_to is null) or ("order".createdat <= to_char(_to,'YYYY-MM-DD 23:59:59')::timestamp));

-- getting totalvalue and count Weekly for branch 
else if(_reporttype = 'weekly')  then return query
select COUNT("order".id),SUM("order".totalprice),SUM("order".deliveryprice),SUM("order".subtotalprice)
,count( case when "order".iscanceled = true then "order".iscanceled end)
,count( case when "order".iscomplained = true then "order".iscomplained end)
,count( case when "order".isdeclined = true then "order".isdeclined end) , to_json( Array( select to_json(json_build_object(
 'labels',concat('W',substring(to_char(createdat,'YYYY-MM-W') from 9),' ',to_char(to_char(createdat,'YYYY-MM-W')::timestamp,'Mon')),
 'orderscount',count(ord.id),
 'ordersamount',sum(ord.totalprice)
))from "order" ord 
where branchid =any(_branchids)
GROUP BY(to_char(ord.createdat,'YYYY-MM-W')) 
order by (to_char(ord.createdat,'YYYY-MM-W')) desc limit 5))
from "order"
where branchid  =any(_branchids) 
and ((_from is null) or ("order".createdat >=  to_char(_from,'YYYY-MM-DD 00:00:00')::timestamp))
and ((_to is null) or ("order".createdat <= to_char(_to,'YYYY-MM-DD 23:59:59')::timestamp));

-- getting totalvalue and count Monthly for branch 
else if(_reporttype = 'monthly') then return query
select COUNT("order".id),SUM("order".totalprice),SUM("order".deliveryprice),SUM("order".subtotalprice)
,count( case when "order".iscanceled = true then "order".iscanceled end)
,count( case when "order".iscomplained = true then "order".iscomplained end)
,count( case when "order".isdeclined = true then "order".isdeclined end) , to_json( Array( select to_json(json_build_object(
 'labels',concat(to_char(to_char(ord.createdat,'YYYY-MM-1')::timestamp,'Mon '),to_char(to_char(ord.createdat,'YYYY-MM-1')::timestamp,'YYYY')),
 'orderscount',count(ord.id),
 'ordersamount',sum(ord.totalprice)
))from "order" ord 
where branchid =any(_branchids)
GROUP BY(to_char(ord.createdat,'YYYY-MM-1')::timestamp) 
order by (to_char(ord.createdat,'YYYY-MM-1')::timestamp) desc limit 12))
from "order"
where branchid  =any(_branchids)  
and ((_from is null) or ("order".createdat >= to_char(_from,'YYYY-MM-1')::timestamp))
and ((_to is null) or ("order".createdat <= to_char(_to,'YYYY-MM-1')::timestamp + INTERVAL '1 MONTH - 1 day'))
;

-- getting totalvalue and count Yearly for branch 
else if (_reporttype = 'yearly') then return query
select COUNT("order".id),SUM("order".totalprice),SUM("order".deliveryprice),SUM("order".subtotalprice)
,count( case when "order".iscanceled = true then "order".iscanceled end)
,count( case when "order".iscomplained = true then "order".iscomplained end)
,count( case when "order".isdeclined = true then "order".isdeclined end) , to_json( Array( select to_json(json_build_object(
 'labels',to_char(to_char(ord.createdat,'YYYY-1-1')::timestamp,'YYYY'),
 'orderscount',count(ord.id),
 'ordersamount',sum(ord.totalprice)
))from "order" ord 
where branchid =any(_branchids)

GROUP BY(to_char(ord.createdat,'YYYY-1-1')::timestamp) 
order by (to_char(ord.createdat,'YYYY-1-1')::timestamp) desc limit 2))
from "order"
where branchid =any(_branchids) 
and ((_from is null) or ("order".createdat >= to_char(_from,'YYYY-01-01')::timestamp))
and ((_to is null) or ("order".createdat <= to_char(_to,'YYYY-12-31')::timestamp));
end if;
end if;
end if;
end if;
end if;
END
$$;


--
-- Name: getdashboardlinechart(public.citext, uuid[], timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getdashboardlinechart(_reporttype public.citext, _branchids uuid[], _from timestamp without time zone DEFAULT NULL::timestamp without time zone, _to timestamp without time zone DEFAULT NULL::timestamp without time zone) RETURNS TABLE(labels public.citext, count bigint, branchname public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
-- getting totalvalue and count hourly for branch 
if(_reporttype = 'hourly') then return query 
select (to_char(ord.createdat,'YYYY-MM-DD HH24:00:00')::timestamp)::citext ,count(ord.id),branch.name from "order" ord
inner join branch on branch.id = ord.branchid 
--where branchid  =any(_branchids) 
--and ((_from is null) or (ord.createdat >= _from))
--and ((_to is null) or (ord.createdat <= _to))
group by (branch.name,to_char(ord.createdat,'YYYY-MM-DD HH24:00:00')::timestamp) 
order by (to_char(ord.createdat,'YYYY-MM-DD HH24:00:00')::timestamp , count(branch.id)) desc;

-- getting totalvalue and count Daily for branch 
else if(_reporttype = 'daily') then return query
select (ord.createdat::date)::citext ,count(ord.id),branch.name from "order" ord
inner join branch on branch.id = ord.branchid 
where ord.branchid  =any(_branchids) 
and ((_from is null) or (ord.createdat >=  to_char(_from,'YYYY-MM-DD 00:00:00')::timestamp))
and ((_to is null) or (ord.createdat <= to_char(_to,'YYYY-MM-DD 23:59:59')::timestamp))
group by (branch.name,ord.createdat::date) 
order by (ord.createdat::date , count(branch.id)) desc;

-- getting totalvalue and count Weekly for branch 
else if(_reporttype = 'weekly')  then return query
select concat('W',substring(to_char(ord.createdat,'YYYY-MM-W') from 9),' ',to_char(to_char(ord.createdat,'YYYY-MM-W')::timestamp,'Mon'))::citext,count(ord.id),branch.name  from "order" ord
inner join branch on branch.id = ord.branchid 
where ord.branchid  =any(_branchids) 
and ((_from is null) or (ord.createdat >=  to_char(_from,'YYYY-MM-DD 00:00:00')::timestamp))
and ((_to is null) or (ord.createdat <= to_char(_to,'YYYY-MM-DD 23:59:59')::timestamp))
GROUP BY(branch.name,to_char(ord.createdat,'YYYY-MM-W')) 
order by (to_char(ord.createdat,'YYYY-MM-W') , count(branch.id)) desc;



-- getting totalvalue and count Monthly for branch 
else if(_reporttype = 'monthly') then return query
select concat(to_char(to_char(ord.createdat,'YYYY-MM-1')::timestamp,'Mon '),to_char(to_char(ord.createdat,'YYYY-MM-1')::timestamp,'YYYY'))::citext,count(ord.id),branch.name from "order" ord
inner join branch on branch.id = ord.branchid 
where ord.branchid  =any(_branchids)  
and ((_from is null) or (ord.createdat >= to_char(_from,'YYYY-MM-1')::timestamp))
and ((_to is null) or (ord.createdat <= to_char(_to,'YYYY-MM-1')::timestamp + INTERVAL '1 MONTH - 1 day'))
GROUP BY(branch.name,to_char(ord.createdat,'YYYY-MM-1')::timestamp) 
order by (to_char(ord.createdat,'YYYY-MM-1')::timestamp , count(branch.id)) desc;

-- getting totalvalue and count Yearly for branch 
else if (_reporttype = 'yearly') then return query
select to_char(to_char(ord.createdat,'YYYY-1-1')::timestamp,'YYYY')::citext,count(ord.id),branch.name from "order" ord
inner join branch on branch.id = ord.branchid 
where branchid =any(_branchids) 
and ((_from is null) or (ord.createdat >= to_char(_from,'YYYY-01-01')::timestamp))
and ((_to is null) or (ord.createdat <= to_char(_to,'YYYY-12-31')::timestamp))
GROUP BY(branch.name,to_char(ord.createdat,'YYYY-1-1')::timestamp) 
order by (to_char(ord.createdat,'YYYY-1-1')::timestamp , count(branch.id)) desc;
end if;
end if;
end if;
end if;
end if;
END
$$;


--
-- Name: delayedorders; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.delayedorders (
    orderid uuid NOT NULL,
    actiontime timestamp without time zone
);


--
-- Name: getdelayedorders(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getdelayedorders() RETURNS SETOF public.delayedorders
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select delayedorders.* from delayedorders inner join "order" on "order".id = delayedorders.orderid order by "order".createdat desc ;
END
$$;


--
-- Name: getdelayedordersbybranchid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getdelayedordersbybranchid(_branchid uuid DEFAULT NULL::uuid) RETURNS SETOF public.delayedorders
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select * from delayedorders where orderid =any(select id from "order" where branchid = _branchid);
END;
$$;


--
-- Name: getdeletedimages(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getdeletedimages() RETURNS TABLE(deletedimagepath public.citext, id uuid)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
        select REPLACE(product.imagepath, 'https://hfiles.ishbek.com/', '')::citext as deletedimagepath, product.id
        from product
        where isdeleted = 't'
          and ispublished = 'f'
          and createdby != 'Moayyad'
          and imagepath is not null;
END;
$$;


--
-- Name: getdeliverycompanies(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getdeliverycompanies() RETURNS TABLE(id uuid, name public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select deliverycompany.id ,
 trim(both '"' from  (deliverycompany.name->'en')::citext)::citext from deliverycompany where isdeleted = false and ispublished = true;
END;
$$;


--
-- Name: getdeliverycompaniesfordeliveryservice(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getdeliverycompaniesfordeliveryservice() RETURNS TABLE(id uuid, name public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY

select branchdelivery.id ,concat((deliverycompany.name->>'en')::citext, ' - ' , company.name, ' - ' ,branch.name)::citext
from branchdelivery
inner join deliverycompany on deliverycompany.id = branchdelivery.deliverycompanyid
inner join branch on branch.id = branchdelivery.branchid
inner join company on company.id = branch.companyid;

END;
$$;


--
-- Name: deliverycompany; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.deliverycompany (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    name jsonb NOT NULL,
    isaggregated boolean NOT NULL,
    opentime timestamp without time zone,
    closetime timestamp without time zone,
    currency public.citext,
    addressid uuid NOT NULL,
    phonenumber public.citext NOT NULL,
    isavailable boolean DEFAULT true,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext,
    logo public.citext,
    website public.citext,
    haspricelist boolean DEFAULT true
);


--
-- Name: getdeliverycompanybyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getdeliverycompanybyid(_id uuid DEFAULT NULL::uuid) RETURNS SETOF public.deliverycompany
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select * from deliverycompany where id = _id and isdeleted = false and ispublished = true;
END;
$$;


--
-- Name: getdeliverycompanyforbranch(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getdeliverycompanyforbranch(_branchid uuid) RETURNS TABLE(id uuid, name public.citext, maxdistance public.citext, priority integer, deliverycompanyid uuid, deliverycompanyname public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select bd.id , b.name , bd.maxdistance::citext, bd.priority , bd.deliverycompanyid , (dc.name->>'en')::citext from branchdelivery bd
inner join deliverycompany dc on bd.deliverycompanyid = dc.id
inner join branch b on b.id = bd.branchid
where bd.branchid = _branchid;
END;
$$;


--
-- Name: getdeliverycompanyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getdeliverycompanyid(_id uuid DEFAULT NULL::uuid) RETURNS SETOF uuid
    LANGUAGE plpgsql
    AS $$
BEGIN
if((select COUNT(deliverycompany.id)  from deliverycompany where deliverycompany.id = _id)>0)
then
  return query select deliverycompany.id  from deliverycompany where deliverycompany.id = _id;
else
 return query select namelookup.id from namelookup where namelookup.id = (select namelookup.id from namelookup where namelookup.id = _id);
end if;
END;
$$;


--
-- Name: getdeliverycompanyname(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getdeliverycompanyname(_id uuid DEFAULT NULL::uuid) RETURNS TABLE(name public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
if((select COUNT(deliverycompany.id)  from deliverycompany where deliverycompany.id = _id)>0)
then
  return query select (deliverycompany.name->>'en')::citext from deliverycompany where deliverycompany.id = _id;
else
 return query select namelookup.name from namelookup where namelookup.id = (select namelookup.id from namelookup where namelookup.id = _id);
end if;
END;
$$;


--
-- Name: getdeliverycompanynameforpos(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getdeliverycompanynameforpos(_id uuid DEFAULT NULL::uuid) RETURNS TABLE(name public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
if((select COUNT(deliverycompany.id)  from deliverycompany where deliverycompany.id = _id)>0)
then
  return query select (deliverycompany.name->>'en')::citext from deliverycompany where deliverycompany.id = _id;
else
 return query select namelookup.name from namelookup where namelookup.id = (select namelookup.id from namelookup where namelookup.id = _id);
end if;
END;
$$;


--
-- Name: getdeliverycompanynameforreport(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getdeliverycompanynameforreport(_id uuid DEFAULT NULL::uuid) RETURNS TABLE(name public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
if((select COUNT(deliverycompany.id)  from deliverycompany where deliverycompany.id = _id)>0)
then
  return query select ('delivery')::citext;
else
 return query select namelookup.name from namelookup where namelookup.id = (select namelookup.id from namelookup where namelookup.id = _id);
end if;
END;
$$;


--
-- Name: getdeliverycompanyreport(uuid, timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getdeliverycompanyreport(_companyid uuid, _fromtime timestamp without time zone DEFAULT NULL::timestamp without time zone, _totime timestamp without time zone DEFAULT NULL::timestamp without time zone) RETURNS TABLE(companyname public.citext, deliveryprice public.citext, numberoforders bigint, totaldelivery double precision)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select (dc.name->>'en')::citext as companyname,
           (o.price->>'DeliveryPrice')::citext as DeliveryPrice,
           count(o.id) as numberoforders,
           ((o.price->>'DeliveryPrice')::double precision * (count(o.id))::double precision) as totaldelivery
       from "order" o inner join deliverycompany dc on dc.id = o.deliverytype
       where o.branchid = any(select id from branch where companyid = _companyid) and o.isdeclined is false and o.iscanceled is false
       and  ((_fromtime is null) or( _fromtime <= o.createdat))
       and ((_totime is null) or( _totime >= o.createdat))
group by (o.price,o.price->>'DeliveryPrice'), dc.name
union
select concat((select name from company where id = _companyid),'Delivery')::citext companyname,
       (o.price->>'DeliveryPrice')::citext as DeliveryPrice,
       (count(o.id)) as numberoforders,
       ((o.price->>'DeliveryPrice')::double precision * (count(o.id))::double precision) as totalDelivery
from "order" o where o.deliverytype = 'ebf23c72-7003-4804-b981-727ef616e1d5' and o.branchid = any(select id from branch where companyid = _companyid) and o.isdeclined is false and o.iscanceled is false
                and  ((_fromtime is null) or( _fromtime <= o.createdat))
                and ((_totime is null) or( _totime >= o.createdat))
               group by (o.price->>'DeliveryPrice')
order by companyname;

END;
$$;


--
-- Name: getdeliverydashboartreportpie(uuid[], uuid[], timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getdeliverydashboartreportpie(_branchids uuid[], _channels uuid[] DEFAULT NULL::uuid[], _from timestamp without time zone DEFAULT NULL::timestamp without time zone, _to timestamp without time zone DEFAULT NULL::timestamp without time zone) RETURNS TABLE(data json)
    LANGUAGE plpgsql
    AS $$
BEGIN
return query 
 select json_build_object(
			  'delivery', (select count(ord.id) from "order" ord where ord.deliverytype not in ('3b9f60af-a9d4-4bae-b267-f73b48ff06fc','7f78870b-910a-4ece-9a78-f630c4a8df65') and branchid  =any(_branchids) 
and ((_channels is null) or (ord.ordersource=any(_channels)))
and ((_from is null) or (ord.createdat >=  to_char(_from,'YYYY-MM-DD 00:00:00')::timestamp))
and ((_to is null) or (ord.createdat <= to_char(_to,'YYYY-MM-DD 23:59:59')::timestamp))) , 
			  'pickup',(select count(ord.id) from "order" ord where ord.deliverytype = '3b9f60af-a9d4-4bae-b267-f73b48ff06fc'and branchid  =any(_branchids)
and ((_channels is null) or (ord.ordersource=any(_channels)))
and ((_from is null) or (ord.createdat >=  to_char(_from,'YYYY-MM-DD 00:00:00')::timestamp))
and ((_to is null) or (ord.createdat <= to_char(_to,'YYYY-MM-DD 23:59:59')::timestamp))) ,
			  'dinein',
	(select	count(ord.id) from "order" ord where ord.deliverytype='7f78870b-910a-4ece-9a78-f630c4a8df65'and branchid  =any(_branchids) 
and ((_channels is null) or (ord.ordersource=any(_channels)))
and ((_from is null) or (ord.createdat >=  to_char(_from,'YYYY-MM-DD 00:00:00')::timestamp))
and ((_to is null) or (ord.createdat <= to_char(_to,'YYYY-MM-DD 23:59:59')::timestamp)))
);
END
$$;


--
-- Name: getdeliveryname(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getdeliveryname(_id uuid DEFAULT NULL::uuid) RETURNS TABLE(name public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select namelookup.name from namelookup where id = _id and isdeleted = false and ispublished = true;
END;
$$;


--
-- Name: getdiscountbyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getdiscountbyid(_id uuid) RETURNS TABLE(id uuid, description public.citext, name public.citext, fromtime timestamp without time zone, totime timestamp without time zone, fromdate timestamp without time zone, todate timestamp without time zone, daysofweek integer[], productids uuid[], categoryids json, channelids uuid[], branchids uuid[], customerids uuid[], discountvalue numeric, discounttype public.citext, attributeids uuid[], promocode public.citext, maxdiscountprice numeric, ispercentage boolean, discountpercent integer, mindiscountquantity integer, mindiscountprice numeric, branch json, product json, namelookup json, attribute json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
   Select discount.id,discount.description, discount.name, discount.fromtime ,discount.totime,discount.fromdate,discount.todate,discount.daysofweek,discount.productids,getcategoriesname(discount.categoryids),discount.channelids,discount.branchids,discount.customerids,discount.discountvalue,discount.discounttype,discount.attributeids,discount.promocode,discount.maxdiscountprice,discount.ispercentage,discount.discountpercent,discount.mindiscountquantity,discount.mindiscountprice,
to_json(Array(select to_json(json_build_object('name',branch.name,'id',branch.id)) from branch where branch.id = any(discount.branchids))),
to_json(Array(select to_json( json_build_object('name',product.name , 'id',product.id)) from  product  where product.id = any(discount.productids))),
to_json(Array(select to_json( json_build_object('name',namelookup.name , 'id',namelookup.id)) from namelookup where namelookup.id = any(discount.channelids))),
to_json(Array(select to_json( json_build_object('name',productattribute.name , 'id',productattribute.id)) from  productattribute  where productattribute.id = any(discount.attributeids)))

from discount where discount.isdeleted = false and discount.id = _id;
END;
$$;


--
-- Name: getdiscountcarttotal(uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getdiscountcarttotal(_branchid uuid, _channel public.citext) RETURNS TABLE(id uuid, value numeric, minquantity integer, maxvalue numeric, minprice numeric, priority integer, ispercentage boolean, createdat timestamp without time zone, type public.citext)
    LANGUAGE plpgsql
    AS $$
    BEGIN
    RETURN QUERY
        select dinfo.id, dinfo.value, dinfo.minquantity, dinfo.maxvalue,dinfo.minprice, dinfo.priority, dinfo.ispercentage,dinfo.createdat,dinfo.type from discountinfo dinfo
               inner join discountchannel disch on disch.discountid = dinfo.id
               inner join discountbranch disbr on disbr.discountid = dinfo.id
        where
 ((case when (dinfo.availablefrom::time < dinfo.availableto::time) then
                 case when ((dinfo.availablefrom::time <= ((now())::time + interval '3 hour')) and (dinfo.availableto::time >= (now())::time))  then 1 else 0 end
             else
                 case when ((dinfo.availableto::time <= (now())::time + interval '3 hour') and (dinfo.availablefrom::time >= (now())::time))  then 0 else 1 end
		   end) =1)            and
            ((dinfo.availablefrom)::date) <= ((now())::date)  and ((dinfo.availableto)::date) >= ((now())::date)
            and
            (select to_char ( (now()), 'D'  )::integer) = any (dinfo.daysofweek)
            and disch.channelid = (select nlm.id from namelookup nlm where nlm.name = _channel)
            and disbr.branchid = _branchid
            and dinfo.ispublished is true
            and dinfo.isdeleted is not true
            and dinfo.isavailable is true
            and dinfo.type = 'Total' order by dinfo.priority desc,dinfo.createdat desc LIMIT 1;
    END;
$$;


--
-- Name: getdiscountdelivery(uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getdiscountdelivery(_branchid uuid, _channel public.citext) RETURNS TABLE(id uuid, value numeric, minquantity integer, maxvalue numeric, minprice numeric, priority integer, ispercentage boolean, createdat timestamp without time zone, type public.citext)
    LANGUAGE plpgsql
    AS $$
    BEGIN
    RETURN QUERY
        select dinfo.id, dinfo.value, dinfo.minquantity, dinfo.maxvalue,dinfo.minprice, dinfo.priority, dinfo.ispercentage,dinfo.createdat,dinfo.type from discountinfo dinfo
               left join discountchannel disch on disch.discountid = dinfo.id
               left join discountbranch disbr on disbr.discountid = dinfo.id
        where
 ((case when (dinfo.availablefrom::time < dinfo.availableto::time) then
                 case when ((dinfo.availablefrom::time <= ((now())::time + interval '3 hour')) and (dinfo.availableto::time >= (now())::time))  then 1 else 0 end
             else
                 case when ((dinfo.availableto::time <= (now())::time + interval '3 hour') and (dinfo.availablefrom::time >= (now())::time))  then 0 else 1 end
		   end) =1)            and
            ((dinfo.availablefrom)::date) <= ((now())::date)  and ((dinfo.availableto)::date) >= ((now())::date)
            and
            (select to_char ( (now()), 'D'  )::integer) = any (dinfo.daysofweek)
            and disch.channelid = (select nlm.id from namelookup nlm where nlm.name = _channel)
            and disbr.branchid = _branchid
            and dinfo.ispublished is true
            and dinfo.isdeleted is not true
            and dinfo.isavailable is true
            and dinfo.type = 'Delivery' order by dinfo.priority desc,dinfo.createdat desc LIMIT 1;
    END;
$$;


--
-- Name: getdiscountinfo(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getdiscountinfo(_branchid uuid, _channelid uuid) RETURNS TABLE(id uuid, value numeric, priority integer, ispercentage boolean, type public.citext)
    LANGUAGE plpgsql
    AS $$
    BEGIN
 RETURN QUERY 
 select dinfo.id, dinfo.value, dinfo.minquantity, dinfo.maxvalue,dinfo.minprice, dinfo.priority, dinfo.ispercentage,dinfo.createdat,dinfo.type from discountinfo dinfo
               left join discountchannel disch on disch.discountid = dinfo.id
               left join discountbranch disbr on disbr.discountid = dinfo.id
        where
 ((case when (dinfo.availablefrom::time < dinfo.availableto::time) then
                 case when ((dinfo.availablefrom::time <= ((now())::time + interval '3 hour')) and (dinfo.availableto::time >= (now())::time))  then 1 else 0 end
             else
                 case when ((dinfo.availableto::time <= (now())::time + interval '3 hour') and (dinfo.availablefrom::time >= (now())::time))  then 0 else 1 end
		   end) =1)            and
            ((dinfo.availablefrom)::date) <= ((now())::date)  and ((dinfo.availableto)::date) >= ((now())::date)
            and
            (select to_char ( (now()), 'D'  )::integer) = any (dinfo.daysofweek)
            and disch.channelid = _channelid
            and disbr.branchid = _branchid
            and dinfo.ispublished is true
            and dinfo.isdeleted is not true
            and dinfo.isavailable is true
            and (dinfo.type = 'Delivery' or dinfo.type = 'Total') order by dinfo.priority desc,dinfo.createdat desc LIMIT 1;
            
           END;
$$;


--
-- Name: getdiscountinfo(uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getdiscountinfo(_branchid uuid, _channel public.citext) RETURNS TABLE(id uuid, value numeric, priority integer, ispercentage boolean, type public.citext)
    LANGUAGE plpgsql
    AS $$
    BEGIN
 RETURN QUERY 
 select dinfo.id, dinfo.value,dinfo.priority, dinfo.ispercentage,dinfo.type from discountinfo dinfo
               left join discountchannel disch on disch.discountid = dinfo.id
               left join discountbranch disbr on disbr.discountid = dinfo.id
        where
 ((case when (dinfo.availablefrom::time < dinfo.availableto::time) then
                 case when ((dinfo.availablefrom::time <= ((now())::time + interval '3 hour')) and (dinfo.availableto::time >= (now())::time))  then 1 else 0 end
             else
                 case when ((dinfo.availableto::time <= (now())::time + interval '3 hour') and (dinfo.availablefrom::time >= (now())::time))  then 0 else 1 end
		   end) =1)            and
            ((dinfo.availablefrom)::date) <= ((now())::date)  and ((dinfo.availableto)::date) >= ((now())::date)
            and
            (select to_char ( (now()), 'D'  )::integer) = any (dinfo.daysofweek)
            and disch.channelid = (select nlk.id from namelookup nlk where nlk.name =_channel)
            and disbr.branchid = _branchid
            and dinfo.ispublished is true
            and dinfo.isdeleted is not true
            and dinfo.isavailable is true
            and (dinfo.type = 'Delivery' or dinfo.type = 'Total') order by dinfo.priority desc,dinfo.createdat desc LIMIT 1;
            
           END;
$$;


--
-- Name: getdiscountinfobyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getdiscountinfobyid(_discountid uuid) RETURNS TABLE(id uuid, name public.citext, type public.citext, ispercentage boolean, daysofweek integer[], description public.citext, value numeric, maxvalue numeric, minquantity integer, minprice numeric, promorcode public.citext, availablefrom timestamp without time zone, availableto timestamp without time zone, priority integer, descriptionlanguage jsonb, discountbranch json, discountproduct json, discountattribute json, discountchannel json, discountcategory json, discountcustomer json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
SELECT din.id ,din.name, din.type,din.ispercentage,
din.daysofweek,din.description,din.value,din.maxvalue,din.minquantity,din.minprice,din.promocode,din.availablefrom,din.availableto,din.priority,din.descriptionlanguage,
(SELECT to_json(
	array(
	select to_json(
		jsonb_build_object(
			'id',dbr.branchid,
			'name',br.name
		)
	)from discountbranch dbr left join  branch br on br.id=dbr.branchid where dbr.discountid=din.id 
	))) --branch

    ,(select
         (CASE WHEN COUNT(dprr.productid) > 0 THEN to_json(
	           array(
	               select to_json(
	                          jsonb_build_object(
		                                          'id',dpr.productid,
		                                          'name',pro.name
                              )
                   ) from discountproduct dpr left join product pro on pro.id = dpr.productid where dpr.discountid = din.id
               )
         )  ELSE
             (case when (select count(*) from discountattribute datt where datt.discountid = din.id ) >0 then
             to_json(array (select to_json(json_build_object(
                 'id',prr.id,
                 'name',prr.name
                 ))
                 from discountattribute dattr
                    inner join productattribute pa on pa.id = dattr.attributeid
                    inner join product prr on pa.productid = prr.id
                 where dattr.discountid= din.id group by prr.id
                 ))
             else null
             end
             ) END
         )from discountproduct dprr where dprr.discountid = din.id  )--discountproducts
    ,(select to_json(
	array(
	select to_json(
	jsonb_build_object(
		'id',disattr.attributeid,
		'name',proatt.name
	)) from discountattribute disattr
	    left join productattribute proatt on proatt.id = disattr.attributeid where disattr.discountid = din.id
	)
	)) --discount attributes
    ,(select to_json(
	array(
	select to_json(
	jsonb_build_object(
		'id',dischl.channelid,
	    'name', (select nlk.name where nlk.id = any(select dischl.channelid))
	)) from discountchannel dischl inner join namelookup nlk on nlk.id = dischl.channelid  where dischl.discountid = din.id
	)
	))--discount channels
    ,(select

          case when
             ((select count(*) from discountproduct where discountproduct.discountid = din.id )>0)
              then
                 to_json(array(	select to_json(
                jsonb_build_object(
                    'id',ca.id,
                    'name',ca.name
                )) from discountproduct dpr
                    inner join product pro on dpr.productid=pro.id left join category ca on ca.id=pro.categoryid
               where dpr.discountid=din.id group by(ca.id)
                ))
              else case when ((select count(*) from discountattribute where discountattribute.discountid = din.id)>0)
                  then to_json(array (select to_json(json_build_object(
                      'id',c.id,
                      'name',c.name
                      )) from discountattribute
                         inner join productattribute pa on discountattribute.attributeid = pa.id
                         inner join product p on p.id = pa.productid
                         inner join category c on p.categoryid = c.id
                         where discountattribute.discountid = din.id group by(c.id)
                      ))
                  else null
                  end
              end), --discount category
              to_json(array (select to_json(json_build_object(
                      'id',cus.id
                      --'name',cus.name,
                       --'phoneno',cus.phoneno
                      )) from discountcustomers dcus
                         inner join customer cus on cus.id = dcus.customerid
                         where dcus.discountid = din.id group by(cus.id)
                      ))
              
              
              
 from discountinfo din WHERE din.id=_discountid	;
 
	
END;
$$;


--
-- Name: getdiscountiteminfo(public.citext, uuid, uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getdiscountiteminfo(_tbalename public.citext, _id uuid, _branchid uuid, _channel public.citext) RETURNS TABLE(id uuid, value numeric, priority integer, ispercentage boolean, type public.citext)
    LANGUAGE plpgsql
    AS $$
    BEGIN
 IF _tbalename = 'product'
            THEN RETURN QUERY (select dinfo.id, dinfo.value, dinfo.priority, dinfo.ispercentage, dinfo.type 
                               from discountinfo dinfo
                               inner join discountproduct dispr on dispr.discountid = dinfo.id
                               inner join discountchannel disch on disch.discountid = dinfo.id
                               inner join discountbranch disbr on disbr.discountid = dinfo.id
                               where
                               ((case when (dinfo.availablefrom::time < dinfo.availableto::time) 
                                 then case when ((dinfo.availablefrom::time <= ((now())::time + interval '3 hour')) and (dinfo.availableto::time >= (now())::time))  then 1 else 0 end
                                      else case when ((dinfo.availableto::time <= (now())::time + interval '3 hour') and (dinfo.availablefrom::time >= (now())::time))  then 0 else 1 end
                                end)=1)
                               and ((dinfo.availablefrom)::date) <= ((now())::date)  and ((dinfo.availableto)::date) >= ((now())::date)
                               and (select to_char ( (now()), 'D'  )::integer) = any (dinfo.daysofweek)
                               and dispr.productid = _id
                               and disch.channelid = (select nlk.id from namelookup nlk where nlk.name =_channel)
                               and disbr.branchid =_branchid
                               and dinfo.isdeleted is not true
                               and dinfo.type = 'Order' order by dinfo.priority desc,dinfo.createdat desc LIMIT 1
                              );
            ELSE RETURN QUERY (select dinfo.id,dinfo.value,dinfo.priority,dinfo.ispercentage,dinfo.type
                                          from discountinfo dinfo
                                          left join discountattribute disprattr on disprattr.discountid = dinfo.id
                                          left join discountchannel disch on disch.discountid = dinfo.id
                                          left join discountbranch disbr on disbr.discountid = dinfo.id
                                          where
                                          ((case when (dinfo.availablefrom::time < dinfo.availableto::time) then
                                            case when ((dinfo.availablefrom::time <= ((now())::time + interval '3 hour')) and (dinfo.availableto::time >= (now())::time))  then 1 else 0 end
                                            else
                                            case when ((dinfo.availableto::time <= (now())::time + interval '3 hour') and (dinfo.availablefrom::time >= (now())::time))  then 0 else 1 end
                                            end) =1)
                                          and
                                          ((dinfo.availablefrom)::date) <= ((now())::date)  and ((dinfo.availableto)::date) >= ((now())::date)
                                          and
                                          (select to_char ( (now()), 'D'  )::integer) = any (dinfo.daysofweek)
                                          and disprattr.attributeid = _id
                                          and disch.channelid = (select nlk.id from namelookup nlk where nlk.name =_channel)
                                          and disbr.branchid = _branchid
                                          and dinfo.ispublished is true
                                          and dinfo.isdeleted is not true
                                          and dinfo.type = 'Order' order by dinfo.priority desc,dinfo.createdat desc LIMIT 1);
END IF;
END;
$$;


--
-- Name: getdiscountproductbybranch_ai(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getdiscountproductbybranch_ai(_branchid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, name public.citext, description public.citext, isdaily boolean, ispercentage boolean, value numeric, maxvalue numeric, minquantity integer, minprice numeric, descriptionlanguage jsonb, type public.citext, product json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select dinfo.id,dinfo.name,dinfo.description,dinfo.isdaily,dinfo.ispercentage,dinfo.value,dinfo.maxvalue
,dinfo.minquantity,dinfo.minprice,dinfo.descriptionlanguage,(CASE WHEN dinfo.ispercentage THEN 'percentage' ELSE 'value' END)::citext as type,
to_json(array(select 
              to_json(json_build_object(
                  'id',pro.id,
                  'name',pro.name,
                  'price',pro.price)) from product pro LEFT JOIN discountproduct dpro ON dpro.productid = pro.id 
              where dpro.discountid = dinfo.id and pro.isdeleted = false
              and pro.ispublished = true
              and pro.isavailable = true
              and pro.id not in (select objectid from branchavailability where branchid ='22d99819-2c7e-4363-9b26-8c136e0dd5b4')
             ))
from discountinfo dinfo INNER JOIN discountchannel dch ON dch.discountid = dinfo.id 
INNER JOIN discountbranch dbr
ON dbr.discountid = dinfo.id 
WHERE 
((case when (dinfo.availablefrom::time < dinfo.availableto::time) then
                 case when ((dinfo.availablefrom::time <= ((now())::time + interval '3 hour')) and (dinfo.availableto::time >= (now())::time))  then 1 else 0 end
             else
                 case when ((dinfo.availableto::time <= (now())::time + interval '3 hour') and (dinfo.availablefrom::time >= (now())::time))  then 0 else 1 end
		   end) =1)
            and
            ((dinfo.availablefrom)::date) <= ((now())::date)  and ((dinfo.availableto)::date) >= ((now())::date)
            and
            (select to_char ( (now()), 'D'  )::integer) = any (dinfo.daysofweek)
and dbr.branchid = _branchid 
AND dch.channelid = (select nlo.id from namelookup nlo where nlo.tabletype = 'ordersource' and nlo.name = 'Chatbot')
AND dinfo.isavailable = true
AND dinfo.isdeleted = false AND  dinfo.ispublished = true;
END;
$$;


--
-- Name: getdistance(uuid, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getdistance(_customerid uuid, _lat1 double precision, _lon1 double precision) RETURNS TABLE(id uuid, name public.citext, distance double precision)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY

    select csad.addressid,
           csad.name,
           (
               distance(_lat1,_lon1,
                   (select latitude from customeraddress csad1 where csad1.addressid = csad.addressid),
               (select longtitude from customeraddress csad1 where csad1.addressid = csad.addressid)))
               *1000
    from customeraddress csad where csad.customerid = _customerid
                                and csad.latitude is not null and csad.longtitude is not null;
END
$$;


--
-- Name: getelicashcredentials(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getelicashcredentials(_companyid uuid) RETURNS TABLE(brandrefid public.citext, companyid uuid)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select ecc.brandrefid, ecc.companyid from elicashcredentials ecc where ecc.companyid = _companyid;
END;
$$;


--
-- Name: getfeesbylabel(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getfeesbylabel(_companyid uuid DEFAULT NULL::uuid) RETURNS TABLE(branchid uuid, addressid uuid, branchname public.citext, cityid uuid, cityname public.citext, areaid uuid, areaname public.citext, subareaid uuid, subareaname public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select 
branch.id branchid, 
branchaddress.addressid,
branch.name branchname,
address.cityname cityid, 
getlocalizationvalue('ar',address.cityname ) cityname,
address.areaname areaid,
getlocalizationvalue('ar',address.areaname)areaname,
address.subareaname subareaid, getlocalizationvalue('ar',address.subareaname)subareaname
from branchaddress
inner join branch on branchaddress.branchid = branch.id 
inner join address on address.id = branchaddress.addressid 
where branch.companyid = _companyid;
END;
$$;


--
-- Name: getfeesbylabelpagination(uuid, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getfeesbylabelpagination(_companyid uuid DEFAULT NULL::uuid, _pagenumber integer DEFAULT 1, _pagesize integer DEFAULT 7) RETURNS TABLE(totalcount bigint, pagecount bigint, data json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select count(branchaddress.id) totalcount , ceil(count(branchaddress.id)/ _pagesize::decimal)::bigint pagecount ,  
 to_json(
        Array(
            select
                to_json(
                    json_build_object( 'id',branch.id, 
									  'addressid',branchaddress.addressid,
									  'branchname',branch.name,
									  'cityid',address.cityname, 
									  'cityname', getlocalizationvalue('ar',address.cityname ),
									  'areaid' ,address.areaname,
									  'areaname',getlocalizationvalue('ar',address.areaname),
									   'subareaid',address.subareaname , 'subareaname' , getlocalizationvalue('ar',address.subareaname) ))
from branchaddress
inner join branch on branchaddress.branchid = branch.id 
inner join address on address.id = branchaddress.addressid 
where branch.companyid = _companyid 
limit _pagesize
OFFSET ((_pagenumber-1) * _pagesize)))
from branchaddress
inner join branch on branchaddress.branchid = branch.id 
where branch.companyid =_companyid;
END;
$$;


--
-- Name: getfirststatusforbranch(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getfirststatusforbranch(_branchid uuid DEFAULT NULL::uuid) RETURNS SETOF uuid
    LANGUAGE plpgsql
    AS $$
BEGIN
if((select COUNT(id)  from orderstatuspossibilities where branchid = _branchid and isdeleted = false and ispublished = true and isfirststatus = true)> 0)
then
  return query select id from orderstatuspossibilities where branchid = _branchid and isdeleted = false and ispublished = true and isfirststatus = true limit 1;
else
 return query select id from orderstatuspossibilities where companyid = (select companyid from branch where id = _branchid) and isfirststatus = true limit 1;
end if;
END;
$$;


--
-- Name: getfoodaggsintegrations(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getfoodaggsintegrations(_companyid uuid) RETURNS TABLE(channelid uuid, name public.citext, logo public.citext, status public.citext, isactive boolean, reason public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select m.channelid,m.name,m.logo,c.status,c.isactive,c.reason from menuintegrators m
        left join companyactiveintegrations c on (m.channelid = c.channelid and companyid=_companyid)
                                                                  where m.isactive= true;
END
$$;


--
-- Name: getfulldashboardview(public.citext, uuid[], uuid[], timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getfulldashboardview(_reporttype public.citext, _branchids uuid[], _channelids uuid[] DEFAULT NULL::uuid[], _from timestamp without time zone DEFAULT NULL::timestamp without time zone, _to timestamp without time zone DEFAULT NULL::timestamp without time zone) RETURNS TABLE(totalorder bigint, totalprice numeric, totaldeliveryprice numeric, subtotalprice numeric, totaliscanceled bigint, totaliscomplained bigint, totalisdeclined bigint, barchart json, branchchart json, channelchart json, topsellingchart json, deliverychart json, dailychart json, hourlychart json)
    LANGUAGE plpgsql
    AS $$

BEGIN
 -- getting totalvalue and count hourly for branch
 if (_from = _to)
 then _to = _to::date+'1 day'::interval;
 end if;
 
if(_reporttype = 'hourly') then return query
select COUNT("order".id),SUM("order".totalprice),SUM("order".deliveryprice),SUM("order".subtotalprice)
,count( case when "order".iscanceled = true then "order".iscanceled end)
,count( case when "order".iscomplained = true then "order".iscomplained end)
,count( case when "order".isdeclined = true then "order".isdeclined end) , to_json( Array( select to_json(json_build_object(
 'labels',concat(to_char(to_char(ord.createdat,'YYYY-MM-DD HH24:00:00')::timestamp,'HH AM '),to_char(to_char(ord.createdat,'YYYY-MM-DD HH24:00:00')::timestamp,'Dy')),
 'orderscount',count(ord.id),
 'ordersamount',sum(coalesce(nullif(ord.totalprice,0),(ord.price->>'FinalPrice')::numeric -  (ord.price->>'DeliveryPrice')::numeric))
))from "order" ord
where branchid =any(_branchids)
GROUP BY(to_char(createdat,'YYYY-MM-DD HH24:00:00')::timestamp)
order by (to_char(createdat,'YYYY-MM-DD HH24:00:00')::timestamp) desc limit 24)) ,
 getbranchchartdashboardreport(_branchids,_channelids,_from,_to),
 getchannelchart(_branchids,_channelids,_from,_to),
 gettopsellingitemsreport(_branchids,_channelids,_from,_to),
 getdeliverydashboartreportpie(_branchids,_channelids,_from,_to),
 getjsondailyreportfordashboard(_branchids,_channelids,_from,_to),
 getjsonhourlyreportfordashboard(_branchids,_channelids,_from,_to)
from "order"
where branchid =any(_branchids)
and ((_from is null) or ("order".createdat >= _from))
and ((_to is null) or ("order".createdat <= _to));

-- getting totalvalue and count Daily for branch
else if(_reporttype = 'daily') then return query
select COUNT("order".id),SUM(coalesce(nullif("order".totalprice,0),("order".price->>'FinalPrice')::numeric -  ("order".price->>'DeliveryPrice')::numeric)),SUM("order".deliveryprice),SUM("order".subtotalprice)
,count( case when "order".iscanceled = true then "order".iscanceled end)
,count( case when "order".iscomplained = true then "order".iscomplained end)
,count( case when "order".isdeclined = true then "order".isdeclined end) , to_json( Array( select to_json(json_build_object(
 'labels',concat(to_char(ord.createdat::date,'Dy '),to_char(ord.createdat::date,'DD-Mon ')),
 'orderscount',count(ord.id),
 'ordersamount',sum(coalesce(nullif(ord.totalprice,0),(ord.price->>'FinalPrice')::numeric -  (ord.price->>'DeliveryPrice')::numeric))
))from "order" ord
where branchid =any(_branchids)
GROUP BY(createdat::date)
order by (createdat::date) desc limit 7)),
 getbranchchartdashboardreport(_branchids,_channelids,_from,_to),
 getchannelchart(_branchids,_channelids,_from,_to),
 gettopsellingitemsreport(_branchids,_channelids,_from,_to),
 getdeliverydashboartreportpie(_branchids,_channelids,_from,_to),
 getjsondailyreportfordashboard(_branchids,_channelids,_from,_to),
 getjsonhourlyreportfordashboard(_branchids,_channelids,_from,_to)

 from "order"
where branchid  =any(_branchids)
and ((_from is null) or ("order".createdat >=  to_char(_from,'YYYY-MM-DD 00:00:00')::timestamp))
and ((_to is null) or ("order".createdat <= to_char(_to,'YYYY-MM-DD 23:59:59')::timestamp));

-- getting totalvalue and count Weekly for branch
else if(_reporttype = 'weekly')  then return query
select COUNT("order".id),SUM(coalesce(nullif("order".totalprice,0),("order".price->>'FinalPrice')::numeric -  ("order".price->>'DeliveryPrice')::numeric)),SUM("order".deliveryprice),SUM("order".subtotalprice)
,count( case when "order".iscanceled = true then "order".iscanceled end)
,count( case when "order".iscomplained = true then "order".iscomplained end)
,count( case when "order".isdeclined = true then "order".isdeclined end) , to_json( Array( select to_json(json_build_object(
 'labels',concat('W',substring(to_char(createdat,'YYYY-MM-W') from 9),' ',to_char(to_char(createdat,'YYYY-MM-W')::timestamp,'Mon')),
 'orderscount',count(ord.id),
 'ordersamount',sum(coalesce(nullif(ord.totalprice,0),(ord.price->>'FinalPrice')::numeric -  (ord.price->>'DeliveryPrice')::numeric))
))from "order" ord
where branchid =any(_branchids)
GROUP BY(to_char(ord.createdat,'YYYY-MM-W'))
order by (to_char(ord.createdat,'YYYY-MM-W')) desc limit 5)),
 getbranchchartdashboardreport(_branchids,_channelids,_from,_to),
 getchannelchart(_branchids,_channelids,_from,_to),
 gettopsellingitemsreport(_branchids,_channelids,_from,_to),
 getdeliverydashboartreportpie(_branchids,_channelids,_from,_to),
 getjsondailyreportfordashboard(_branchids,_channelids,_from,_to),
 getjsonhourlyreportfordashboard(_branchids,_channelids,_from,_to)
 from "order"
where branchid  =any(_branchids)
and ((_from is null) or ("order".createdat >=  to_char(_from,'YYYY-MM-DD 00:00:00')::timestamp))
and ((_to is null) or ("order".createdat <= to_char(_to,'YYYY-MM-DD 23:59:59')::timestamp));

-- getting totalvalue and count Monthly for branch
else if(_reporttype = 'monthly') then return query
select COUNT("order".id),SUM(coalesce(nullif("order".totalprice,0),("order".price->>'FinalPrice')::numeric -  ("order".price->>'DeliveryPrice')::numeric)),SUM("order".deliveryprice),SUM("order".subtotalprice)
,count( case when "order".iscanceled = true then "order".iscanceled end)
,count( case when "order".iscomplained = true then "order".iscomplained end)
,count( case when "order".isdeclined = true then "order".isdeclined end) , to_json( Array( select to_json(json_build_object(
 'labels',concat(to_char(to_char(ord.createdat,'YYYY-MM-1')::timestamp,'Mon '),to_char(to_char(ord.createdat,'YYYY-MM-1')::timestamp,'YYYY')),
 'orderscount',count(ord.id),
 'ordersamount',sum(coalesce(nullif(ord.totalprice,0),(ord.price->>'FinalPrice')::numeric -  (ord.price->>'DeliveryPrice')::numeric))
))from "order" ord
where branchid =any(_branchids)
GROUP BY(to_char(ord.createdat,'YYYY-MM-1')::timestamp)
order by (to_char(ord.createdat,'YYYY-MM-1')::timestamp) desc limit 12)),
 getbranchchartdashboardreport(_branchids,_channelids,_from,_to),
 getchannelchart(_branchids,_channelids,_from,_to),
 gettopsellingitemsreport(_branchids,_channelids,_from,_to),
 getdeliverydashboartreportpie(_branchids,_channelids,_from,_to),
 getjsondailyreportfordashboard(_branchids,_channelids,_from,_to),
 getjsonhourlyreportfordashboard(_branchids,_channelids,_from,_to)
from "order"
where branchid  =any(_branchids)
and ((_from is null) or ("order".createdat >= to_char(_from,'YYYY-MM-1')::timestamp))
and ((_to is null) or ("order".createdat <= to_char(_to,'YYYY-MM-1')::timestamp + INTERVAL '1 MONTH - 1 day'))
;

-- getting totalvalue and count Yearly for branch
else if (_reporttype = 'yearly') then return query
select COUNT("order".id),SUM(coalesce(nullif("order".totalprice,0),("order".price->>'FinalPrice')::numeric -  ("order".price->>'DeliveryPrice')::numeric)),SUM("order".deliveryprice),SUM("order".subtotalprice)
,count( case when "order".iscanceled = true then "order".iscanceled end)
,count( case when "order".iscomplained = true then "order".iscomplained end)
,count( case when "order".isdeclined = true then "order".isdeclined end) , to_json( Array( select to_json(json_build_object(
 'labels',to_char(to_char(ord.createdat,'YYYY-1-1')::timestamp,'YYYY'),
 'orderscount',count(ord.id),
 'ordersamount',sum(coalesce(nullif(ord.totalprice,0),(ord.price->>'FinalPrice')::numeric -  (ord.price->>'DeliveryPrice')::numeric))
))from "order" ord
where branchid =any(_branchids)
GROUP BY(to_char(ord.createdat,'YYYY-1-1')::timestamp)
order by (to_char(ord.createdat,'YYYY-1-1')::timestamp) desc limit 2)),
 getbranchchartdashboardreport(_branchids,_channelids,_from,_to),
 getchannelchart(_branchids,_channelids,_from,_to),
 gettopsellingitemsreport(_branchids,_channelids,_from,_to),
 getdeliverydashboartreportpie(_branchids,_channelids,_from,_to),
 getjsondailyreportfordashboard(_branchids,_channelids,_from,_to),
 getjsonhourlyreportfordashboard(_branchids,_channelids,_from,_to)
from "order"
where branchid =any(_branchids)
and ((_from is null) or ("order".createdat >= to_char(_from,'YYYY-01-01')::timestamp))
and ((_to is null) or ("order".createdat <= to_char(_to,'YYYY-12-31')::timestamp));
end if;
end if;
end if;
end if;
end if;
END
$$;


--
-- Name: getglobalattributes(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getglobalattributes(_companyid uuid) RETURNS SETOF public.productattribute
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select * from productattribute where companyid = _companyid and isglobal=true and isdeleted = false and ispublished = true order by priority desc;
END;
$$;


--
-- Name: getglobalattributestree(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getglobalattributestree(_companyid uuid) RETURNS TABLE(id uuid, name jsonb, price jsonb, isrequired boolean, isalergy boolean, isavailable boolean, noofselection integer, minimumcount integer, maximumcount integer, description jsonb, children jsonb)
    LANGUAGE plpgsql
    AS $$
                  BEGIN
                  RETURN QUERY
                   select
                       pa.id,
                       pa.name,
                       pa.price,
                       pa.isrequired,
                       pa.isalergy,
                       pa.isavailable,
                       pa.noofselection,
                       pa.minimumcount,
                       pa.maximumcount,
                       pa.description,
                       (select to_json(array (
                           select to_json(
                               jsonb_build_object(
                                      'id',ch.id,
                                      'name',ch.name,
                                      'price',ch.price,
                                      'isrequired',ch.isrequired,
                                      'isalergy',ch.isalergy,
                                      'isavailable',ch.isavailable,
                                      'noofselection',ch.noofselection,
                                      'minimumcount',ch.minimumcount,
                                      'maximumcount',ch.maximumcount,
                                      'description',ch.description,
                                      'children',(
                                          select to_json(array (
                                            select to_json(
                                              jsonb_build_object(
                                              'id',sub.id,
                                              'name',sub.name,
                                              'price',sub.price,
                                              'isrequired',sub.isrequired,
                                              'isalergy',sub.isalergy,
                                              'isavailable',sub.isavailable,
                                              'noofselection',sub.noofselection,
                                              'minimumcount',sub.minimumcount,
                                              'maximumcount',sub.maximumcount,
                                              'description',sub.description))
                           from productattribute sub where sub.attributeid =ch.id and sub.isdeleted = false)))))
                           from productattribute ch where ch.attributeid =pa.id and ch.isdeleted = false
                           ))::jsonb
                           as children)
                       from productattribute pa
                        where companyid = _companyid
                        and isglobal=true
                        and isdeleted = false
                        and ispublished = true
                        and attributeid is null
                        and isdeleted = false
                        order by priority desc;
                  END;

$$;


--
-- Name: getgroups(uuid[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getgroups(_productids uuid[]) RETURNS TABLE(groups json)
    LANGUAGE plpgsql
    AS $$

BEGIN
RETURN query
select to_json(array_agg((to_json((
    select to_json(
        json_build_object(
            'id', pa.id,
            'deleted', pa.isdeleted,
            'ischatbotquestion', pa.ischatbotquestion,
            'name_localized', pa.name,
            'name',(case when ((pa.name->>'ar'::citext) <> '' and (pa.name->>'ar'::citext)  is not null  )then pa.name->>'ar' else pa.name->>'en' end )::citext,
            'description',(case when (pa.description->>'ar' is not null )then pa.description->>'ar' else (case when(pa.description->>'en' is not null) then pa.description->>'en' else '' end ) end )::citext,
            'description_localized' , json_build_object('en',(case when (pa.description->>'en' is not null )then pa.description->>'en' else ''end),'ar',case when (pa.description->>'ar' is not null )then pa.description->>'ar' else ''end),
            'controltype',pa.controltype ,
            'min',pa.minimumcount ,
            'max', pa.maximumcount,
            'priority',pa.priority,
            'options',getattributeoptionids(pa.id)
            )))))))
from productattribute pa
where pa.productid = any (_productids)
and pa.attributeid is null
and pa.isdeleted = false;
END;
$$;


--
-- Name: getgroups_careem(uuid[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getgroups_careem(_productids uuid[]) RETURNS TABLE(groups json)
    LANGUAGE plpgsql
    AS $$

BEGIN
RETURN query
select to_json(array_agg((to_json((
    select to_json(
        json_build_object(
            'id', pa.id,
            'deleted', pa.isdeleted,
            'name_localized', pa.name,
            'name',(case when ((pa.name->>'ar'::citext) <> '' and (pa.name->>'ar'::citext)  is not null  )then pa.name->>'ar' else pa.name->>'en' end )::citext,
            'description',(case when (pa.description->>'ar' is not null )then pa.description->>'ar' else (case when(pa.description->>'en' is not null) then pa.description->>'en' else '' end ) end )::citext,
            'description_localized' , json_build_object('en',(case when (pa.description->>'en' is not null )then pa.description->>'en' else ''end),'ar',case when (pa.description->>'ar' is not null )then pa.description->>'ar' else ''end),
            --'min',(case when pa.isrequired != true then 0 else 1 end ) ,
            --'max', pa.min,
            'multi_select',(case when pa.maximumcount > 1 then true else false end),
            'min',pa.minimumcount,
            'max',pa.maximumcount,
            'priority',pa.priority,
            'options',getattributeoptionids_careem(pa.id)
            )))))))
from productattribute pa
where pa.productid = any (_productids)
and pa.attributeid is null
and pa.isdeleted = false;
END;
$$;


--
-- Name: getgroupsforcareemdto(uuid[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getgroupsforcareemdto(_productids uuid[]) RETURNS TABLE(groups json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN query
select to_json(array_agg((to_json((
    select to_json(
        json_build_object(
            'id', pa.id,
            'deleted', pa.isdeleted,
            'name_localized', pa.name,
            'name',(case when ((pa.name->>'ar'::citext) <> '' and (pa.name->>'ar'::citext)  is not null  )then pa.name->>'ar' else pa.name->>'en' end )::citext,
            'description',(case when (pa.description->>'ar' is not null )then pa.description->>'ar' else (case when(pa.description->>'en' is not null) then pa.description->>'en' else '' end ) end )::citext,
            'description_localized' , json_build_object('en',(case when (pa.description->>'en' is not null )then pa.description->>'en' else ''end),'ar',case when (pa.description->>'ar' is not null )then pa.description->>'ar' else ''end),
            --'min',(case when pa.isrequired != true then 0 else 1 end ) ,
            --'max', pa.min,
            'min',pa.minimumcount,
            'max',pa.maximumcount,
            'priority',pa.priority,
            'options',getattributeoptionids(pa.id)
            )))))))
from productattribute pa
where pa.productid = any (_productids)
and pa.attributeid is null
and pa.isdeleted = false;
END;
$$;


--
-- Name: gethourlyreportfordashboard(uuid[], uuid[], timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.gethourlyreportfordashboard(_branchids uuid[], _channels uuid[] DEFAULT NULL::uuid[], _from timestamp without time zone DEFAULT NULL::timestamp without time zone, _to timestamp without time zone DEFAULT NULL::timestamp without time zone) RETURNS TABLE(hour public.citext, avgamount double precision, avgcount double precision)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN query
    select
    case when(
        (EXTRACT (HOUR FROM  createdat))::integer< 12)
        then concat((EXTRACT (HOUR FROM  createdat))::integer , ' AM')
        else concat(case when (EXTRACT (HOUR FROM  createdat)::integer = 12 ) then (EXTRACT (HOUR FROM  createdat))::integer else  (EXTRACT (HOUR FROM  createdat))::integer-12 end, ' PM')
        end ::citext
     , (sum(totalprice) / (case when (_from is not null and _to is not null) then (select _to::date - _from::date) else 30 end))::double precision
    , (count(id)/ (case when (_from is not null and _to is not null) then (select _to::date - _from::date) else 30 end)::double precision)
from "order"
where
"order".branchid  =any(_branchids)
and ((_channels is null) or ("order".ordersource=any(_channels)))
and ((_from is null) or ("order".createdat >= (to_char(_from::date,'YYYY-MM-DD 00:00:00')::timestamp)))
and ((_to is null) or ("order".createdat <= _to::date+'1 day' ::interval -'1 second' ::interval))
group by (EXTRACT (HOUR FROM  createdat))
order by (EXTRACT (HOUR FROM  createdat)) ;
END;
$$;


--
-- Name: getimagepath(public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getimagepath(_image public.citext DEFAULT NULL::public.citext) RETURNS TABLE(path public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select (CASE WHEN (_image like '%http%' or _image is null) THEN null ELSE 'https://uat-files.ishbek.com/'::citext END) ;
END;
$$;


--
-- Name: getimagepath_careem(public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getimagepath_careem(_image public.citext DEFAULT NULL::public.citext) RETURNS TABLE(path public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select (CASE WHEN (_image like '%http%' or _image is null) THEN null ELSE 'https://hfiles.ishbek.com/'::citext END) ;
END;
$$;


--
-- Name: getimagepathurl(public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getimagepathurl(_image public.citext DEFAULT NULL::public.citext) RETURNS TABLE(path public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select (CASE WHEN (_image like '%http%' or _image is null) THEN null ELSE ('https://uat-files.ishbek.com/'):: citext END) ;
END;
$$;


--
-- Name: integrationcompany; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.integrationcompany (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    name public.citext,
    logo character varying,
    type public.citext,
    phone public.citext,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL
);


--
-- Name: getintegrationcompany(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getintegrationcompany() RETURNS SETOF public.integrationcompany
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select * from integrationcompany where isdeleted = false ;
END;
$$;


--
-- Name: getintegrationcompanybyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getintegrationcompanybyid(_id uuid DEFAULT NULL::uuid) RETURNS SETOF public.integrationcompany
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select * from integrationcompany where id = _id and isdeleted = false and ispublished = true;
END;
$$;


--
-- Name: getintegrationorders(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getintegrationorders(_branchid uuid) RETURNS TABLE(id uuid, branchorderid public.citext, products json, currentstatus public.citext, ordersource uuid, ordersourcename public.citext, scheduled timestamp without time zone, deliverytype uuid, customerid uuid, branchid uuid, notes public.citext, totalprice numeric, deliveryprice numeric, deliveryaddress uuid, subtotalprice numeric, referencenumber public.citext, totalpreparingtime public.citext, deliverystatus public.citext, paymenttype public.citext, createdat timestamp without time zone, createdby public.citext, branchname public.citext, customername public.citext, customerdateofbirth date, customerphoneno public.citext, customerphoneno2 public.citext, customeremail public.citext, customerimage public.citext, customerchannel uuid, customerloyalitypoints numeric, customerfb public.citext, customertwitter public.citext, customerinstagram public.citext, customerlastorderdate date, customerisblocked boolean, customernotes public.citext, customercreatedat timestamp without time zone, customercreatedby public.citext, address json)
    LANGUAGE plpgsql
    AS $$
BEGIN 
RETURN QUERY
select
    ord.id,
    ord.branchorderid,
    to_json(
        Array(
            select
                to_json(
                    json_build_object(
                        'id',
                        ordpr.id,
                        'orderid',
                        ordpr.orderid,
                        'productid',
                        ordpr.productid,
                        'productname',
                        prd.name,
						'count',
						ordpr.itemcount,
						'createdat',
						prd.createdat,
						'createdby',
						prd.createdby,
                        'attributes',
                        to_json(
                            Array(
                                select
                                    to_json(
                                        json_build_object(
                                            'id',
                                            ordpratt.id,
                                            'orderproductid',
                                            ordpratt.orderproductid,
                                            'attributeid',
                                            ordpratt.attributeid,
                                            'attributename',
                                            prdatt.name,
                                            'pricesubtotal',
                                            ordpratt.pricesubtotal,
                                            'pricetaxvalue',
                                            ordpratt.pricetaxvalue,
                                            'pricetaxpercentage',
                                            ordpratt.pricetaxpercentage,
                                            'notes',
                                            ordpratt.notes,
											'createdat',
											ordpratt.createdat,
											'createdby',
											ordpratt.createdby
                                        )
                                    )
                                from
                                    orderproductattribute ordpratt
                                    left join productattribute prdatt on ordpratt.attributeid = prdatt.id
								where ordpratt.orderproductid = ordpr.id
                            )
                        ),
                        'pricesubtotal',
                        ordpr.pricesubtotal,
                        'pricetaxvalue',
                        ordpr.pricetaxvalue,
                        'pricetaxpercentage',
                        ordpr.pricetaxpercentage,
                        'notes',
                        ordpr.notes
                    )
                )
            from
                orderproduct ordpr
                left join product prd on ordpr.productid = prd.id
			where ordpr.orderid = ord.id
        )
    ) products,
    getorderstatus(ord.currentstatus),
    ord.ordersource,
	getlookupname(ord.ordersource),
    ord.scheduled,
    ord.deliverytype,
    ord.customerid,
    ord.branchid,
    ord.notes,
    ord.totalprice,
    ord.deliveryprice,
    ord.deliveryaddress,
    ord.subtotalprice,
    ord.referencenumber,
    ord.totalpreparingtime,
    ord.deliverystatus,
    ord.paymenttype,
    ord.createdat,
    ord.createdby,
	getbranchname(ord.branchid),
    customer.name,
    customer.dateofbirth,
    customer.phoneno,
    customer.phoneno2,
    customer.email,
    customer.image,
    customer.channel,
    customer.loyalitypoints,
    customer.fb,
    customer.twitter,
    customer.instagram,
    customer.lastorderdate,
    customer.isblocked,
    customer.notes,
    customer.createdat,
    customer.createdby,
	json_build_object('en',(select to_json(json_build_object('id', addr.id ,'name',name ,
													 'subareaid', subareaname , 
													 'subareaname',getlocalizationvalue('en' , 'subareaName' ,subareaname , 1),
'areaid',areaname, 'areaname',getlocalizationvalue('en' , 'areaName' ,areaname , 1), 
'cityid',cityname , 'cityname',getlocalizationvalue('en' , 'cityName' ,cityname , 1), 
'countryid',countryname,'countryname', getlocalizationvalue('en' , 'countryname' ,countryname , 1), 
'latitude',latitude ,'longtitude', longtitude ,
'address1',address1 ,'address2', address2 , 'phoneno',phoneno ,'buildingno', buildingno , 'streetno',streetno ,
'note',note , 'postalcode',postalcode , 'zipcode',zipcode , 'createdat',addr.createdat,'createdby',addr.createdby ))
from address addr where addr.id = ord.deliveryaddress and isdeleted = false and ispublished = true
),'ar', (select to_json(json_build_object('id', addr.id ,'name',name ,
													 'subareaid', subareaname , 
													 'subareaname',getlocalizationvalue('ar' , 'subareaName' ,subareaname , 1),
'areaid',areaname, 'areaname',getlocalizationvalue('ar' , 'areaName' ,areaname , 1), 
'cityid',cityname , 'cityname',getlocalizationvalue('ar' , 'cityName' ,cityname , 1), 
'countryid',countryname,'countryname', getlocalizationvalue('ar' , 'countryname' ,countryname , 1), 
'latitude',latitude ,'longtitude', longtitude ,
'address1',address1 ,'address2', address2 , 'phoneno',phoneno ,'buildingno', buildingno , 'streetno',streetno ,
'note',note , 'postalcode',postalcode , 'zipcode',zipcode , 'createdat',addr.createdat,'createdby',addr.createdby  ))
from address addr where addr.id = ord.deliveryaddress and isdeleted = false and ispublished = true
))
from
    "order" ord
    left join customer on ord.customerid = customer.id
	
	
where
    ord.branchid = _branchid;
	
	
	
		update lastorderfollowup
	    set ord.id = lastorderfollowup.orderid ;

END;
$$;


--
-- Name: getintegrationrequest(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getintegrationrequest(_companyid uuid) RETURNS TABLE(id uuid, channelid uuid, status public.citext, isactive boolean, createdby public.citext, companyname public.citext, channelname public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select
        cai.companyid as "Id",
        cai.channelid,
        cai.status,
        cai.isactive,
        cai.createdby,
        c.name,
        oi.name
    from companyactiveintegrations cai
             inner join company c on c.id = cai.companyid
             inner join ourintegration oi on oi.referenceid = cai.channelid
             where cai.status='pending' and cai.companyid = _companyid;
END
$$;


--
-- Name: getisfirststatus(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getisfirststatus(_id uuid DEFAULT NULL::uuid) RETURNS SETOF boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select st.isfirststatus from orderstatuspossibilities st where id = _id and isdeleted = false and ispublished = true;
END;
$$;


--
-- Name: getishbekareas(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getishbekareas(_cityid integer) RETURNS TABLE(id uuid, areaid bigint, ishbekcityserialid integer, name public.citext, name_en public.citext, name_ar public.citext, lat double precision, lng double precision, searchable_text public.citext, url_name_en public.citext, url_name_ar public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select ia.id as "Id",
           ia.areaid as "AreaId",
           ia.cityid as "CityId",
           ia.name as "Name",
           ia.name_en as "NameEn",
           ia.name_ar as "NameAr",
           ia.lat as "Lat",
           ia.lng as "Lng",
           ia.searchable_text as "SearchableText",
           ia.url_name_ar as "UrlNameAr",
           ia.url_name_en as "UrlNameEn"
    from ishbekareas ia where ia.cityid = _cityid;
END;
$$;


--
-- Name: getishbekcities(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getishbekcities() RETURNS TABLE(id uuid, cityid integer, name_ar public.citext, name_en public.citext, alias_name public.citext, searchable_text public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select
        ic.id as "Id",
        ic.cityid as "CityId",
        ic.name_ar as "NameAr",
        ic.name_en as "NameEn",
        ic.alias_name as "AliasName",
        ic.searchable_text as "SearchableText"
    from ishbekcities ic
    where ispublished = true;
END;
$$;


--
-- Name: getishbekorderid(public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getishbekorderid(_talabatorderid public.citext DEFAULT NULL::public.citext) RETURNS SETOF uuid
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select  td.orderid
 from talabatdelivery td
 where td.talabatorderid = _talabatorderid and requesttype = 'Order Creation' limit 1; 
END;
$$;


--
-- Name: getitems(uuid[], uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getitems(_categoryids uuid[], _menuid uuid) RETURNS TABLE(items json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN query
select to_json(array(select to_json(json_build_object(
       'id', pr.id,'deleted',pr.isdeleted,
	   'name',(case when (pr.name->>'ar' is not null )then pr.name->>'ar' else (case when (pr.name->>'en' is not null) THEN pr.name->>'en' ELSE '' END )   end ),
	   'name_localized',pr.name,
       'nametags',pt.nametags,
       'sizetags',pt.sizetags ,
       'ingredienttags',pt.ingredienttags,
	   'description',(case when(pr.description->>'en')::citext is not null then (pr.description->>'en')::citext else ''end),
	   'description_localized', pr.shortdescription ,
	   'active',pr.isavailable,
	   'istopselling',pr.istopselling,
	   'price', (case when (pr.price->>'careem' is not null) then ((price->>'careem')::decimal * (1 + (price->>'priceTaxPercentage')::decimal)) else ((price->>'default')::decimal * (1 + (price->>'priceTaxPercentage')::decimal)) end),
	   'media',CONCAT('https://hfiles.ishbek.com/',pr.imagepath)::citext ,'priority',pr.displaynumber,
	   'groups',(select array_agg(pa.id) from productattribute pa where productid = pr.id and pa.attributeid is null and pa.isdeleted = false)
    ))
                     from product pr
                     left join producttags pt on pr.id = pt.productid
where
    pr.categoryid =any (_categoryids) and pr.isdeleted = false
    and pr.id in (select productid from menuproduct where menuid = _menuid)
    ));

END;
$$;


--
-- Name: getitems_careem(uuid[], uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getitems_careem(_categoryids uuid[], _branchid uuid) RETURNS TABLE(items json)
    LANGUAGE plpgsql
    AS $$
declare
-- branchopentime text = (select to_char(opentime::time,'HH24:MI') from branch where id = _branchid);
-- branchclosetime text = (select to_char(closetime::time,'HH24:MI') from branch where id = _branchid);
BEGIN
RETURN query
select to_json(array(select to_json(json_build_object(
       'id', pr.id,'deleted',pr.isdeleted,
	   'name',(case when (pr.name->>'ar' is not null )then pr.name->>'en' else (case when (pr.name->>'en' is not null) THEN pr.name->>'en' ELSE '' END )   end ),
	   'name_localized',pr.name,
       'shifts', (select * from getoperationalhoursforbranch_careem(_branchid)),
	   'description',(case when(pr.description->>'en')::citext is not null then (pr.description->>'en')::citext else ''end),
	   'description_localized', pr.shortdescription ,
	   'active',CASE WHEN (
        SELECT COUNT(*)
        FROM branchavailability ba
        WHERE ba.objecttype = 'product'
          AND ba.objectid = pr.id
          AND ba.branchid = _branchid
          AND  ba.channelid = '0c698066-ce70-483f-8da6-968465fd697a'
    ) > 0 THEN false
    ELSE pr.isavailable
END,
	   'price', (case when (pr.price->>'careem' is not null) then ((price->>'careem')::decimal * (1 + (price->>'priceTaxPercentage')::decimal)) else ((price->>'default')::decimal * (1 + (price->>'priceTaxPercentage')::decimal)) end),
	   'media',concat(getimagepath_careem(pr.imagepath)::citext,pr.imagepath)::citext ,
        'priority',pr.displaynumber,
       'tags', (select json_build_array(coalesce(pr.producttags->>'en',''))),
	   'groups',(select array_agg(pa.id) from productattribute pa where productid = pr.id and pa.attributeid is null and pa.isdeleted = false)
    ))
                     from product pr
where
    pr.categoryid =any (_categoryids) and pr.isdeleted = false
    and pr.id in (select productid from menuproduct where menuid = (select menu.id from menu where menu.id = (select mch.menuid from menuchannel mch where mch.branchid = _branchid and mch.channelid =(select nlp.id from namelookup nlp where nlp.name ='careem')) and menu.isdeleted = false))
    ))

;

END;
$$;


--
-- Name: getitemsforcareemdto(uuid[], uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getitemsforcareemdto(_categoryids uuid[], _branchid uuid) RETURNS TABLE(items json)
    LANGUAGE plpgsql
    AS $$
declare
-- branchopentime text = (select to_char(opentime::time,'HH24:MI') from branch where id = _branchid);
-- branchclosetime text = (select to_char(closetime::time,'HH24:MI') from branch where id = _branchid);
BEGIN
RETURN query
select to_json(array(select to_json(json_build_object(
       'id', pr.id,'deleted',pr.isdeleted,
	   'name',(case when (pr.name->>'ar' is not null )then pr.name->>'en' else (case when (pr.name->>'en' is not null) THEN pr.name->>'en' ELSE '' END )   end ),
	   'name_localized',pr.name,
       'shifts', (select * from getoperationalhoursforbranch(_branchid)),
	   'description',(case when(pr.description->>'en')::citext is not null then (pr.description->>'en')::citext else ''end),
	   'description_localized', pr.shortdescription ,
	   'active',pr.isavailable,
	   'price', (case when (pr.price->>'callcenter' is not null) then ((price->>'callcenter')::decimal * (1 + (price->>'priceTaxPercentage')::decimal)) else ((price->>'default')::decimal * (1 + (price->>'priceTaxPercentage')::decimal)) end),
	   'media',CONCAT('https://hfiles.ishbek.com/',pr.imagepath)::citext ,'priority',pr.displaynumber,
	   'groups',(select array_agg(pa.id) from productattribute pa where productid = pr.id and pa.attributeid is null and pa.isdeleted = false)
    ))
                     from product pr
where
    pr.categoryid =any (_categoryids) and pr.isdeleted = false
    and pr.id in (select productid from menuproduct where menuid = (select menu.id from menu where menu.id = (select mch.menuid from menuchannel mch where mch.branchid = _branchid and mch.channelid =(select nlp.id from namelookup nlp where nlp.name ='callcenter')) and menu.isdeleted = false))
    ))

;

END;
$$;


--
-- Name: getjobid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getjobid(_id uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select jobid from orderprint where jobid = _id  limit 1;
END;
$$;


--
-- Name: getjsondailyreportfordashboard(uuid[], uuid[], timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getjsondailyreportfordashboard(_branchids uuid[], _channels uuid[] DEFAULT NULL::uuid[], _from timestamp without time zone DEFAULT NULL::timestamp without time zone, _to timestamp without time zone DEFAULT NULL::timestamp without time zone) RETURNS TABLE(dailychart json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN query




    select to_json( Array( select to_json(json_build_object(
 'labels',logicbase.dayname,
 'ordersamount',sum/(select count from daycount(_dayname := logicbase.dayname, _from := _from, _to := _to))::double precision,
 'orderscount',count/(select count from daycount(_dayname := logicbase.dayname, _from := _from, _to := _to))::double precision
))from ( select to_char(createdat::date, 'Day')::citext as dayname,
        sum(coalesce(nullif("order".totalprice,0),("order".price->>'FinalPrice')::numeric -  ("order".price->>'DeliveryPrice')::numeric)) sum,
        count(id)::double precision count
 from "order"
where
 "order".branchid  =any(_branchids)
and ((_channels is null) or ("order".ordersource=any(_channels)))
and ((_from is null) or ("order".createdat >= (to_char(_from::date,'YYYY-MM-DD 00:00:00')::timestamp)))
and ((_to is null) or ("order".createdat <= _to::date+'1 day' ::interval -'1 second' ::interval))
group by to_char(createdat::date, 'Day')) logicbase));
END;
$$;


--
-- Name: getjsonhourlyreportfordashboard(uuid[], uuid[], timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getjsonhourlyreportfordashboard(_branchids uuid[], _channels uuid[] DEFAULT NULL::uuid[], _from timestamp without time zone DEFAULT NULL::timestamp without time zone, _to timestamp without time zone DEFAULT NULL::timestamp without time zone) RETURNS TABLE(hourlychart json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN query
    select to_json( Array( select to_json(json_build_object(
 'labels',logicbase.hourname,
 'orderscount',logicbase.avgcount,
 'ordersamount',logicbase.avgamount
))from (    select
    case when(
        (EXTRACT (HOUR FROM  createdat))::integer< 12)
        then concat((EXTRACT (HOUR FROM  createdat))::integer , ' AM')
        else concat(case when (EXTRACT (HOUR FROM  createdat)::integer = 12 ) then (EXTRACT (HOUR FROM  createdat))::integer else  (EXTRACT (HOUR FROM  createdat))::integer-12 end, ' PM')
        end ::citext as hourname
     , (sum(coalesce(nullif("order".totalprice,0),("order".price->>'FinalPrice')::numeric -  ("order".price->>'DeliveryPrice')::numeric)) / (case when (_from is not null and _to is not null) then (select _to::date - _from::date) else 30 end))::double precision avgamount
    , (count(id)/ (case when (_from is not null and _to is not null) then (select _to::date - _from::date) else 30 end)::double precision)avgcount
from "order"
where
"order".branchid  =any(_branchids)
and ((_channels is null) or ("order".ordersource=any(_channels)))
and ((_from is null) or ("order".createdat >= (to_char(_from::date,'YYYY-MM-DD 00:00:00')::timestamp)))
and ((_to is null) or ("order".createdat <= _to::date+'1 day' ::interval -'1 second' ::interval))
group by (EXTRACT (HOUR FROM  createdat))
order by (EXTRACT (HOUR FROM  createdat)) ) logicbase
        ));
END;
$$;


--
-- Name: getjsonproductreport(uuid, timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getjsonproductreport(_companyid uuid, _fromtime timestamp without time zone DEFAULT NULL::timestamp without time zone, _totime timestamp without time zone DEFAULT NULL::timestamp without time zone) RETURNS TABLE(data json)
    LANGUAGE plpgsql
    AS $$
        declare sqlquery text;

BEGIN
        sqlquery = getproductsalesreport(_companyid,(case when _fromtime is null then '2000-01-01 00:00:00' else _fromtime end),(case when _fromtime is null then '2100-01-01 00:00:00' else _totime end));
RETURN QUERY EXECUTE sqlquery;
        END;
$$;


--
-- Name: getlanguageid(public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getlanguageid(_languagecode public.citext) RETURNS TABLE(languageid uuid)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select id from language lang
  where lang.languagecode=_languagecode;
END;
$$;


--
-- Name: getlastaddeddiscountbycompanyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getlastaddeddiscountbycompanyid(_companyid uuid) RETURNS TABLE(id uuid, name public.citext, availablefromtime time without time zone, availablefromdate date, availabletotime time without time zone, availabletodate date, isavailable boolean, numofbranch bigint, numofproducts bigint, numofchannel bigint)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select dinfo.id, dinfo.name,
             (dinfo.availablefrom::time) as availablefromtime,
             (dinfo.availablefrom::date) as availablefromdate,
             (dinfo.availableto::time) as availabletotime,
             (dinfo.availableto::date) as availabletodate,
             dinfo.isavailable,
        (select count(*) from discountbranch where discountid = dinfo.id) as numofbranch,
        (select count(*) from discountproduct where discountid = dinfo.id) as numofproducts,
        (select count(*) from discountchannel where discountid = dinfo.id) as numofchannel
    from discountinfo dinfo
    where dinfo.companyid = _companyid
    and dinfo.isdeleted = false
    order by createdat desc limit 1;

END;
$$;


--
-- Name: getlastpromocodeaddedbycompanyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getlastpromocodeaddedbycompanyid(_companyid uuid) RETURNS TABLE(id uuid, name public.citext, availablefromtime time without time zone, availablefromdate date, availabletotime time without time zone, availabletodate date, isavailable boolean, numofbranch bigint, numofproducts bigint, numofchannel bigint)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select prc.id,
        prc.name,
        (prc.availablefrom::time) as availablefromtime,
        (prc.availablefrom::date) as availablefromdate,
        (prc.availableto::time) as availabletotime,
        (prc.availableto::date) as availabletodate,
        prc.isavailable,
        (select count(*) from promocodebranch where promocodeid = prc.id) as numofbranch,
        (select count(*) from promocodecategory where promocodeid = prc.id) as numofproducts,
        (select count(*) from promocodechannel where promocodeid = prc.id) as numofchannel
    from promocode prc
    where prc.companyid = _companyid
    and prc.isdeleted = false
    order by createdat desc limit 1;

END;
$$;


--
-- Name: getlatestbranch(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getlatestbranch(_companyid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, name public.citext, namelanguage jsonb, companyid uuid, addressname public.citext, opentime timestamp without time zone, closetime timestamp without time zone, status integer, countryid uuid, createdat timestamp without time zone, createdby public.citext, latitude numeric, longtitude numeric, phonenumber public.citext, transferbranch json, hasactivemenu boolean, addressid uuid, branchaddressname public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select "branch".id,"branch".name, "branch".namelanguage,"branch".companyid,"branch".addressname ,"branch".opentime,"branch".closetime,
case when ("branch".status = 1) then
case when ("branch".opentime::time < "branch".closetime::time) then
case when (("branch".opentime::time <= ((now() AT TIME ZONE 'Asia/Amman'::text)::time))
		   and ("branch".closetime::time >= (now() AT TIME ZONE 'Asia/Amman'::text)::time) )  then 1 else 0 end
else case when (("branch".closetime::time <= (now() AT TIME ZONE 'Asia/Amman'::text)::time)
		   and ("branch".opentime::time >= (now() AT TIME ZONE 'Asia/Amman'::text)::time) )  then 0 else 1 end
		   end
else 0 end ,"branch".countryid,"branch".createdat,"branch".createdby,"branch".latitude,"branch".longtitude,"branch".phonenumber,
 (select to_json(json_build_object(
	 'id',transferbranch.id,
	 'isactive',transferbranch.isactive,
	 'transfertobranchid',transferbranch.transfertobranchid,
   	 'transferedtobranch',(select br.name from branch br where br.id = transferbranch.transfertobranchid ))) from transferbranch
	 where isactive = true and branchidselected = "branch".id
	 and ((fromdate is null and todate is null) or(fromdate <= (now() AT TIME ZONE 'Asia/Amman'::text)::timestamp) and (todate >= (now() AT TIME ZONE 'Asia/Amman'::text)::timestamp))
) ,
(case when menuid is null then false else (select menu.isavailable from menu where menu.id = branch.menuid and menu.isdeleted = false) end)
, branch.addressid,(select getaddressname(branch.addressid))
from branch  where  "branch".companyid = _companyid and "branch".isdeleted = false and "branch".ispublished = true
 order by "branch".createdat desc
  LIMIT  1
 ;

END;
$$;


--
-- Name: getlocaldeliveryname(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getlocaldeliveryname(_branchid uuid) RETURNS SETOF public.citext
    LANGUAGE plpgsql
    AS $$
BEGIN
    return query
    select concat((select name from company where id = (select companyid from branch where id = _branchid)),'Delivery')::citext;
END;
$$;


--
-- Name: getlocalizationvalue(public.citext, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getlocalizationvalue(_languagecode public.citext, _objectid uuid) RETURNS TABLE(result public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select value as "Value" from languageresourcee lr
  where lr.objectid=_objectid and lr.languagecode=_languagecode 
  and lr.ispublished=true and lr.isdeleted=false;
END;
$$;


--
-- Name: getlocalizationvalue(public.citext, public.citext, uuid, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getlocalizationvalue(_languagecode public.citext, _key public.citext, _objectid uuid, _type integer) RETURNS TABLE(result public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY

SELECT (CASE
    WHEN COUNT(lr.value) = 0 THEN null
    ELSE (select value as "Value" from languageresourcee lr
  where lr.key = _key and lr.objectid=_objectid and lr.languagecode=_languagecode  and lr.type = _type
  and lr.ispublished=true and lr.isdeleted=false)
  END) as value from languageresourcee lr
  where lr.key = _key and lr.objectid=_objectid and lr.languagecode=_languagecode  and lr.type = _type
  and lr.ispublished=true and lr.isdeleted=false ;

END;
$$;


--
-- Name: getlookupname(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getlookupname(_id uuid DEFAULT NULL::uuid) RETURNS SETOF public.citext
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select name  from namelookup nlk where nlk.id = _id and nlk.isdeleted = false and nlk.ispublished = true;
END;
$$;


--
-- Name: getlookupsbytype(public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getlookupsbytype(_type public.citext) RETURNS TABLE(id uuid, name public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select namelookup.id, namelookup.name from namelookup where  namelookup.tabletype like concat('%',_type,'%') and isdeleted = false and ispublished = true;
END;
$$;


--
-- Name: getmanualattributevaluesforproudct(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getmanualattributevaluesforproudct(_id uuid, _branchid uuid) RETURNS TABLE(id uuid, name jsonb, branches jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select attributevalues.id , attributevalues.name ,
(select to_json( array(select row_to_json(getbranchforcategorybymenuid(_id := _branchid,_callid := attributevalues.id)))))::jsonb 
 from productattribute attributevalues where
 attributevalues.productid = _id and attributevalues.isdeleted = false and attributevalues.ispublished = true 
                        and attributeid is null;
END;
$$;


--
-- Name: getmarketperformancereport(uuid, timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getmarketperformancereport(_companyid uuid DEFAULT NULL::uuid, _fromtime timestamp without time zone DEFAULT NULL::timestamp without time zone, _totime timestamp without time zone DEFAULT NULL::timestamp without time zone) RETURNS TABLE(branchname public.citext, deliverytype public.citext, ordercount bigint, amount numeric, average numeric, withdelivery numeric, totalsales numeric, id uuid)
    LANGUAGE plpgsql
    AS $$

BEGIN
RETURN QUERY

select b.name branchname ,
       case when ord.deliverytype = '3b9f60af-a9d4-4bae-b267-f73b48ff06fc' then ('pickup' ::citext) else ('delivery'::citext) end ::citext deliverytype ,
       count(*) ordercount,
       round(sum((ord.price->>'FinalPrice')::numeric),3),
       round((sum((ord.price->>'FinalPrice')::numeric - (ord.price->>'DeliveryPrice')::numeric) / (count(ord.id) ::numeric)),3)  average,
       round(sum((ord.price->>'FinalPrice')::numeric),3) withdelivery,
       round(sum((ord.price->>'FinalPrice')::numeric),3) totalsales,
       b.id  from "order" ord
                          join branch b on b.id = ord.branchid
                          where ord.branchid in (select b2.id from branch b2 where companyid = _companyid)
                          and ((_fromtime is null) or(  ord.createdat >= _fromtime )) and ((_totime is null) or(   ord.createdat <= _totime))
                          group by branchid, b.name,b.id, case when ord.deliverytype = '3b9f60af-a9d4-4bae-b267-f73b48ff06fc' then ('pickup' ::citext) else ('delivery'::citext) end ::citext;
-- select b.name branchname,
--        ('pickup'::citext) deliverytype,
--         count(ord.id) ordercount,
--         round(sum((ord.price->>'FinalPrice')::numeric - (ord.price->>'DeliveryPrice')::numeric),3) amount,
--         round((sum((ord.price->>'FinalPrice')::numeric - (ord.price->>'DeliveryPrice')::numeric) / (count(ord.id) ::numeric)),3) average,
--         round(sum((ord.price->>'FinalPrice')::numeric),3) withdelivery,
--         (select round(sum((o.price->>'FinalPrice')::numeric),3) from "order" o where o.branchid = b.id) totalsales,b.id
--
-- from "order" ord
--     inner join branch b on ord.branchid = b.id
-- where b.companyid = _companyid
--   and ord.deliverytype = '3b9f60af-a9d4-4bae-b267-f73b48ff06fc'
-- group by b.id
-- union
-- select b.name,
--        'delivery',
--         count(ord.id) ,
--         round(sum((ord.price->>'FinalPrice')::numeric),3) ,
--         round((sum((ord.price->>'FinalPrice')::numeric - (ord.price->>'DeliveryPrice')::numeric) / (count(ord.id) ::numeric)),3) ,
--         round(sum((ord.price->>'FinalPrice')::numeric),3),
--           (select round(sum((o.price->>'FinalPrice')::numeric),3) from "order" o where o.branchid = b.id)
-- ,b.id
-- from "order" ord inner join branch b on ord.branchid = b.id
-- where
-- ((_fromtime is null) or(ord.createdat >= _fromtime  )) and ((_totime is null) or( ord.createdat <= _totime  ))
-- and b.companyid = _companyid and ord.deliverytype <> '3b9f60af-a9d4-4bae-b267-f73b48ff06fc'
-- group by b.id;
END;
$$;


--
-- Name: getmenu(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getmenu(_id uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, name public.citext, createdat timestamp without time zone, createdby public.citext, companyid uuid)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select  menu.id, menu.name, menu.createdat, menu.createdby , menu.companyid
from menu where menu.id = _id and isdeleted = false and ispublished = true;

END;
$$;


--
-- Name: getmenuai(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getmenuai(_menuid uuid) RETURNS TABLE(catalog json, categories json, items json, groups json, options json)
    LANGUAGE plpgsql
    AS $$

BEGIN
RETURN query
select getcatalog(_menuid),
getcategories(_menuid),
getitems((select getmenucategoryids(_menuid)),_menuid),
getgroups((select array_agg(productid) from menuproduct where menuid = _menuid)),
getoptions((select array_agg(productid) from menuproduct where menuid = _menuid ));
END;
$$;


--
-- Name: getmenucategoryids(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getmenucategoryids(_menuid uuid) RETURNS TABLE(categories uuid[])
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN query
 select array_agg(c.id)::uuid[] from menucategories
inner join category c on c.id = menucategories.categoryid
where menucategories.menuid = _menuid and c.isdeleted= false;
END;
$$;


--
-- Name: getmenucategoryids_careem(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getmenucategoryids_careem(_menuid uuid) RETURNS TABLE(categories uuid[])
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN query
        select array_agg(c.id)::uuid[]
        from menucategories
                 inner join category c on c.id = menucategories.categoryid
        where menucategories.menuid = _menuid
          and c.isdeleted = false;
END;
$$;


--
-- Name: getmenujson(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getmenujson(_menuid uuid) RETURNS TABLE(menu json)
    LANGUAGE plpgsql
    AS $$

BEGIN
RETURN query

select row_to_json(getmenuai(_menuid));

END;
$$;


--
-- Name: getmenuviews(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getmenuviews(_companyid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, name public.citext, isavailable boolean, branch json, channel json, product json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select mn.id,mn.name,mn.isavailable,
to_json( Array( select to_json(json_build_object('id' ,
    (CASE WHEN br.id IS NULL THEN mch.branchid ELSE br.id END)
    ,'name',
    (CASE WHEN br.id IS NULL THEN (select br1.name from branch br1 where br1.id = mch.branchid) ELSE br.name END)
    ,'location' ,
    (CASE WHEN br.id IS NULL THEN (select br1.addressname from branch br1 where br1.id = mch.branchid)  ELSE br.addressname END)
    ))
                from branch br
                    left join menuchannel mch on mch.branchid = br.id
		where (br.menuid = mn.id or mch.menuid = mn.id) and mn.isdeleted = false and mn.ispublished = true GROUP BY br.id,mch.branchid )) branches,

        to_json( Array( select to_json(json_build_object('id' , mch.channelid ,'name', nlk.name,'issync',(select mis.issync from menuintegratiosync mis where mis.channelid = mch.channelid and mis.menuid = mn.id ) )) from menuchannel mch left join namelookup nlk on nlk.id = mch.channelid
		where mch.menuid = mn.id and mn.isdeleted = false and mn.ispublished = true and nlk.isdeleted = false and nlk.ispublished=true group by mch.channelid,nlk.name )) channel,
		to_json( Array( select to_json(json_build_object('id' , product.id,'name', product.name,'isavailable' , product.ispublished,'image' , concat(getimagepath(product.imagepath),product.imagepath)::citext))	from product product
		where product.id in (select productid from menuproduct where menuid = mn.id) and product.isdeleted = false  )) products
		from menu mn
		where mn.companyid = _companyid and mn.isdeleted = false and mn.ispublished = true  order by mn.createdat desc;
		END;
$$;


--
-- Name: getnewcompanycities(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getnewcompanycities(_companyid uuid DEFAULT NULL::uuid) RETURNS TABLE(name public.citext, id public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY

select distinct(branchdeliverycharge.city) as name,branchdeliverycharge.city as id 
from branchdeliverycharge
inner join branch on branch.id = branchdeliverycharge.branchid
where branch.companyid = _companyid;
END;
$$;


--
-- Name: getnextstatus(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getnextstatus(_id uuid) RETURNS SETOF uuid
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
-- select nextstatus from orderstatuspossibilities where id = _id and isdeleted = false and ispublished = true;
   select nextstatus from orderstatuspossibilities1 where id = _id;
END;
$$;


--
-- Name: getnotification(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getnotification(_companyid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, createdat timestamp without time zone, title public.citext, subject public.citext, categroy public.citext[], customers bigint)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY


SELECT notifi.id, notifi.createdat,notifi.title, notifi.subject,array_agg(lk.name),(select COUNT(nf.id) from notificationfollowup nf where nf.notificationid = notifi.id)
	FROM public.notification notifi
    left join lookup lk on lk.id =any(notifi.category)
    WHERE companyid = _companyid and isdeleted = false GROUP BY notifi.id;

END;
$$;


--
-- Name: getnotificationforbranch(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getnotificationforbranch(_branchid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, subject text, startdate date, starttime time without time zone, urgent boolean, priority integer, createdat timestamp without time zone, createdby public.citext, companyname public.citext, companyid uuid, companylogo character varying, branches json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select "noti".id,"noti".subject,"noti".startdate,"noti".starttime,"noti".urgent,"noti".priority,"noti".createdat,"noti".createdby,
"comp".name as companyname,"comp".id as companyid,"comp".logo as companylogo,to_json(Array(select to_json(json_build_object( 'name',"bra".name,'id',"bra".id)) from branch bra where "bra".id = _branchid)) as branches
from notification noti 
INNER JOIN company comp ON "comp".id = "noti".companyid 
INNER JOIN notificationfollowup notifoll ON "notifoll".notificationid = "noti".id
where "noti".type = 1 and "noti".isdeleted = false;
END;
$$;


--
-- Name: getnotificationforcompany(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getnotificationforcompany(_companyid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, subject text, startdate date, starttime time without time zone, urgent boolean, priority integer, createdat timestamp without time zone, createdby public.citext, companyname public.citext, companyid uuid, branches json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select "noti".id,"noti".subject,"noti".startdate,"noti".starttime,"noti".urgent,"noti".priority,"noti".createdat,"noti".createdby,
"comp".name as companyname,"comp".id as companyid,to_json(Array(select to_json(json_build_object( 'name',"bra".name,'id',"bra".id)) as branches from branch bra where "bra".id = ANY("notifoll".branchid))) as branches
from notification noti 
INNER JOIN company comp ON "comp".id = "noti".companyid 
INNER JOIN notificationfollowup notifoll ON "notifoll".notificationid = "noti".id
where "noti".companyid = _companyid and "noti".type = 1 and "noti".isdeleted = false;
END;
$$;


--
-- Name: getnowcartdiscountsonline(uuid, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getnowcartdiscountsonline(_branchid uuid, _isonline boolean DEFAULT true) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
    declare _channelid uuid;
    BEGIN
        if _isonline
            then _channelid=(select id from namelookup where name = 'OnlineOrdering');
            else _channelid=(select id from namelookup where name = 'Chatbot');
            end if;
    RETURN QUERY
            select json_build_object(
                'Total',
               getnowdiscountsbytypeonline(_branchid,_channelid,'Total') ,
                'Delivery',
             getnowdiscountsbytypeonline(_branchid,_channelid,'Delivery')
        );
    END;
$$;


--
-- Name: getnowdiscountsbytypeonline(uuid, uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getnowdiscountsbytypeonline(_branchid uuid, _channelid uuid, _discounttype public.citext) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
    BEGIN
    RETURN QUERY
    select row_to_json(discount) from (
                select dinfo.id, dinfo.value, dinfo.minquantity, dinfo.maxvalue,dinfo.minprice, dinfo.priority,
                       dinfo.ispercentage,dinfo.createdat,dinfo.type from discountinfo dinfo
               inner join discountchannel disch on disch.discountid = dinfo.id
               inner join discountbranch disbr on disbr.discountid = dinfo.id
        where
             ((case when (dinfo.availablefrom::time < dinfo.availableto::time) then
                             case when ((dinfo.availablefrom::time <= ((now())::time + interval '3 hour')) and (dinfo.availableto::time >= (now())::time))  then 1 else 0 end
                         else
                             case when ((dinfo.availableto::time <= (now())::time + interval '3 hour') and (dinfo.availablefrom::time >= (now())::time))  then 0 else 1 end
                       end) =1)            and
            ((dinfo.availablefrom)::date) <= ((now())::date)  and ((dinfo.availableto)::date) >= ((now())::date)
            and
            (select to_char ( (now()), 'D'  )::integer) = any (dinfo.daysofweek)
            and disch.channelid = _channelid
            and disbr.branchid = _branchid
            and dinfo.ispublished is true
            and dinfo.isdeleted is not true
            and dinfo.isavailable is true
            and  dinfo.type = _discounttype
             order by dinfo.priority desc,dinfo.createdat desc LIMIT 1)discount;
    END;
$$;


--
-- Name: getnowdiscountsforattribute(uuid, uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getnowdiscountsforattribute(_attributeid uuid, _branchid uuid, _channelid uuid) RETURNS TABLE(id uuid, value numeric, minquantity integer, maxvalue numeric, minprice numeric, priority integer, ispercentage boolean, createdat timestamp without time zone)
    LANGUAGE plpgsql
    AS $$
    BEGIN
    RETURN QUERY
        select dinfo.id, dinfo.value, dinfo.minquantity, dinfo.maxvalue,dinfo.minprice, dinfo.priority, dinfo.ispercentage,dinfo.createdat from discountinfo dinfo
               left join discountattribute disprattr on disprattr.discountid = dinfo.id
               left join discountchannel disch on disch.discountid = dinfo.id
               left join discountbranch disbr on disbr.discountid = dinfo.id
        where
 ((case when (dinfo.availablefrom::time < dinfo.availableto::time) then
                 case when ((dinfo.availablefrom::time <= ((now())::time + interval '3 hour')) and (dinfo.availableto::time >= (now())::time))  then 1 else 0 end
             else
                 case when ((dinfo.availableto::time <= (now())::time + interval '3 hour') and (dinfo.availablefrom::time >= (now())::time))  then 0 else 1 end
		   end) =1)            and
            ((dinfo.availablefrom)::date) <= ((now())::date)  and ((dinfo.availableto)::date) >= ((now())::date)
            and
            (select to_char ( (now()), 'D'  )::integer) = any (dinfo.daysofweek)
            and disprattr.attributeid = _attributeid
            and disch.channelid = _channelid
            and disbr.branchid = _branchid
            and dinfo.ispublished is true
            and dinfo.isdeleted is not true
            and dinfo.isavailable is not false
           
            order by dinfo.priority desc, dinfo.createdat desc limit 1;
            
    END;
$$;


--
-- Name: getnowdiscountsfordeliverybybranchid(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getnowdiscountsfordeliverybybranchid(_branchid uuid, _channelid uuid) RETURNS TABLE(id uuid, value numeric, minquantity integer, maxvalue numeric, minprice numeric, priority integer, ispercentage boolean, createdat timestamp without time zone, type public.citext)
    LANGUAGE plpgsql
    AS $$
    BEGIN
    RETURN QUERY
        select dinfo.id, dinfo.value, dinfo.minquantity, dinfo.maxvalue,dinfo.minprice, dinfo.priority, dinfo.ispercentage,dinfo.createdat,dinfo.type from discountinfo dinfo
               left join discountchannel disch on disch.discountid = dinfo.id
               left join discountbranch disbr on disbr.discountid = dinfo.id
        where
 ((case when (dinfo.availablefrom::time < dinfo.availableto::time) then
                 case when ((dinfo.availablefrom::time <= ((now())::time + interval '3 hour')) and (dinfo.availableto::time >= (now())::time))  then 1 else 0 end
             else
                 case when ((dinfo.availableto::time <= (now())::time + interval '3 hour') and (dinfo.availablefrom::time >= (now())::time))  then 0 else 1 end
		   end) =1)            and
            ((dinfo.availablefrom)::date) <= ((now())::date)  and ((dinfo.availableto)::date) >= ((now())::date)
            and
            (select to_char ( (now()), 'D'  )::integer) = any (dinfo.daysofweek)
            and disch.channelid = _channelid
            and disbr.branchid = _branchid
            and dinfo.ispublished is true
            and dinfo.isdeleted is not true
            and dinfo.isavailable is true
            and dinfo.type = 'Delivery' order by dinfo.priority desc,dinfo.createdat desc LIMIT 1;
    END;
$$;


--
-- Name: getnowdiscountsforproducts(uuid, uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getnowdiscountsforproducts(_productid uuid, _branchid uuid, _channelid uuid) RETURNS TABLE(id uuid, value numeric, minquantity integer, maxvalue numeric, minprice numeric, priority integer, ispercentage boolean)
    LANGUAGE plpgsql
    AS $$
    BEGIN
    RETURN QUERY
         select dinfo.id, dinfo.value,dinfo.minquantity, dinfo.maxvalue, dinfo.minprice, dinfo.priority, dinfo.ispercentage from discountinfo dinfo
               inner join discountproduct dispr on dispr.discountid = dinfo.id
               inner join discountchannel disch on disch.discountid = dinfo.id
               inner join discountbranch disbr on disbr.discountid = dinfo.id
        where
             ((case when (dinfo.availablefrom::time < dinfo.availableto::time) then
                 case when ((dinfo.availablefrom::time <= ((now())::time + interval '3 hour')) and (dinfo.availableto::time >= (now())::time))  then 1 else 0 end
             else
                 case when ((dinfo.availableto::time <= (now())::time + interval '3 hour') and (dinfo.availablefrom::time >= (now())::time))  then 0 else 1 end
		   end) =1)
            and
            ((dinfo.availablefrom)::date) <= ((now())::date)  and ((dinfo.availableto)::date) >= ((now())::date)
            and
            (select to_char ( (now()), 'D'  )::integer) = any (dinfo.daysofweek)
            and dispr.productid = _productid
            and disch.channelid = _channelid
            and disbr.branchid =_branchid
            and dinfo.isdeleted is not true and dinfo.isavailable is true
            and disbr.branchid =_branchid
            and dinfo.isavailable is not false
            order by dinfo.priority desc, dinfo.createdat desc limit 1;
    END;
$$;


--
-- Name: getnowdiscountsfortotalbybranchid(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getnowdiscountsfortotalbybranchid(_branchid uuid, _channelid uuid) RETURNS TABLE(id uuid, value numeric, minquantity integer, maxvalue numeric, minprice numeric, priority integer, ispercentage boolean, createdat timestamp without time zone, type public.citext)
    LANGUAGE plpgsql
    AS $$
    BEGIN
    RETURN QUERY
        select dinfo.id, dinfo.value, dinfo.minquantity, dinfo.maxvalue,dinfo.minprice, dinfo.priority, dinfo.ispercentage,dinfo.createdat,dinfo.type from discountinfo dinfo
               inner join discountchannel disch on disch.discountid = dinfo.id
               inner join discountbranch disbr on disbr.discountid = dinfo.id
        where
 ((case when (dinfo.availablefrom::time < dinfo.availableto::time) then
                 case when ((dinfo.availablefrom::time <= ((now())::time + interval '3 hour')) and (dinfo.availableto::time >= (now())::time))  then 1 else 0 end
             else
                 case when ((dinfo.availableto::time <= (now())::time + interval '3 hour') and (dinfo.availablefrom::time >= (now())::time))  then 0 else 1 end
		   end) =1)            and
            ((dinfo.availablefrom)::date) <= ((now())::date)  and ((dinfo.availableto)::date) >= ((now())::date)
            and
            (select to_char ( (now()), 'D'  )::integer) = any (dinfo.daysofweek)
            and disch.channelid = _channelid
            and disbr.branchid = _branchid
            and dinfo.ispublished is true
            and dinfo.isdeleted is not true
            and dinfo.isavailable is true
            and dinfo.type = 'Total' order by dinfo.priority desc,dinfo.createdat desc LIMIT 1;
    END;
$$;


--
-- Name: discountinfo; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.discountinfo (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    name public.citext,
    type public.citext,
    description public.citext,
    promocode public.citext,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext,
    priority integer DEFAULT 1 NOT NULL,
    noofuse integer,
    noofusefrocustomer integer,
    isdaily boolean DEFAULT false NOT NULL,
    isavailable boolean DEFAULT true NOT NULL,
    level public.citext,
    daysofweek integer[],
    availablefrom timestamp without time zone,
    availableto timestamp without time zone,
    ispercentage boolean,
    value numeric,
    maxvalue numeric,
    minquantity integer,
    minprice numeric,
    companyid uuid,
    descriptionlanguage jsonb
);


--
-- Name: getnowdiscountsinfo(timestamp without time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getnowdiscountsinfo(_timestamp timestamp without time zone) RETURNS SETOF public.discountinfo
    LANGUAGE plpgsql
    AS $$
    BEGIN
    RETURN QUERY
        select * from discountinfo dinfo
        where
            ((dinfo.availablefrom)::time) <= ((_timestamp)::time)  and ((dinfo.availableto)::time) >= ((_timestamp)::time)
            and
            ((dinfo.availablefrom)::date) <= ((_timestamp)::date)  and ((dinfo.availableto)::date) >= ((_timestamp)::date)
            and
            (select to_char ( (_timestamp), 'D'  )::integer) = any (dinfo.daysofweek);
    END;
$$;


--
-- Name: getnowdisountsforagent(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getnowdisountsforagent(_productid uuid, _branchid uuid) RETURNS TABLE(discount json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select 

json_build_object('name' , name,
												 'ispercentage', ispercentage,
												 'discountpercent' , discountpercent,
												 'discountvalue' , discountvalue,
												 'maxdiscountprice' , maxdiscountprice,
												 'mindiscountquantity' , mindiscountquantity,
											     'mindiscountprice',mindiscountprice)	from discount where 
--time is available by now
((fromtime is null ) or (fromtime::time <= (now() AT TIME ZONE 'Asia/Amman'::text)::time)) and
((totime is null ) or (totime::time >= (now() AT TIME ZONE 'Asia/Amman'::text)::time)) and
--date is available by now
((fromdate is null ) or (fromdate::date <= (now() AT TIME ZONE 'Asia/Amman'::text)::date)) and
((todate is null ) or (todate::date >= (now() AT TIME ZONE 'Asia/Amman'::text)::date)) and
--today is actually on this offer
((daysofweek is null ) or (select to_char((now() AT TIME ZONE 'Asia/Amman'::text)::timestamp,'D')::integer = any(daysofweek)))
and isdeleted = false
--without promocodes
and promocode is null
--is on product not in attributes 
and attributeids is null
--product limitation
and _productid =any(productids)
--branch limitation
and _branchid =any(branchids)
order by createdat desc
limit 1;

END;
$$;


--
-- Name: getnowpromocode(public.citext, uuid, uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getnowpromocode(_promocode public.citext, _branchid uuid DEFAULT NULL::uuid, _customerid uuid DEFAULT NULL::uuid, _channelid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, name public.citext, type public.citext, value numeric, maxvalue numeric, minquantity integer, minprice numeric, numberofusecustomer integer, numberofusage integer, isdaily boolean, ispercentage boolean, numberofuse bigint, customerids jsonb, customerorder jsonb)
    LANGUAGE plpgsql
    AS $$

    BEGIN
    RETURN QUERY
        select proc.id, proc.name, proc.type, proc.value, proc.maxvalue, proc.minquantity, proc.minprice, proc.numberofusecustomer, proc.numberofusage, proc.isdaily, proc.ispercentage, proc.numberofuse,
        (select to_json(array (
                           select to_json(
                               jsonb_build_object( 'customerid',procus.customerid,
                                                   'promocodeid',procus.promocodeid,
                                                   'numberofusage',procus.numberofusage,
                                                   'lasttime', ((now() + interval '3 hour') - (lastusetime))::time
                                                 ))
                               from promocodecustomers procus where promocodeid = proc.id ))::jsonb),
        (select to_json(array (
                           select to_json(
                               jsonb_build_object( 'customerid',ord.customerid,
                                                   'numberofusage',count(ord.id),
                                                   'lasttime', ((now() + interval '3 hour') - (max(ord.createdat)))::time
                                                 ))
                               from promocode prc INNER JOIN "order" ord on(((ord.price->>'PromoCode')::Json)->>'Id')::uuid = prc.id where proc.id = (((ord.price->>'PromoCode')::Json)->>'Id')::uuid and ord.customerid = _customerid group by ord.customerid ))::jsonb)
                               
        from promocode proc INNER JOIN promocodebranch prbr on prbr.promocodeid = proc.id
        INNER JOIN promocodechannel proch on proch.promocodeid = proc.id
        where
            ((case when (proc.availablefrom::time < proc.availableto::time) then
                 case when ((proc.availablefrom::time <= ((now())::time + interval '3 hour')) and (proc.availableto::time >= (now())::time))  then 1 else 0 end
             else
                 case when ((proc.availableto::time <= (now())::time + interval '3 hour') and (proc.availablefrom::time >= (now())::time))  then 0 else 1 end
		   end) =1) and
            ((proc.availablefrom)::date) <= ((now())::date)  and ((proc.availableto)::date) >= ((now())::date)
            and
            (select to_char ( (now()), 'D'  )::integer) = any (proc.daysofweek)
            and proc.name = _promocode
            and prbr.branchid = _branchid
            and proch.channelid = _channelid
            and proc.isavailable = true and proc.isdeleted = false  
            order by proc.priority desc,proc.createdat desc LIMIT 1;
    END;
$$;


--
-- Name: getofferlogo(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getofferlogo(_companyid uuid) RETURNS SETOF public.citext
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select coalesce(NULLIF(LTRIM(RTRIM(offerlogo)), '') ,(select logo from company where id = _companyid))::citext from orderconfig where companyid =_companyid;
    END;
$$;


--
-- Name: getoffersimages(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getoffersimages(_companyid uuid) RETURNS TABLE(imagepath public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select offerimage.imagepath from offerimage where companyid = _companyid and isdeleted = false and ispublished = true;
END;
$$;


--
-- Name: getoldprinter(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getoldprinter(_jobid uuid) RETURNS TABLE(name public.citext[])
    LANGUAGE plpgsql
    AS $$

BEGIN
RETURN QUERY

--USE
 select printername from printingorder where id = _jobid;
END;
$$;


--
-- Name: getonlineuserotpbyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getonlineuserotpbyid(_id uuid) RETURNS TABLE(userid uuid, otpcode public.citext, createdat timestamp without time zone)
    LANGUAGE plpgsql
    AS $$

BEGIN
RETURN QUERY

select c.id,c.verifycode,c.verifycodetime from customer c where c.id = _id;
END;
$$;


--
-- Name: getonlineusers(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getonlineusers(_id uuid) RETURNS TABLE(id uuid, name public.citext, phone public.citext, email public.citext, verified boolean, lastlogin public.citext, lastloginip public.citext, image public.citext)
    LANGUAGE plpgsql
    AS $$

BEGIN
RETURN QUERY

select c.id,c.name,c.phoneno,c.email,c.isverify,null::citext,null::citext,c.image  from customer c where c.id = _id;
END;
$$;


--
-- Name: getonlineusersbyphone(public.citext, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getonlineusersbyphone(_phone public.citext, _companyid uuid) RETURNS TABLE(id uuid, name public.citext, phone public.citext, fullphonenumber public.citext, email public.citext, verified boolean, lastlogin public.citext, lastloginip public.citext, image public.citext)
    LANGUAGE plpgsql
    AS $$

BEGIN
RETURN QUERY

select c.id,c.name,c.phoneno,c.fullphonenumber,c.email,c.isverify,null::citext,null::citext,c.image  from restaurantcustomer rc
                                                                                   inner join customer c on c.id = rc.customerid
                                                                                   where c.phoneno = _phone and rc.restaurantid = _companyid;
END;
$$;


--
-- Name: getoperationalhoursforbranch(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getoperationalhoursforbranch(_branchid uuid) RETURNS SETOF jsonb[]
    LANGUAGE plpgsql
    AS $$
    BEGIN
        return query
    select case when
    (EXTRACT(EPOCH FROM (to_char(closetime::time,'HH24:MI')::time - to_char(opentime::time,'HH24:MI')::time ))) < 0

    then

    Array(
    select to_json(json_build_object('start_time',to_char(opentime::time,'HH24:MI'),'end_time','23:59'))::jsonb
    union
    select to_json(json_build_object('start_time','00:00','end_time',to_char(closetime::time,'HH24:MI')))::jsonb)
    ::jsonb[]

    else
        Array(
    select to_json(json_build_object('start_time',to_char(opentime::time,'HH24:MI'),'end_time',to_char(closetime::time,'HH24:MI')))::jsonb) end
 from branch where id = _branchid;

    end;
    
$$;


--
-- Name: getoperationalhoursforbranch_careem(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getoperationalhoursforbranch_careem(_branchid uuid) RETURNS SETOF jsonb[]
    LANGUAGE plpgsql
    AS $$
    BEGIN
        return query
    select case when
    (EXTRACT(EPOCH FROM (to_char(closetime::time,'HH24:MI')::time - to_char(opentime::time,'HH24:MI')::time ))) < 0

    then

    Array(
    select to_json(json_build_object('start_time',to_char('00:00'::time,'HH24:MI'),'end_time','23:59'))::jsonb
    union
    select to_json(json_build_object('start_time','00:00','end_time',to_char('23:59'::time,'HH24:MI')))::jsonb)
    ::jsonb[]

    else
        Array(
    select to_json(json_build_object('start_time',to_char('00:00'::time,'HH24:MI'),'end_time',to_char('23:59'::time,'HH24:MI')))::jsonb) end
 from branch where id = _branchid;

    end;
$$;


--
-- Name: getoption(uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getoption(_id uuid DEFAULT NULL::uuid, _languagecode public.citext DEFAULT 'en'::public.citext) RETURNS TABLE(id uuid, name public.citext, suboptionid uuid, attributeid uuid, ispreselected boolean, quantity integer, createdat timestamp without time zone, createdby public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select option.id, getvalue(_languagecode,'optionName',option.id,1),option.suboptionid, option.attributeid, option.ispreselected, option.quantity, option.createdat, option.createdby 
from option where option.id = _id and isdeleted = false and ispublished = true;

END;
$$;


--
-- Name: getoptionchildren(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getoptionchildren(_attributeid uuid DEFAULT NULL::uuid) RETURNS SETOF json[]
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select array(select to_json(json_build_object(
	'id',l3.id,
    'deleted',l3.isdeleted,
	'name',case when ((((l3.name->>'ar')::citext) is not null) and (((l2.name->>'ar')::citext) is not null)) then concat(((l2.name->>'ar')::citext), ' - ' , ((l3.name->>'ar')::citext)) else concat(((l2.name->>'en')::citext),' - ',((l3.name->>'en')::citext)) end,
    'name_localized',json_build_object('en',concat(((l2.name->>'en')::citext),' - ',((l3.name->>'en')::citext)),'ar',concat(((l2.name->>'ar')::citext), ' - ' ,((l3.name->>'ar')::citext))),
    'active',l3.isavailable,
    'price', ((((l1.price::json)->>'callcenter')::numeric) + (((l2.price::json)->>'callcenter')::numeric) + (((l3.price::json)->>'callcenter')::numeric)),
    'priority',l3.priority
    ))
        from productattribute l3
        inner join productattribute l2 on l3.attributeid = l2.id
        inner join productattribute l1 on l2.attributeid = l1.id
             where l3.attributeid = _attributeid and l3.isdeleted = false
        )::json[];
END;
$$;


--
-- Name: getoptionchildren_careem(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getoptionchildren_careem(_attributeid uuid DEFAULT NULL::uuid) RETURNS SETOF json[]
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select array(select to_json(json_build_object(
	'id',l3.id,
    'deleted',l3.isdeleted,
	'name',case when ((((l3.name->>'ar')::citext) is not null) and (((l2.name->>'ar')::citext) is not null)) then concat(((l2.name->>'ar')::citext), ' - ' , ((l3.name->>'ar')::citext)) else concat(((l2.name->>'en')::citext),' - ',((l3.name->>'en')::citext)) end,
    'name_localized',json_build_object('en',concat(((l2.name->>'en')::citext),' - ',((l3.name->>'en')::citext)),'ar',concat(((l2.name->>'ar')::citext), ' - ' ,((l3.name->>'ar')::citext))),
    'active',l3.isavailable,
    'price', ((((l1.price::json)->>'careem')::numeric) + (((l2.price::json)->>'careem')::numeric) + (((l3.price::json)->>'careem')::numeric)),
    'priority',l3.priority
    ))
        from productattribute l3
        inner join productattribute l2 on l3.attributeid = l2.id
        inner join productattribute l1 on l2.attributeid = l1.id
             where l3.attributeid = _attributeid and l3.isdeleted = false
        )::json[];
END;
$$;


--
-- Name: getoptionchildrenanswer(uuid, public.citext, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getoptionchildrenanswer(_menuid uuid, _channel public.citext, _attributeid uuid DEFAULT NULL::uuid) RETURNS SETOF json[]
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select array(select to_json(json_build_object(
    'questionid', _attributeid,
	'id',l3.id,
    'deleted',l3.isdeleted,
	'name',l3.name,
    'isavailable',l3.isavailable,
    'minimumcount',l3.minimumcount,
    'maximumcount',l3.maximumcount,
    'controltype',l3.controltype,
    'description',l3.description,
    'discount',(select getattrbiuteiscountishbekinterface(_id := l3.id,_channel := _channel)),
    'branches', ARRAY(select getbranchforcategorybymenuidandchannel(_id := _menuid,_callid := l3.id,_channel :=_channel)),
    'price', ((((l1.price)->_channel)::decimal) + (((l2.price)->_channel)::decimal) + (((l3.price)->_channel)::decimal)),
    'priority',l3.priority
    ))
        from productattribute l3
        inner join productattribute l2 on l3.attributeid = l2.id
        inner join productattribute l1 on l2.attributeid = l1.id
             where l3.attributeid = _attributeid and l3.isdeleted = false
        )::json[];
END;
$$;


--
-- Name: getoptionchildrenidanswer(uuid, public.citext, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getoptionchildrenidanswer(_menuid uuid, _channel public.citext, _attributeid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select  l3.id 
        from productattribute l3
        inner join productattribute l2 on l3.attributeid = l2.id
        inner join productattribute l1 on l2.attributeid = l1.id
             where l3.attributeid = _attributeid and l3.isdeleted = false
        ;
END;
$$;


--
-- Name: getoptions(uuid[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getoptions(_productids uuid[]) RETURNS TABLE(options json)
    LANGUAGE plpgsql
    AS $$

BEGIN
RETURN query
select
    to_json(array(select to_json(unnest(
            case
                when ((select doeshavechildren(lv2.id)))
                    then (select getoptionchildren(lv2.id))--create function to get 3lvls
                else
                    array(select to_json(json_build_object(
                            'id', lv2.id,
                            'deleted', lv2.isdeleted,
                            'ischatbotquestion', lv2.ischatbotquestion,
                            'name',
                            case when (lv2.name ->> 'en' is not null) then lv2.name ->> 'en' else lv2.name ->> 'ar' end,
                            'name_localized', json_build_object('en', lv2.name ->> 'en', 'ar', lv2.name ->> 'ar'),
                            'active', lv2.isavailable,
                            'price', case
                                         when ((lv1.price::jsonb ->> 'careem' is not null) and
                                               (lv2.price::jsonb ->> 'careem' is not null)) then (
                                                 (((lv1.price::jsonb) ->> 'careem')::decimal) +
                                                 (((lv2.price::jsonb) ->> 'careem')::decimal))
                                         else ((((lv1.price::jsonb) ->> 'default')::decimal) +
                                               (((lv2.price::jsonb) ->> 'default')::decimal)) end,
                            'priority', lv2.priority
                        )))::json[]
                end))
            from productattribute lv1
            left join productattribute lv2 on lv1.id = lv2.attributeid
            where lv1.productid = any(_productids) and lv1.isdeleted = false and lv2.isdeleted = false ));
END;
$$;


--
-- Name: getoptions(integer, integer, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getoptions(_pagenumber integer DEFAULT NULL::integer, _pagesize integer DEFAULT NULL::integer, _languagecode public.citext DEFAULT 'en'::public.citext) RETURNS TABLE(id uuid, name public.citext, suboptionid uuid, attributeid uuid, ispreselected boolean, quantity integer, createdat timestamp without time zone, createdby public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select  
option.id, getvalue(_languagecode,'optionName',option.id,1),option.suboptionid, option.attributeid, option.ispreselected, option.quantity, option.createdat, option.createdby 
from option where isdeleted = false and ispublished = true
LIMIT _pagesize
OFFSET ((_pagenumber-1) * _pagesize);

END;
$$;


--
-- Name: getoptions_careem(uuid[], uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getoptions_careem(_productids uuid[], _branchid uuid) RETURNS TABLE(options json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN query
select
    to_json(array(select to_json(unnest(
            case
                when ((select doeshavechildren_careem(lv2.id)))
                    then (select getoptionchildren_careem(lv2.id))--create function to get 3lvls
                else
                    array(select to_json(json_build_object(
                            'id', lv2.id,
                            'deleted', lv2.isdeleted,
                            'name',
                            case when (lv2.name ->> 'en' is not null) then lv2.name ->> 'en' else lv2.name ->> 'ar' end,
                            'name_localized', json_build_object('en', lv2.name ->> 'en', 'ar', lv2.name ->> 'ar'),
                            'active', CASE WHEN (
        SELECT COUNT(*)
        FROM branchavailability ba
        WHERE ba.objecttype = 'subattribute'
          AND ba.objectid = lv2.id
          AND ba.branchid = _branchid
          AND  ba.channelid = '0c698066-ce70-483f-8da6-968465fd697a'
    ) > 0 THEN false
    ELSE true
END,
                            'price', case
                                         when ((lv1.price::jsonb ->> 'careem' is not null) and (lv2.price::jsonb ->> 'careem' is not null))
                                             then (
                                             (((lv1.price::jsonb) ->> 'careem')::decimal) + (((lv2.price::jsonb) ->> 'careem')::decimal)
                                             )
                                         else (  (((lv1.price::jsonb) ->> 'default')::decimal) + (((lv2.price::jsonb) ->> 'default')::decimal)) end,
                            'priority', lv2.priority
                        )))::json[]
                end))
            from productattribute lv1
            inner join productattribute lv2 on lv1.id = lv2.attributeid
            where lv1.productid = any (_productids)
                and lv1.attributeid is null and lv1.isdeleted = false and lv2.isdeleted = false ));
END;
$$;


--
-- Name: getoptionsforcareemdto(uuid[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getoptionsforcareemdto(_productids uuid[]) RETURNS TABLE(options json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN query
select
    to_json(array(select to_json(unnest(
            case
                when ((select doeshavechildren(lv2.id)))
                    then (select getoptionchildren(lv2.id))--create function to get 3lvls
                else
                    array(select to_json(json_build_object(
                            'id', lv2.id,
                            'deleted', lv2.isdeleted,
                            'name',
                            case when (lv2.name ->> 'en' is not null) then lv2.name ->> 'en' else lv2.name ->> 'ar' end,
                            'name_localized', json_build_object('en', lv2.name ->> 'en', 'ar', lv2.name ->> 'ar'),
                            'active', lv2.isavailable,
                            'price', case
                                         when ((lv1.price::jsonb ->> 'callcenter' is not null) and (lv2.price::jsonb ->> 'callcenter' is not null))
                                             then (
                                             (((lv1.price::jsonb) ->> 'callcenter')::decimal) + (((lv2.price::jsonb) ->> 'callcenter')::decimal)
                                             )
                                         else (  (((lv1.price::jsonb) ->> 'default')::decimal) + (((lv2.price::jsonb) ->> 'default')::decimal)) end,
                            'priority', lv2.priority
                        )))::json[]
                end))
            from productattribute lv1
            inner join productattribute lv2 on lv1.id = lv2.attributeid
            where lv1.productid = any (_productids)
                and lv1.attributeid is null and lv1.isdeleted = false and lv2.isdeleted = false ));
END;
$$;


--
-- Name: getorderbybranchandstatus(uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getorderbybranchandstatus(_branchid uuid, _status public.citext) RETURNS SETOF public."order"
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select * from "order" where (isdeleted = false and ispublished=true and branchid = _branchid and  currentstatus= _status) ;
END;
$$;


--
-- Name: getorderbybranchid(uuid[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getorderbybranchid(_branchid uuid[]) RETURNS TABLE(branchorderid public.citext, id uuid, phoneno public.citext, referencenumber public.citext, ordersourceid uuid, customername public.citext, branchid uuid, branchname public.citext, reminder timestamp without time zone, iscanceled boolean, ordersource public.citext, deliverytype public.citext, deliveryname public.citext, createdat timestamp without time zone, currentstatus public.citext, statuscolor public.citext, nextstatus uuid, isfirst boolean, islast boolean, isautoaccept boolean, delayinminutes integer, price numeric, latitude numeric, longtitude numeric, phonenumber public.citext, scheduled boolean, scheduledate timestamp without time zone)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select
O.branchorderid::citext,
O.id,
c.phoneno,
o.referencenumber2,
o.ordersource,
C.name,
BR.id as branchid,
BR.name,
O.reminder,
O.iscanceled,
NL.name::citext as ordersource,
(select NL1.name from namelookup NL1 where  NL1.id = O.deliverytype)::citext AS "deliverytype",
(select dc.name->>'en' from deliverycompany dc where dc.id = O.deliverytype)::citext AS "deliveryname",
--CASE WHEN CL.name = 'Careem' THEN 'CareemNow' ELSE (CASE WHEN CL.name = 'Callcenter' THEN ( case when DC.name->>'en'::citext is null then NL.name else DC.name->>'en'::citext end ) ELSE 'Talabat' END)::citext END ::citext AS "deliverytype",
O.createdat,
CASE WHEN O.isdeclined is true then 'Declined' else OP.status end as currentstatus,
CASE WHEN O.isdeclined is true then 'red' else OP.color end as statuscolor,
OP.nextstatus ,
coalesce(OP.isfirststatus,false) as isfirst,
OP.islaststatus,
BR.isautoaccept,
coalesce(BR.delay->>'Min','0')::integer as delayinminutes,
(O.price->>'Total')::numeric AS price,
BR.latitude,
BR.longtitude,
BR.phonenumber,
CASE
    when O.scheduled is not null  then true
    else false
  END,
O.scheduled
from "order" O
JOIN customer C on C.id = O.customerid
JOIN namelookup NL ON O.ordersource = NL.id
--JOIN channellookup CL ON CL.id = O.ordersource
--JOIN orderstatuspossibilities OP ON O.currentstatus = OP.id
JOIN orderstatuspossibilities1 OP ON O.currentstatus = OP.id
LEFT JOIN deliverycompany DC ON DC.id = O.deliverytype
JOIN branch BR on BR.id = O.branchid
where BR.id = any(_branchid)
and isdeclined != true and isseen is null
and O.isready is false
and ((O.scheduled is null) or ((O.reminder <= ((now() AT TIME ZONE 'Asia/Amman'::text)::timestamp)) or (O.scheduled <= (now() at time zone 'Asia/Amman'::text)::timestamp)))
and O.createdat >= now() - interval '20 hour' order by O.createdat desc limit 150;
END;
$$;


--
-- Name: getorderconfigbycompanyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getorderconfigbycompanyid(_companyid uuid) RETURNS TABLE(id uuid, language public.citext, selectedservices uuid[], logo public.citext, registrationphoto public.citext, themecolor public.citext, buttoncolor public.citext, reservationtime timestamp without time zone, ordertime timestamp without time zone, preparetime timestamp without time zone, restaurantdomain public.citext, issms boolean, istrackorder boolean, ispuplished boolean, isdeleted boolean, createdat timestamp without time zone, createdby public.citext, updatedat timestamp without time zone, updatedby public.citext, deletedat timestamp without time zone, deletedby public.citext, companyid uuid, pickupbranchids uuid[], dineinbranchids uuid[], deliverybranchids uuid[], offerlogo public.citext, value text)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select *,
       (select  "companyinfo".value from companyinfo where type = 'Bio' and companyinfo.companyid = _companyid)
from "orderconfig" where "orderconfig".companyid = _companyid;

END;
$$;


--
-- Name: getordercurrentstatus(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getordercurrentstatus(_id uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, currentstatus public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select "order".id, "order".currentstatus from "order" where "order".id = _id and isdeleted = false and ispublished = true;
END;
$$;


--
-- Name: getordercurretnstatus(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getordercurretnstatus(_orderid uuid) RETURNS TABLE(islast boolean, status public.citext, color public.citext, isready boolean)
    LANGUAGE plpgsql
    AS $$

BEGIN
RETURN QUERY
-- select  coalesce(pos.islaststatus,false),pos.status,pos.color, "order".isready from "order"
-- inner join orderstatuspossibilities pos on "order".currentstatus = pos.id
--  where "order".id = _orderid;
    select  coalesce(pos.islaststatus,false),pos.status,pos.color, "order".isready from "order"
    inner join orderstatuspossibilities1 pos on "order".currentstatus = pos.id
    where "order".id = _orderid;
END;
$$;


--
-- Name: getordercustomerinfobyphone(public.citext, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getordercustomerinfobyphone(_phonenumber public.citext, _companyid uuid) RETURNS TABLE(id uuid, name public.citext, phoneno public.citext, countrycode public.citext, phoneno2 public.citext, lastorderdate date, email public.citext, fb public.citext, twitter public.citext, instagram public.citext, notes public.citext, isblocked boolean, elicashuserrefid public.citext, createdat timestamp without time zone, address json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY

select  "customer".id,"customer".name,"customer".phoneno,"customer".countrycode,"customer".phoneno2,"customer".Lastorderdate,"customer".Email,"customer".Fb,"customer".Twitter,"customer".Instagram,"customer".Notes,(select isapproved from blacklist where companyid = _companyid and customerid = "customer".id) ,ecu.refid, "customer".Createdat,
 to_json(
        Array(
             select  (
                to_json(
                    json_build_object(
                        'id',
                        csadd.addressid,
                        'name',
                        csadd.name,
                        'latitude',
                        csadd.latitude,
                        'longtitude',
                        csadd.longtitude,
                        'streetname',
                        csadd.streetname,
                        'details',
                        csadd.details,
                        'buildingno',
                        csadd.buildingno
						)
					))
			       from customeraddress csadd
                   inner join address on address.id = csadd.addressid
				   where csadd.customerid = "customer".id and csadd.isdeleted = 'false'
                   and ((select count(*) >0 from branchdeliverycharge bdc where bdc.id = csadd.labeladdressid and bdc.companyid = _companyid)
                   or (((select COUNT(*) > 0 from getbranchfordistance(_companyid,csadd.latitude,csadd.longtitude) ) or (select COUNT(*) > 0 from getbranchforcalculater(_companyid,csadd.latitude,csadd.longtitude))) and (csadd.labeladdressid is null )))
                   and csadd.name IS NOT NULL
                   order by csadd.createdat desc , csadd.updatedat desc limit 5
			)
          ) address
from customer
left join elicashusers ecu on ecu.customerid = "customer".id
WHERE  _phonenumber in("customer".phoneno, "customer".phoneno2) AND "customer".isdeleted = 'false' AND "customer".ispublished = 'true';
END;
$$;


--
-- Name: getorderdeliverycost(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getorderdeliverycost(_addressid uuid DEFAULT NULL::uuid, _branchid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, name public.citext, deliverycost numeric, haspricelist boolean)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select deliverycompany.id ,(deliverycompany.name->>'en')::citext  as name , case when(branchdeliveryaddress.deliverycost is not null) then branchdeliveryaddress.deliverycost else null::numeric END , deliverycompany.haspricelist from deliverycompany 
inner join branchdelivery on branchdelivery.deliverycompanyid = deliverycompany.id
left join branchdeliveryaddress on branchdeliveryaddress.branchdeliverycompany = branchdelivery.id 
left join branchaddress on branchaddress.id = branchdeliveryaddress.branchaddress
where (not deliverycompany.haspricelist and branchdelivery.branchid = _branchid )or  (branchaddress.addressid= _addressid and branchaddress.branchid = _branchid)  ;
END;
$$;


--
-- Name: orderfollowupdetails; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.orderfollowupdetails (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    orderid uuid,
    notes public.citext,
    usertype public.citext DEFAULT false,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext,
    customerid uuid,
    adminnote public.citext
);


--
-- Name: getorderfollowupdetailsbyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getorderfollowupdetailsbyid(_id uuid DEFAULT NULL::uuid) RETURNS SETOF public.orderfollowupdetails
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select * from orderfollowupdetails where orderid = _id and isdeleted = false and ispublished = true;
END;
$$;


--
-- Name: getorderfollowupdetailsbyuser(public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getorderfollowupdetailsbyuser(_usertype public.citext DEFAULT NULL::public.citext) RETURNS TABLE(id uuid, orderid uuid, ordertime timestamp without time zone, name public.citext, branchid uuid, customerid uuid, status public.citext, createdat timestamp without time zone)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select ordfp.id , ord.id, ord.createdat, br.name , ord.customerid, ord.branchid , ordsp.status, ordfp.createdat   
 from orderfollowupdetails AS ordfp
 inner join "order" AS ord
 on ordfp.orderid = "ord".id 
 inner join branch AS br
 on "ord".branchid = br.id
 inner join orderstatuspossibilities AS ordsp 
 on ordsp.id = ord.currentstatus
 where ordfp.createdby = 'agent' and ordfp.isdeleted = false and ordfp.ispublished = true;
END;
$$;


--
-- Name: getorderfollowupviewbybranch(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getorderfollowupviewbybranch(_id uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, ordercase public.citext, isagent boolean, isteamleader boolean, isbranch boolean, isdeleted boolean, ispublished boolean, createdat timestamp without time zone, createdby public.citext, updatedat timestamp without time zone, updatedby public.citext, deletedat timestamp without time zone, deletedby public.citext, details json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select fol.*,  to_json(
                            Array(
                                select
                                    to_json(
                                        json_build_object(
                                            'id',
                                            fold.id,
                                            'notes',
                                            fold.notes,     
                                             'usertype',
                                          fold.usertype, 
                                          'createdby',
                                          fold.createdby,
                                           'createdat',
                                          fold.createdat
                                        )
                                    )
                                from
                                    orderfollowupdetails fold 
										inner join "order" ord  on fold.orderid = ord.id where ord.branchid = _id
                            )
                        ) from orderfollowup fol where fol.id = _id and fol.isdeleted = false and fol.ispublished = true;
END;
$$;


--
-- Name: getorderfollowupviewbycustomerid(uuid, integer, integer, timestamp without time zone, timestamp without time zone, public.citext, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getorderfollowupviewbycustomerid(_companyid uuid DEFAULT NULL::uuid, _pagenumber integer DEFAULT 1, _pagesize integer DEFAULT 5, _fromtime timestamp without time zone DEFAULT NULL::timestamp without time zone, _totime timestamp without time zone DEFAULT NULL::timestamp without time zone, _customerphone public.citext DEFAULT NULL::public.citext, _customerid uuid DEFAULT NULL::uuid) RETURNS TABLE(branchorderid public.citext, phoneno public.citext, branchname public.citext, orderid uuid, customername public.citext, customerid uuid, status public.citext, ordertime timestamp without time zone, createdat timestamp without time zone, category public.citext, subcategory public.citext, notes public.citext, adminnote public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY

 select ord.branchorderid,c.phoneno,br.name ,ord.id as orderid, c.name,c.id,fol.status, ord.createdat,fol.createdat, fol.category, fol.subcategory, fold.notes,fold.adminnote from orderfollowup fol
 inner join "order" ord on fol.id = ord.id
 inner join orderfollowupdetails fold on fold.orderid = ord.id
 inner join customer c on c.id = fol.customerid
 inner join "branch" br on br.id = ord.branchid
 where ((_customerid is null) or (fol.customerid = _customerid)) and  ((_companyid is null) or (_companyid = br.companyid))
 and fol.isdeleted = false and fol.ordercase = 'Complain' and fol.ispublished=true and fold.isdeleted=false and fold.ispublished=true
 AND (_fromtime IS NULL OR _fromtime <= fol.createdat)
 AND (_totime IS NULL OR _totime >= fol.createdat)
 AND (
            (_customerphone IS NULL)
            OR (c.id = ANY (SELECT customer.id FROM customer WHERE c.phoneno LIKE concat('%', _customerphone, '%')))
        )
 order by ord.createdat desc
 LIMIT _pagesize
 OFFSET ((_pagenumber - 1) * _pagesize);
 END;
$$;


--
-- Name: getorderfollowupviewbycustomerid2(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getorderfollowupviewbycustomerid2(_companyid uuid DEFAULT NULL::uuid, _customerid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, status public.citext, createdat timestamp without time zone, category public.citext, subcategory public.citext, notes public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN

   
    if(_companyid is not null and _customerid is null) THEN
	RETURN QUERY select fol.id, fol.status, fol.createdat, fol.category, fol.subcategory, fold.notes  from orderfollowup fol
	inner join "order" ord on ord.id = fol.id
	inner join orderfollowupdetails fold on fold.orderid = ord.id 
	inner join "branch" br on br.id = ord.branchid 
	where br.companyid = _companyid
	and fol.ispublished=true and fold.isdeleted=false and fold.ispublished=true;
	end if;
	
	if(_companyid is null and _customerid is not null) THEN
	RETURN QUERY select fol.id, fol.status, fol.createdat, fol.category, fol.subcategory, fold.notes  from orderfollowup fol
	inner join "order" ord on ord.id = fol.id
	inner join orderfollowupdetails fold on fold.orderid = ord.id 
	inner join "branch" br on br.id = ord.branchid 
	where fol.customerid = _customerid
	and fol.ispublished=true and fold.isdeleted=false and fold.ispublished=true;
	end if;
	
	if(_companyid is not null and _customerid is not null) THEN
	RETURN QUERY select fol.id, fol.status, fol.createdat, fol.category, fol.subcategory, fold.notes  from orderfollowup fol
	inner join "order" ord on ord.id = fol.id
	inner join orderfollowupdetails fold on fold.orderid = ord.id 
	inner join "branch" br on br.id = ord.branchid 
	where br.companyid = _companyid and fol.customerid = _customerid
	and fol.ispublished=true and fold.isdeleted=false and fold.ispublished=true;
	end if;
	
	if(_companyid is null and _customerid is null) THEN
	RETURN QUERY select fol.id, fol.status, fol.createdat, fol.category, fol.subcategory, fold.notes from orderfollowup fol
 	inner join "order" ord on fol.id = ord.id
 	inner join orderfollowupdetails fold on fold.orderid = ord.id 
 	where fol.isdeleted = false and fol.ispublished=true and fold.isdeleted=false and fold.ispublished=true;
	end if;
	
 END;
$$;


--
-- Name: getorderfollowupviewbyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getorderfollowupviewbyid(_id uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, ordercase public.citext, isagent boolean, isteamleader boolean, isbranch boolean, isdeleted boolean, ispublished boolean, createdat timestamp without time zone, createdby public.citext, updatedat timestamp without time zone, updatedby public.citext, deletedat timestamp without time zone, deletedby public.citext, category public.citext, subcategory public.citext, customerid uuid, details json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select fol.*,  to_json(
                            Array(
                                select
                                    to_json(
                                        json_build_object(
                                            'id',
                                            fold.id,
                                            'notes',
                                            fold.notes,     
                                             'usertype',
                                          fold.usertype, 
                                          'createdby',
                                          fold.createdby,
                                           'createdat',
                                          fold.createdat
                                        )
                                    )
                                from
                                    orderfollowupdetails fold where orderid = _id
                            )
                        ) from orderfollowup fol where fol.id = _id and fol.isdeleted = false and fol.ispublished = true;
END;
$$;


--
-- Name: getorderfollowupviewbyorderid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getorderfollowupviewbyorderid(_orderid uuid DEFAULT NULL::uuid) RETURNS TABLE(note public.citext, adminnote public.citext, createdby public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN

RETURN QUERY

 select ofd.notes,ofd.adminnote,ofd.createdby from orderfollowupdetails ofd where orderid=_orderid;
 END;
$$;


--
-- Name: getorderhistory(uuid[], timestamp without time zone, timestamp without time zone, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getorderhistory(_branchids uuid[], _fromtime timestamp without time zone DEFAULT NULL::timestamp without time zone, _totime timestamp without time zone DEFAULT NULL::timestamp without time zone, _customerphone public.citext DEFAULT NULL::public.citext) RETURNS TABLE(branchorderid public.citext, id uuid, iscanceled boolean, ordersource public.citext, deliverytype public.citext, createdat timestamp without time zone, currentstatus public.citext, statuscolor public.citext, nextstatus uuid, isfirst boolean, islast boolean)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select "order".branchorderid,"order".id,"order".iscanceled,getlookupname("order".ordersource),getdeliverycompanyname("order".deliverytype),
"order".createdat,
case when "order".isdeclined=false then (select st.status from orderstatuspossibilities st where st.id ="order".currentstatus) else 'declined' end
,case when "order".isdeclined=false then (select st.color from orderstatuspossibilities st where st.id ="order".currentstatus) else 'red' end ,pos.nextstatus , pos.isfirststatus, pos.islaststatus
from "order"
inner join orderstatuspossibilities pos on "order".currentstatus =pos.id
where "order".branchid = Any (_branchids) and (pos.isfirststatus is null or pos.isfirststatus != true )
and ((_fromtime is null) or( _fromtime <= "order".createdat))
and ((_totime is null) or( _totime >= "order".createdat))
and "order".branchid = any(_branchids)
and ((_customerphone is null) or ("order".customerid = any(select customer.id from customer where phoneno like concat('%',_customerphone,'%'))))
order by createdat desc
;
END;
$$;


--
-- Name: orderhistory; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.orderhistory (
    id uuid NOT NULL,
    status public.citext NOT NULL,
    notes public.citext,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL
);


--
-- Name: getorderhistoryid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getorderhistoryid(_id uuid DEFAULT NULL::uuid) RETURNS SETOF public.orderhistory
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select * from orderhistory where id = _id;
END;
$$;


--
-- Name: getorderhistoryreport(uuid[], timestamp without time zone, timestamp without time zone, public.citext, integer, integer, public.citext, uuid[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getorderhistoryreport(_branchids uuid[], _fromtime timestamp without time zone DEFAULT NULL::timestamp without time zone, _totime timestamp without time zone DEFAULT NULL::timestamp without time zone, _customerphone public.citext DEFAULT NULL::public.citext, _pagenumber integer DEFAULT 1, _pagesize integer DEFAULT 5, _reference public.citext DEFAULT NULL::public.citext, _channelids uuid[] DEFAULT '{}'::uuid[]) RETURNS TABLE(branchorderid public.citext, branchid uuid, customername public.citext, id uuid, iscanceled boolean, ordersource public.citext, deliverytype public.citext, createdat timestamp without time zone, currentstatus public.citext, statuscolor public.citext, nextstatus uuid, isfirst boolean, islast boolean, branchname public.citext, price numeric, name public.citext, createdby public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT
         O.branchorderid                                                                              AS branchorderid
        ,O.branchid                                                                                   AS branchid
        ,C.name                                                                                       AS customername
        ,O.id                                                                                         AS id
        ,O.iscanceled                                                                                 AS iscanceled
        ,CL.name                                                                                      AS ordersource
        ,CASE
    WHEN DC.name->>'en'::citext IS NULL
     THEN NL.name
    ELSE DC.name->>'en'::citext
END::citext AS deliverytype
        ,O.createdat ::timestamp without time zone                                                    AS createdat
        ,CASE WHEN O.isdeclined is true then 'Declined' else st.status end                            AS currentstatus
        ,CASE WHEN O.isdeclined is true then 'red' else st.color end                                  AS statuscolor
        ,st.nextstatus                                                                                AS nextstatus
        ,st.isfirststatus                                                                             AS isfirst
        ,st.islaststatus                                                                              AS islast
        ,B.name                                                                                       AS branchname
        ,(O.price->>'Total')::numeric                                                                 AS price
        ,CL.name                                                                                      AS name
        ,O.createdby                                                                                  AS createdby
    FROM "order" O
JOIN branch B ON B.id = O.branchid
JOIN channellookup CL ON CL.id = O.ordersource
JOIN customer C ON C.id = O.customerid
LEFT JOIN deliverycompany DC ON DC.id = O.deliverytype
--LEFT JOIN orderstatuspossibilities st ON st.id = O.currentstatus
LEFT JOIN orderstatuspossibilities1 st ON st.id = O.currentstatus
LEFT JOIN namelookup NL ON NL.id = O.deliverytype
    WHERE
        O.branchid = ANY (_branchids)
        AND (st.isfirststatus IS NULL OR st.isfirststatus != true)
        AND (
            (_channelids IS NULL)
            OR (O.ordersource = ANY (_channelids))
        )
        AND (_fromtime IS NULL OR _fromtime <= O.createdat)
        AND (_totime IS NULL OR _totime >= O.createdat)
        AND O.branchid = ANY (_branchids)
        AND (
            (_customerphone IS NULL)
            OR (O.customerid = ANY (SELECT customer.id FROM customer WHERE phoneno LIKE concat('%', _customerphone, '%')))
        )
        AND (
            (_reference IS NULL)
            OR ((O.referencenumber->>'deliveryPlatformID')::citext LIKE concat('%', _reference, '%'))
            OR ((O.referencenumber->>'careem')::citext LIKE concat('%', _reference, '%'))
        )
    ORDER BY
        createdat DESC
    LIMIT
        _pagesize
    OFFSET
        ((_pagenumber - 1) * _pagesize);
END;
$$;


--
-- Name: getorderhistoryreportforoperation(uuid[], timestamp without time zone, timestamp without time zone, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getorderhistoryreportforoperation(_branchids uuid[], _fromtime timestamp without time zone DEFAULT NULL::timestamp without time zone, _totime timestamp without time zone DEFAULT NULL::timestamp without time zone, _customerphone public.citext DEFAULT NULL::public.citext) RETURNS TABLE(branchorderid public.citext, customername public.citext, branchname public.citext, id uuid, iscanceled boolean, ordersource public.citext, deliverytype public.citext, createdat timestamp without time zone, currentstatus public.citext, statuscolor public.citext, nextstatus uuid, isfirst boolean, islast boolean)
    LANGUAGE plpgsql
    AS $$

BEGIN
RETURN QUERY
select "order".branchorderid,(select cu.name from customer cu where cu.id = "order".customerid ),CONCAT(brs.name,'-',co.name)::citext,"order".id,"order".iscanceled,getlookupname("order".ordersource),getdeliverycompanyname("order".deliverytype),
"order".createdat,
case when "order".isdeclined=false then (select st.status from orderstatuspossibilities st where st.id ="order".currentstatus) else 'declined' end
,case when "order".isdeclined=false then (select st.color from orderstatuspossibilities st where st.id ="order".currentstatus) else 'red' end ,pos.nextstatus , pos.isfirststatus, pos.islaststatus
from "order"
inner join orderstatuspossibilities pos on "order".currentstatus =pos.id
left join branch brs on brs.id = "order".branchid
left join company co on co.id = brs.companyid
where "order".branchid = Any (_branchids) and (pos.isfirststatus is null or pos.isfirststatus != true )
and ((_fromtime is null) or( _fromtime <= "order".createdat))
and ((_totime is null) or( _totime >= "order".createdat))
and "order".branchid = any(_branchids)
and ((_customerphone is null) or ("order".customerid = any(select customer.id from customer where phoneno like concat('%',_customerphone,'%'))))
order by createdat desc
;
END;
$$;


--
-- Name: getorderinvoice(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getorderinvoice(_orderid uuid) RETURNS TABLE(companyimage public.citext, companyname public.citext, branchname public.citext, ordernotes public.citext, orderreferencenumber public.citext, branchorderid public.citext, pickuptype public.citext, isscheduled boolean, ordertime public.citext, orderdate public.citext, products json, deliverycost numeric, customer json, totalprice numeric)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select company.logo::citext , company.name , branch.name , ord.notes, ord.referencenumber,
ord.referencenumber , getdeliverycompanyname(ord.deliverytype),
case when ord.scheduled is null then false else true  end,
to_char( case when (ord.scheduled is null) then (ord.createdat::time) else (ord.scheduled::time) end, 'HH12:MI AM')::citext time,
to_char(case when (ord.scheduled is null) then ord.createdat::date else (ord.scheduled::date) end,'DD-MM-YYYY')::citext date,
to_json(Array(select to_json(json_build_object('productName',prd.name,'productNotes',ordpr.notes,'count',ordpr.itemcount,
'totalPrice' ,ordpr.pricetaxvalue,
'taxpercentage', ordpr.pricetaxpercentage,
                        'attributes',to_json(Array(select to_json(json_build_object('attributeName',prdatt.name,'attributes',ordpratt.children --need work to make it name array
										))from orderproductattribute ordpratt left join productattribute prdatt on ordpratt.attributeid = prdatt.id where ordpratt.orderproductid = ordpr.id))))
            from orderproduct ordpr left join product prd on ordpr.productid = prd.id
			where ordpr.orderid = ord.id)) products,
	ord.deliveryprice,
	to_json(json_build_object('name' ,	customer.name  , 'phone' , customer.phoneno ,'address', (select concat(getlocalizationvalue('ar' , 'subareaName' ,ad.subareaname , 1), ' - ', getlocalizationvalue('ar' , 'areaName' ,ad.areaname , 1) , ' - ',  getlocalizationvalue('ar' , 'cityName' ,ad.cityname , 1)) from address  ad where ad.id = ord.deliveryaddress),'addressdetails',
(select concat(customeraddress.name,' - ',customeraddress.details,' - ',customeraddress.streetname,' - ',customeraddress.buildingno) from customeraddress inner join address on customeraddress.addressid = address.id where customerid = ord.customerid  and customeraddress.addressid = ord.deliveryaddress))) customer , ord.totalprice totalprice
from "order" ord 
inner join branch on ord.branchid = branch.id
inner join company on branch.companyid = company.id
inner join customer on customer.id = ord.customerid
where ord.id = _orderid;

END;
$$;


--
-- Name: getordermanaulprinters2(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getordermanaulprinters2(_id uuid) RETURNS TABLE(jobid uuid, taxnumber public.citext, restaurantname public.citext, copies integer, branchname public.citext, branchid uuid, branchlogo public.citext, branchphone public.citext, printer public.citext, template public.citext, orderinfo json, clientinfo json, items json)
    LANGUAGE plpgsql
    AS $$

BEGIN
RETURN QUERY

--USE

select
propr.id,
(CASE WHEN brt.istaxnumber ='true'THEN (brt.taxnumbervalue)::citext END),
(CASE WHEN brt.isrestaurantname ='true'  THEN co.name END):: citext,
(CASE WHEN pr.type ='Cashier' THEN (pr.noofcopy)::integer ELSE '1' END),
(CASE WHEN brt.isbranchname ='true'  THEN br.name END):: citext,
br.id,
(CASE WHEN brt.islogo ='true'  THEN CONCAT('https://files.ishbek.com/',co.logo)::citext END)::citext ,
(CASE WHEN brt.isphonenumber ='true'  THEN br.phonenumber END):: citext,
pr.name,
(CASE WHEN pr.type ='Cashier' THEN '1' ELSE '2' END)::citext,
(CASE WHEN brt.isorderinfo ='true' THEN (to_json(json_build_object(
'orderNo',(CASE WHEN brt.isordernumber ='true'THEN  concat('*',ord.branchorderid,'*',(CASE WHEN (select namelookup.name from namelookup where namelookup.id = (select namelookup.id from namelookup where namelookup.id = ord.deliverytype))
is not null THEN 'P'
ELSE 'D' END)) END) ,
 'paymentStatus',(CASE WHEN ord.paymenttype NOT IN (select unnest(Array['CASH - pending','Cash' ,'prepaid'])::citext) THEN 'Paid'  ELSE 'UnPaid' END) ,
 'orderType',
(CASE WHEN brt.isordertype ='true' THEN
(CASE WHEN (select namelookup.name from namelookup where namelookup.id = ord.deliverytype )
is not null THEN (select namelookup.name from namelookup where namelookup.id = ord.deliverytype )
ELSE 'Delivery' END) END)
,'orderSource',
(CASE WHEN brt.isordersource ='true' THEN
(CASE WHEN (ord.referencenumber != '{}' and ord.referencenumber !='{
  "callcenter": null
}') THEN (
    select (CASE WHEN (select resoucevalue.reskey from (SELECT value::citext as resvalue,key::citext as reskey FROM jsonb_each((select ord1.referencenumber from "order" ord1 where ord1.id = ord.id)) where value !='null' and (SELECT COUNT(value::citext) as resvalue FROM jsonb_each((select ord1.referencenumber from "order" ord1 where ord1.id = ord.id)) where value !='null') = 1 ) as resoucevalue)
 = 'careem' THEN

    (select concat('Careem',':',resoucevalue.resvalue)  from (SELECT value::citext as resvalue,key::citext as reskey FROM jsonb_each((select ord1.referencenumber from "order" ord1 where ord1.id = ord.id)) where (value !='null' )) as resoucevalue)

    ELSE (select concat('TALABAT',':',(select trim(both '"' from (resoucevalue.resvalue))))  from (SELECT (value::citext) as resvalue,key::citext as reskey FROM jsonb_each((select ord1.referencenumber from "order" ord1 where ord1.id = ord.id)) where (value !='null' )) as resoucevalue  WHERE   (resoucevalue.reskey = 'shortCode' )) END)
    ) ELSE (select concat(name,' - ',(CASE WHEN (select namelookup.name from namelookup where namelookup.id = ord.deliverytype and namelookup.name = 'pickup')
is not null THEN 'P'
ELSE 'D' END))  from namelookup where id = ord.ordersource and isdeleted = false and ispublished = true)  END)
END)
, 'orderDate',
(CASE WHEN brt.iscreatetime ='true' THEN  ord.createdat END)
,'DeliveryPrice', (CASE WHEN brt.isdeliveryfees ='true' THEN ord.deliveryprice END),
 'scheduledorder', (CASE WHEN brt.isscheduletime ='true' THEN  ord.scheduled END),
 'tax',(CASE WHEN brt.istaxvalue ='true' THEN '0' END),
 'notes',
(CASE WHEN brt.isordernote ='true' THEN ord.notes END),
    
 'subTotal',(CASE WHEN brt.isorderprice ='true' THEN ord.subtotalprice END),
    'total',(CASE WHEN brt.istotal ='true' THEN ((ord.price->>'FinalPrice')::numeric)END)))) END)

,
to_json(json_build_object(
 'clientName', (CASE WHEN brt.iscustomername ='true' THEN cu.name END),
 'clientPhone',(CASE WHEN brt.iscustomerphone ='true' THEN cu.phoneno END),
 'clientAddress',(CASE WHEN brt.iscustomeraddress ='true' THEN (select concat(cua.name,'-',(select concat(brdc.city,'-',brdc.area,'-',brdc.subarea)from branchdeliverycharge brdc where brdc.id=cua.labeladdressid),'-',cua.streetname,'-',cua.notes,'-',cua.buildingno,'-',cua.details)
from customeraddress cua where cua.addressid = ord.deliveryaddress and cua.customerid = ord.customerid)END),'clientStreetNo',(CASE WHEN brt.iscustomeraddress ='true' THEN (select cua.streetname from customeraddress cua where cua.addressid = ord.deliveryaddress and cua.customerid = ord.customerid)END),'clientBuildingNo',(CASE WHEN brt.iscustomeraddress ='true' THEN(select cua.buildingno from customeraddress cua where cua.addressid = ord.deliveryaddress and cua.customerid = ord.customerid)END),'notes',(CASE WHEN brt.isdeliverynote ='true' THEN (select cua.notes from customeraddress cua where cua.addressid = ord.deliveryaddress and cua.customerid = ord.customerid )END))),
(CASE WHEN pr.type ='Cashier'  THEN  to_json(
        Array(
            select
                to_json(
                    json_build_object(
                        'item',
                        (prd.name->>(select languageselected from printers prlang where prlang.id = pr.id )::citext)::citext,
						'QTY',
						ordpr.itemcount,
						'notes',
                        (CASE WHEN brt.isproductnote ='true' THEN
						ordpr.notes END),
                        'price',
                        ordpr.pricesubtotal,
                        'topping',
                        (CASE WHEN brt.isattribute ='true' THEN
                        to_json(
                            Array(
                                select
                                    to_json(
                                        json_build_object(
                                            'attributename',
											(prdatt.name ->> (select languageselected from printers prlang where prlang.id = pr.id )::citext)::citext,
											'values',(CASE WHEN brt.issubattribute ='true' THEN (ordpratt.children)::json END),
                                            'notes',
                                            ordpratt.notes
                                        )
                                    )
                                from
                                    orderproductattribute ordpratt
                                    left join productattribute prdatt on ordpratt.attributeid = prdatt.id
								where ordpratt.orderproductid = ordpr.id
                            )
                        )END)
                    )
                )
            from
                orderproduct ordpr
                left join product prd on ordpr.productid = prd.id
                inner join  manualprintingorder propr1 on propr1.orderid = ordpr.orderid
			    where propr1.id = propr.id and propr1.printing = false
        )
    ) ELSE to_json(
        Array(
            select
                to_json(
                    json_build_object(
                        'item',
                        (prd.name ->> (select languageselected from printers prlang where prlang.id = pr.id )::citext)::citext,
						'QTY',
						ordpr.itemcount,
						'notes',
                        (CASE WHEN brt.isproductnote ='true' THEN
						ordpr.notes END),
                        'price',
                        ordpr.pricesubtotal,
                        'topping',
                        (CASE WHEN brt.isattribute ='true' THEN
                        to_json(
                            Array(
                                select
                                    to_json(
                                        json_build_object(
                                            'attributename',
											(prdatt.name ->> (select languageselected from printers prlang where prlang.id = pr.id )::citext)::citext,
											'values',
                                            (CASE WHEN brt.issubattribute ='true' THEN
											(ordpratt.children)::json END),
                                            'notes',
                                            ordpratt.notes
                                        )
                                    )
                                from
                                    orderproductattribute ordpratt
                                    left join productattribute prdatt on ordpratt.attributeid = prdatt.id
								where ordpratt.orderproductid = ordpr.id
                            )
                        )END)
                    )
                )
            from
                orderproduct ordpr
                left join product prd on ordpr.productid = prd.id
                inner join  manualprintingorder propr1 on propr1.orderid = ordpr.orderid
			    where propr1.id = propr.id and propr1.printing = false and prd.categoryid IN (select unnest(prs.categoryids) from printers prs where prs.name = pr.name and prs.type = 'Kitchen')
        )
    )  END) from printers pr INNER JOIN branchtemplate brt on pr.type = brt.type and pr.branchid = _id
INNER JOIN branch br on br.id=brt.branchid LEFT JOIN company co ON br.companyid = co.id
INNER JOIN "order" ord ON (ord.branchid = br.id and ord.branchid = _id)
INNER JOIN manualprintingorder propr ON (propr.orderid = ord.id and propr.printing = false and pr.name NOT IN (select unnest(propr1.printername) from manualprintingorder propr1 where propr1.id = propr.id))
INNER JOIN customer cu ON cu.id = ord.customerid where brt.isdeleted = 'false' and pr.branchid = _id and propr.branchid = _id ;
END;
$$;


--
-- Name: getordermanaulprintersdefaultv2(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getordermanaulprintersdefaultv2(_id uuid) RETURNS TABLE(jobid uuid, taxnumber public.citext, restaurantname public.citext, copies integer, branchname public.citext, branchid uuid, branchlogo public.citext, branchphone public.citext, printer public.citext, template public.citext, orderinfo json, clientinfo json, items json)
    LANGUAGE plpgsql
    AS $$

BEGIN
RETURN QUERY
--USE
select op.jobid, op.taxnumber, op.restaurantname, op.copies, op.branchname, op.branchid, op.branchlogo, op.branchphone, op.printer, op.template, op.orderinfo, op.clientinfo, op.items from orderprint op where op.branchid = _id and op.isdeleted = false
and (EXTRACT(EPOCH FROM ((now() AT TIME ZONE 'Asia/Amman'::text) - op.createdat)))::bigint > (5)::bigint;
END;
$$;


--
-- Name: getordermethod(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getordermethod(_id uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, type integer, title jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY

(select ('7f78870b-910a-4ece-9a78-f630c4a8df65')::uuid , 2 as type ,to_json(json_build_object('en', 'dinein','ar','الاكل بالمطعم'))::jsonb from orderconfig where _id = any(dineinbranchids)  
UNION 
select ('3b9f60af-a9d4-4bae-b267-f73b48ff06fc')::uuid , 1 as type , to_json(json_build_object('en', 'pickup','ar','استلام'))::jsonb from orderconfig where _id = any(pickupbranchids)
UNION 
select ('6d7b89d4-28a0-483d-a1fb-104719545138')::uuid , 3 as type ,to_json(json_build_object('en', 'delivery','ar','نوصيل'))::jsonb from orderconfig where _id = any(deliverybranchids)) order by type;
END;
$$;


--
-- Name: getorderprinters(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getorderprinters(_id uuid) RETURNS TABLE(orderid uuid, branchid uuid)
    LANGUAGE plpgsql
    AS $$
BEGIN 
RETURN QUERY

--use
select "order".id,"order".branchid from "order" where "order".id = _id;
END;
$$;


--
-- Name: getorderproduct(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getorderproduct(_id uuid) RETURNS TABLE(name jsonb, image public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select p.name ,CONCAT(getimagepathurl(p.imagepath),p.imagepath)::citext
from product p left join orderproduct ordp on p.id = ordp.productid
WHERE ordp.orderid = _id order by ordp.createdat desc;
END;
$$;


--
-- Name: getorderreports(uuid[], uuid[], timestamp without time zone, timestamp without time zone, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getorderreports(_branchids uuid[], _source uuid[] DEFAULT NULL::uuid[], _fromtime timestamp without time zone DEFAULT NULL::timestamp without time zone, _totime timestamp without time zone DEFAULT NULL::timestamp without time zone, _customerphone public.citext DEFAULT NULL::public.citext) RETURNS TABLE(id uuid, orderid public.citext, customername public.citext, customerphone public.citext, createdatdate public.citext, creationtime public.citext, branchname public.citext, ordertype public.citext, deliveryname public.citext, source public.citext, scheduled public.citext, createdby public.citext, accepttime timestamp without time zone, accptedby public.citext, iscanceled boolean, isdeclined boolean, declinetime timestamp without time zone, declinedby public.citext, isedited boolean, orderstatus public.citext, deliveryprice numeric, totalpricetaxed numeric, referenceids public.citext, paymenttype public.citext, buildingno public.citext, streetname public.citext, addressname public.citext, latitude numeric, longtitude numeric)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select ord.id,
       ord.branchorderid,
       cus.name,
       cus.phoneno,
       to_char(ord.createdat,'dd-mm-yyyy') :: citext as createdat,
       to_char(ord.createdat,'HH:MI AM') :: citext as createdat,
       branch.name ,
       getdeliverycompanynameforreport(ord.deliverytype),
       getdeliverycompanyname(ord.deliverytype),
	   getlookupname(ord.ordersource),
	   case when (ord.scheduled  is not null ) then ord.scheduled::citext else 'not scheduled ' end,
			ord.createdby ,
			(select oh.createdat from orderhistory oh where oh.id= ord.id and oh.status ='accepted'),
			(select oh.createdby from orderhistory oh where oh.id= ord.id and oh.status ='accepted'),
			ord.iscanceled,
			ord.isdeclined,
			(select oh.createdat from orderhistory oh where oh.id= ord.id and oh.status ='declined'),
			(select oh.createdby from orderhistory oh where oh.id= ord.id and oh.status ='declined'),
			ord.isedited,
			getorderstatus(ord.currentstatus),
			ord.deliveryprice,
			coalesce(nullif(ord.totalprice,0),(ord.price->>'FinalPrice')::numeric -  (ord.price->>'DeliveryPrice')::numeric) ,
			coalesce(nullif((ord.referencenumber->>'careem')::citext,''),(ord.referencenumber->>'deliveryPlatformID')::citext),
			ord.paymenttype,
            ca.buildingno,
            ca.streetname,
            ca.name as addressname,
            ca.latitude,
            ca.longtitude
            from "order" ord
            inner join customer cus on cus.id = ord.customerid
            inner join branch on branch.id = ord.branchid
            left join company co on co.id = branch.companyid
            left join customeraddress ca on ca.addressid = ord.deliveryaddress
            where ((_fromtime is null) or( _fromtime <= ord.createdat))
            and ((_totime is null) or( _totime >= ord.createdat))
            and ((_customerphone is null) or( _customerphone = cus.phoneno))
            and ord.branchid = any(_branchids)
            and ((_source is null) or (ord.ordersource = any(_source)))
            order by ord.createdat ASC;
END;
$$;


--
-- Name: getorderreportsjs(uuid[], uuid[], timestamp without time zone, timestamp without time zone, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getorderreportsjs(_branchids uuid[], _source uuid[] DEFAULT NULL::uuid[], _fromtime timestamp without time zone DEFAULT NULL::timestamp without time zone, _totime timestamp without time zone DEFAULT NULL::timestamp without time zone, _customerphone public.citext DEFAULT NULL::public.citext) RETURNS TABLE(report json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY

select to_json(array(select row_to_json(getorderreports(_branchids,_source,_fromtime,_totime,_customerphone))));
END;
$$;


--
-- Name: getordersbeforethreehours_ai(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getordersbeforethreehours_ai(_customerid uuid, _companyid uuid) RETURNS TABLE(tracklink public.citext, currentstatus public.citext, deliverystatus public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select ord.deliverytrackinglink,(select case when(ord.isdeclined) then 'Declined' else  (select getorderstatus(ord.currentstatus)) end ), ord.deliverystatus from "order" ord 
 where ord.customerid = _customerid 
 and ord.createdat between 
 (select now() at time zone 'Asia/Amman' - interval '3 hour' ) 
 and (select now() at time zone 'Asia/Amman') 
-- and ord.isdeleted = false and ord.ispublished = true
 and _companyid = (select companyid  from branch  where id  = ord.branchid)
order by createdat desc
limit 1;
END;
$$;


--
-- Name: getordersbybranchid(uuid[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getordersbybranchid(_branchid uuid[]) RETURNS SETOF public."order"
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select * from "order";
END;
$$;


--
-- Name: getordersbycustomer(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getordersbycustomer(_customerid uuid, _branchid uuid DEFAULT NULL::uuid) RETURNS SETOF public."order"
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select * from "order" where isdeleted = false and ispublished=true and customerid = _customerid and ( ( _branchid is null ) or ( branchid = _branchid) );

END;
$$;


--
-- Name: getorderseq(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getorderseq(_branchid uuid) RETURNS SETOF integer
    LANGUAGE plpgsql
    AS $$
BEGIN
if ((select count(branchid) from branchorderseq where branchid = _branchid) <1)
then 
insert into branchorderseq (branchid , seq)values(_branchid , 1);
RETURN QUERY (select 1::integer as seq);
else 
update branchorderseq set seq = seq +1 where branchid = _branchid ;
RETURN QUERY (select seq from branchorderseq where branchid = _branchid);
end if;
END
$$;


--
-- Name: ordernotificationsettings; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.ordernotificationsettings (
    branchid uuid NOT NULL,
    sound public.citext NOT NULL,
    volume numeric DEFAULT 0.9 NOT NULL,
    loop boolean DEFAULT false NOT NULL
);


--
-- Name: getordersound(uuid[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getordersound(_branchid uuid[]) RETURNS SETOF public.ordernotificationsettings
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select * from ordernotificationsettings where branchid = any (_branchid);
END;
$$;


--
-- Name: getordersource(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getordersource() RETURNS TABLE(name public.citext, id uuid)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select namelookup.name,namelookup.id from namelookup where tabletype like '%ordersource%';
END
$$;


--
-- Name: getordersource(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getordersource(_companyid uuid) RETURNS TABLE(name public.citext, acceptedorderscount numeric, acceptedsubtotalvalue numeric, ordercallcenter numeric, ordervaluecallcenter numeric, ordertalabat numeric, ordervaluetalabat numeric, orderonline numeric, ordervalueonline numeric, orderchatbot numeric, ordervaluechatbot numeric, ordermobile numeric, ordervaluemobile numeric)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select
    b.name ,
    (select coalesce(count(*) ,0)::integer from "order" o where branchid = b.id and isdeclined !=true) acceptedorderscount,
    (select coalesce(sum((price->>'SubTotal')::numeric) ,0)::numeric from "order" o where branchid = b.id and isdeclined !=true) as acceptedsubtotalvalue,
    (select coalesce(count(*),0) from "order" o where branchid = b.id and b.isdeleted!=true and o.ordersource=(select id from namelookup where name = 'callcenter')) ordercallcenter,
    (select coalesce(sum((price->>'Total')::numeric),0) from "order" o where o.branchid= b.id and o.ordersource=(select id from namelookup where name = 'callcenter')) ordervaluecallcenter,
    (select coalesce(count(*),0) from "order" o where branchid = b.id and b.isdeleted!=true and o.ordersource=(select id from namelookup where name = 'talabat')) ordertalabat,
    (select coalesce(sum((price->>'Total')::numeric),0) from "order" o where o.branchid= b.id and o.ordersource=(select id from namelookup where name = 'talabat')) ordervaluetalabat,
    (select coalesce(count(*),0) from "order" o where branchid = b.id and b.isdeleted!=true and o.ordersource=(select id from namelookup where name = 'onlineordering')) orderonline,
    (select coalesce(sum((price->>'Total')::numeric),0) from "order" o where o.branchid= b.id and o.ordersource=(select id from namelookup where name = 'onlineordering')) ordervalueonline,
    (select coalesce(count(*),0) from "order" o where branchid = b.id and b.isdeleted!=true and o.ordersource=(select id from namelookup where name = 'chatbot')) orderchatbot,
    (select coalesce(sum((price->>'Total')::numeric),0) from "order" o where o.branchid= b.id and o.ordersource=(select id from namelookup where name = 'chatbot')) ordervaluechatbot,
    (select coalesce(count(*),0) from "order" o where branchid = b.id and b.isdeleted!=true and o.ordersource=(select id from namelookup where name = 'mobileapp')) ordermobile,
    (select coalesce(sum((price->>'Total')::numeric),0) from "order" o where o.branchid= b.id and o.ordersource=(select id from namelookup where name = 'mobileapp')) ordervaluemobile
from branch b where companyid = _companyid ;

END;
$$;


--
-- Name: getordersourcereport(uuid, timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getordersourcereport(_companyid uuid, _fromtime timestamp without time zone DEFAULT NULL::timestamp without time zone, _totime timestamp without time zone DEFAULT NULL::timestamp without time zone) RETURNS TABLE(name public.citext, acceptedorderscount integer, acceptedsubtotalvalue numeric, ordercallcenter bigint, ordervaluecallcenter numeric, ordertalabat bigint, ordervaluetalabat numeric, orderonline bigint, ordervalueonline numeric, orderchatbot bigint, ordervaluechatbot numeric, ordermobile bigint, ordervaluemobile numeric)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select
    b.name ,
    (select coalesce(count(*) ,0)::integer from "order" o where branchid = b.id and isdeclined !=true and ((_fromtime is null) or( _fromtime <= o.createdat)) and ((_totime is null) or( _totime >= o.createdat))) acceptedorderscount,
    (select coalesce(sum((price->>'Total')::numeric) ,0)::numeric from "order" o where branchid = b.id and isdeclined !=true and ((_fromtime is null) or( _fromtime <= o.createdat)) and ((_totime is null) or( _totime >= o.createdat))) as acceptedsubtotalvalue,
    (select coalesce(count(*),0) from "order" o where branchid = b.id and b.isdeleted!=true and ((_fromtime is null) or( _fromtime <= o.createdat)) and ((_totime is null) or( _totime >= o.createdat)) and o.ordersource=(select id from namelookup nlk where nlk.name = 'callcenter')) ordercallcenter,
    (select coalesce(sum((price->>'Total')::numeric),0) from "order" o where o.branchid= b.id and o.ordersource=(select id from namelookup nlk where nlk.name = 'callcenter')and ((_fromtime is null) or( _fromtime <= o.createdat)) and ((_totime is null) or( _totime >= o.createdat))) ordervaluecallcenter,
    (select coalesce(count(*),0) from "order" o where branchid = b.id and b.isdeleted!=true and o.ordersource=(select id from namelookup nlk where nlk.name = 'talabat' and tabletype = 'ordersource')and ((_fromtime is null) or( _fromtime <= o.createdat)) and ((_totime is null) or( _totime >= o.createdat))) ordertalabat,
    (select coalesce(sum((price->>'Total')::numeric),0) from "order" o where o.branchid= b.id and o.ordersource=(select id from namelookup nlk where nlk.name = 'talabat' and tabletype = 'ordersource')and ((_fromtime is null) or( _fromtime <= o.createdat)) and ((_totime is null) or( _totime >= o.createdat))) ordervaluetalabat,
    (select coalesce(count(*),0) from "order" o where branchid = b.id and b.isdeleted!=true and o.ordersource=(select id from namelookup nlk where nlk.name = 'onlineordering')and ((_fromtime is null) or( _fromtime <= o.createdat)) and ((_totime is null) or( _totime >= o.createdat))) orderonline,
    (select coalesce(sum((price->>'Total')::numeric),0) from "order" o where o.branchid= b.id and o.ordersource=(select id from namelookup nlk where nlk.name = 'onlineordering')and ((_fromtime is null) or( _fromtime <= o.createdat)) and ((_totime is null) or( _totime >= o.createdat))) ordervalueonline,
    (select coalesce(count(*),0) from "order" o where branchid = b.id and b.isdeleted!=true and o.ordersource=(select id from namelookup nlk where nlk.name = 'chatbot')and ((_fromtime is null) or( _fromtime <= o.createdat)) and ((_totime is null) or( _totime >= o.createdat))) orderchatbot,
    (select coalesce(sum((price->>'Total')::numeric),0) from "order" o where o.branchid= b.id and o.ordersource=(select id from namelookup nlk where nlk.name = 'chatbot')and ((_fromtime is null) or( _fromtime <= o.createdat)) and ((_totime is null) or( _totime >= o.createdat))) ordervaluechatbot,
    (select coalesce(count(*),0) from "order" o where branchid = b.id and b.isdeleted!=true and o.ordersource=(select id from namelookup nlk where nlk.name = 'mobileapp')and ((_fromtime is null) or( _fromtime <= o.createdat)) and ((_totime is null) or( _totime >= o.createdat))) ordermobile,
    (select coalesce(sum((price->>'Total')::numeric),0) from "order" o where o.branchid= b.id and o.ordersource=(select id from namelookup nlk where nlk.name = 'mobileapp')and ((_fromtime is null) or( _fromtime <= o.createdat)) and ((_totime is null) or( _totime >= o.createdat))) ordervaluemobile
from branch b where b.companyid = _companyid;

END;
$$;


--
-- Name: getordersources(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getordersources(_id uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, name public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
--select distinct(ord.ordersource) ,getlookupname(ord.ordersource) from "order" ord WHERE ord.branchid = any(select br.id from branch br where br.companyid = _id);
select ord.ordersource , NL.name from "order" ord join namelookup NL ON NL.id = ord.ordersource  where ord.branchid  in (select br.id from branch br where br.companyid = _id) group by ord.ordersource , NL.name;

END;
$$;


--
-- Name: getorderstatus(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getorderstatus(_id uuid DEFAULT NULL::uuid) RETURNS SETOF public.citext
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
-- select st.status from orderstatuspossibilities st where id = _id and isdeleted = false and ispublished = true;
 select st.status from orderstatuspossibilities1 st where id = _id;
END;
$$;


--
-- Name: getorderstatuscolor(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getorderstatuscolor(_id uuid DEFAULT NULL::uuid) RETURNS SETOF public.citext
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select st.color from orderstatuspossibilities st where id = _id and isdeleted = false and ispublished = true;
END;
$$;


--
-- Name: getorderstatushistory(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getorderstatushistory(_orderid uuid) RETURNS TABLE(id uuid, status public.citext, notes public.citext, createdat timestamp without time zone, createdby public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select oh.id,oh.status,oh.notes,oh.createdat,oh.createdby from orderhistory oh where oh.id=_orderid;
		END;
$$;


--
-- Name: orderstatuspossibilities; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.orderstatuspossibilities (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    branchid uuid,
    status public.citext NOT NULL,
    nextstatus uuid,
    cancancel boolean DEFAULT false NOT NULL,
    companyid uuid,
    islaststatus boolean DEFAULT false NOT NULL,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext,
    color public.citext DEFAULT 'gray'::public.citext NOT NULL,
    isfirststatus boolean DEFAULT false
);


--
-- Name: getorderstatuspossibilitiesbybranchid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getorderstatuspossibilitiesbybranchid(_id uuid DEFAULT NULL::uuid) RETURNS SETOF public.orderstatuspossibilities
    LANGUAGE plpgsql
    AS $$
BEGIN
if((select COUNT(id)  from orderstatuspossibilities where branchid = _id and isdeleted = false and ispublished = true)> 0)
then
  return query select * from orderstatuspossibilities where branchid = _id and isdeleted = false and ispublished = true;
else
 return query select * from orderstatuspossibilities where companyid = (select companyid from branch where id = _id);
end if;
END;
$$;


--
-- Name: getorderstatuspossibilitiesbybranchidarray(uuid[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getorderstatuspossibilitiesbybranchidarray(_id uuid[] DEFAULT NULL::uuid[]) RETURNS TABLE(id uuid, branchid uuid, status public.citext, nextstatus uuid, cancancel boolean, companyid uuid, islaststatus boolean, isdeleted boolean, ispublished boolean, createdat timestamp without time zone, createadby public.citext, updatedat timestamp without time zone, updatedby public.citext, deleteadat timestamp without time zone, deletedby public.citext, color public.citext, isfirststatus boolean, branchname public.citext, nextname public.citext)
    LANGUAGE plpgsql
    AS $$
declare comapny uuid;
BEGIN
if((select COUNT(ps.id)  from orderstatuspossibilities ps where ps.branchid = Any (_id) and ps.isdeleted = false and ps.ispublished = true)> 0)
then
  return query select ps.*,getbranchname(ps.branchid), 
  (select nps.status from orderstatuspossibilities nps where nps.id = ps.nextstatus)
  from orderstatuspossibilities ps  where ps.branchid = Any (_id) and ps.isdeleted = false and ps.ispublished = true; 
else
comapny = (select distinct br.companyid from branch br where br.id = Any (_id));
 return query select ps.*,(concat(getcompanyname(comapny),' Company')::citext),(select nps.status from orderstatuspossibilities nps where nps.id = ps.nextstatus) from orderstatuspossibilities ps where ps.companyid =comapny ;
end if;
END;
$$;


--
-- Name: getorderstatuspossibilitiesbyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getorderstatuspossibilitiesbyid(_id uuid DEFAULT NULL::uuid) RETURNS SETOF public.orderstatuspossibilities
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select * from orderstatuspossibilities where id = _id and isdeleted = false and ispublished = true;
END;
$$;


--
-- Name: getorderstatussequence(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getorderstatussequence(_orderid uuid) RETURNS TABLE(isfirst boolean, islast boolean, isready boolean, isfoodready boolean)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
--     select
--     coalesce(pos.isfirststatus,false), pos.islaststatus, "order".isready
--     from "order"
--     inner join orderstatuspossibilities pos on "order".currentstatus =pos.id
--     where "order".id = _orderid;
    select coalesce(pos.isfirststatus,false), pos.islaststatus, "order".isready, pos.isfoodready
    from "order"
    inner join orderstatuspossibilities1 pos on "order".currentstatus =pos.id
    where "order".id = _orderid;
END;
$$;


--
-- Name: getorderview(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getorderview(_orderid uuid) RETURNS TABLE(id uuid, branchorderid public.citext, price jsonb, products json, currentstatus public.citext, ordersource uuid, ordersourcename public.citext, deliveryname public.citext, scheduled timestamp without time zone, deliverytype uuid, customerid uuid, branchid uuid, notes public.citext, numberofpeople public.citext, totalprice numeric, deliveryprice numeric, deliveryaddress uuid, subtotalprice numeric, referencenumber jsonb, totalpreparingtime public.citext, deliverystatus public.citext, paymenttype public.citext, createdat timestamp without time zone, createdby public.citext, branchname public.citext, customername public.citext, customerdateofbirth date, customerphoneno public.citext, customerphoneno2 public.citext, customeremail public.citext, customerimage public.citext, customerchannel uuid, customerloyalitypoints numeric, customerfb public.citext, customertwitter public.citext, customerinstagram public.citext, customerlastorderdate date, customerisblocked boolean, customernotes public.citext, customercreatedat timestamp without time zone, customercreatedby public.citext, address json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select
    ord.id,
    ord.branchorderid,
    ord.price,
    to_json(
        Array(
            select
                to_json(
                    json_build_object(
                        'id',
                        ordpr.id,
                        'orderid',
                        ordpr.orderid,
                        'productid',
                        ordpr.productid,
                        'productname',
                        prd.name,
                        'img',
                        prd.imagepath,
						'count',
						ordpr.itemcount,
						'createdat',
						prd.createdat,
						'createdby',
						prd.createdby,
                        'price',
                        ordpr.price,
                        'attributes',
                        to_json(
                            Array(
                                select
                                    to_json(
                                        json_build_object(
                                            'id',
                                            ordpratt.id,
                                            'orderproductid',
                                            ordpratt.orderproductid,
                                            'attributeid',
                                            ordpratt.attributeid,
                                            'attributename',
                                             prdatt.name,
                                            'pricesubtotal',
                                            ordpratt.pricesubtotal,
                                            'pricetaxvalue',
                                            ordpratt.pricetaxvalue,
                                            'pricetaxpercentage',
                                            ordpratt.pricetaxpercentage,
											'values',(ordpratt.children)::json,
                                            'notes',
                                            ordpratt.notes,
											'createdat',
											ordpratt.createdat,
											'createdby',
											ordpratt.createdby
                                        )
                                    )
                                from
                                    orderproductattribute ordpratt
                                    left join productattribute prdatt on ordpratt.attributeid = prdatt.id
								where ordpratt.orderproductid = ordpr.id
                            )
                        ),
                        'pricesubtotal',
                        ordpr.pricesubtotal,
                        'pricetaxvalue',
                        ordpr.pricetaxvalue,
                        'pricetaxpercentage',
                        ordpr.pricetaxpercentage,
                        'notes',
                        ordpr.notes
                    )
                )
            from
                orderproduct ordpr
                left join product prd on ordpr.productid = prd.id
			where ordpr.orderid = ord.id
        )
    ) products,
    getorderstatus(ord.currentstatus),
    ord.ordersource,
	getlookupname(ord.ordersource),
	case when (ord.deliverytype = 'ebf23c72-7003-4804-b981-727ef616e1d5')
	    then (select getlocaldeliveryname(ord.branchid))
	    else (Select getdeliverycompanyname(ord.deliverytype))
        end,
	ord.scheduled,
    ord.deliverytype,
    ord.customerid,
    ord.branchid,
    ord.notes,
	ord.numberofpeople,
    ord.totalprice,
    ord.deliveryprice,
    ord.deliveryaddress,
    ord.subtotalprice,
    ord.referencenumber,
    ord.totalpreparingtime,
    ord.deliverystatus,
    ord.paymenttype,
    ord.createdat,
    ord.createdby,
	getbranchname(ord.branchid),
    customer.name,
    customer.dateofbirth,
    customer.phoneno,
    customer.phoneno2,
    customer.email,
    customer.image,
    customer.channel,
    customer.loyalitypoints,
    customer.fb,
    customer.twitter,
    customer.instagram,
    customer.lastorderdate,
    customer.isblocked,
    customer.notes,
    customer.createdat,
    customer.createdby,
	json_build_object('en',(select to_json(json_build_object(
	                                                 'id', addr.id ,
	                                                 'name',addr.name ,
                                                     'latitude',addr.lat ,
	                                                 'longtitude', addr.lng ,
	                                                 'buildingno', addr.buildingnumber ,
	                                                 'streetname',addr.street,
	                                                 'details',addr.otherdetails,
	                                                 'addressname',addr.name,
	                                                 'city',ic.name_en,
                                                     'area',ia.name_en,
                                                     'subarea',addr.preferedsubarea
	                                        ))
from public.addresses addr
    join public.ishbekcities ic on addr.ishbekcityid = ic.cityid
    join public.ishbekareas ia on ia.areaid = addr.ishbekareaid and addr.ishbekcityid = ia.cityid
where addr.id = ord.deliveryaddress
                ),'ar', (select to_json(json_build_object(
                                                      'id', addr.id ,
	                                                 'name',addr.name ,
                                                     'latitude',addr.lat ,
	                                                 'longtitude', addr.lng ,
	                                                 'buildingno', addr.buildingnumber ,
	                                                 'streetname',addr.street,
	                                                 'details',addr.otherdetails,
	                                                 'addressname',addr.name,
	                                                 'city',ic.name_ar,
                                                     'area',ia.name_ar,
                                                     'subarea',addr.preferedsubarea
                                                        ))
from public.addresses addr
    join public.ishbekcities ic on addr.ishbekcityid = ic.cityid
    join public.ishbekareas ia on ia.areaid = addr.ishbekareaid and addr.ishbekcityid = ia.cityid
where addr.id = ord.deliveryaddress
))
from
    "order" ord
    left join customer on ord.customerid = customer.id
where
    ord.id = _orderid;
END;
$$;


--
-- Name: getorderviewfordelivery(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getorderviewfordelivery(_orderid uuid) RETURNS TABLE(id uuid, branchorderid public.citext, price jsonb, products json, currentstatus public.citext, ordersource uuid, ordersourcename public.citext, deliveryname public.citext, scheduled timestamp without time zone, deliverytype uuid, customerid uuid, branchid uuid, notes public.citext, numberofpeople public.citext, totalprice numeric, deliveryprice numeric, deliveryaddress uuid, subtotalprice numeric, referencenumber jsonb, totalpreparingtime public.citext, deliverystatus public.citext, paymenttype public.citext, createdat timestamp without time zone, createdby public.citext, branchname public.citext, customername public.citext, customerdateofbirth date, customerphoneno public.citext, customerphoneno2 public.citext, customeremail public.citext, customerimage public.citext, customerchannel uuid, customerloyalitypoints numeric, customerfb public.citext, customertwitter public.citext, customerinstagram public.citext, customerlastorderdate date, customerisblocked boolean, customernotes public.citext, customercreatedat timestamp without time zone, customercreatedby public.citext, address json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select
    ord.id,
    ord.branchorderid,
    ord.price,
    to_json(
        Array(
            select
                to_json(
                    json_build_object(
                        'id',
                        ordpr.id,
                        'orderid',
                        ordpr.orderid,
                        'productid',
                        ordpr.productid,
                        'productname',
                        prd.name,
                        'img',
                        prd.imagepath,
						'count',
						ordpr.itemcount,
						'createdat',
						prd.createdat,
						'createdby',
						prd.createdby,
                        'price',
                        ordpr.price,
                        'attributes',
                        to_json(
                            Array(
                                select
                                    to_json(
                                        json_build_object(
                                            'id',
                                            ordpratt.id,
                                            'orderproductid',
                                            ordpratt.orderproductid,
                                            'attributeid',
                                            ordpratt.attributeid,
                                            'attributename',
                                             prdatt.name,
                                            'pricesubtotal',
                                            ordpratt.pricesubtotal,
                                            'pricetaxvalue',
                                            ordpratt.pricetaxvalue,
                                            'pricetaxpercentage',
                                            ordpratt.pricetaxpercentage,
											'values',(ordpratt.children)::json,
                                            'notes',
                                            ordpratt.notes,
											'createdat',
											ordpratt.createdat,
											'createdby',
											ordpratt.createdby
                                        )
                                    )
                                from
                                    orderproductattribute ordpratt
                                    left join productattribute prdatt on ordpratt.attributeid = prdatt.id
								where ordpratt.orderproductid = ordpr.id
                            )
                        ),
                        'pricesubtotal',
                        ordpr.pricesubtotal,
                        'pricetaxvalue',
                        ordpr.pricetaxvalue,
                        'pricetaxpercentage',
                        ordpr.pricetaxpercentage,
                        'notes',
                        ordpr.notes
                    )
                )
            from
                orderproduct ordpr
                left join product prd on ordpr.productid = prd.id
			where ordpr.orderid = ord.id
        )
    ) products,
    getorderstatus(ord.currentstatus),
    ord.ordersource,
	getlookupname(ord.ordersource),
	case when (ord.deliverytype = 'ebf23c72-7003-4804-b981-727ef616e1d5')
	    then (select getlocaldeliveryname(ord.branchid))
	    else (Select getdeliverycompanyname(ord.deliverytype))
        end,
	ord.scheduled,
    ord.deliverytype,
    ord.customerid,
    ord.branchid,
    ord.notes,
	ord.numberofpeople,
    (ord.price->>'FinalPrice')::numeric,
    ord.deliveryprice,
    ord.deliveryaddress,
    ord.subtotalprice,
    ord.referencenumber,
    ord.totalpreparingtime,
    ord.deliverystatus,
    ord.paymenttype,
    ord.createdat,
    ord.createdby,
	getbranchname(ord.branchid),
    customer.name,
    customer.dateofbirth,
    customer.phoneno,
    customer.phoneno2,
    customer.email,
    customer.image,
    customer.channel,
    customer.loyalitypoints,
    customer.fb,
    customer.twitter,
    customer.instagram,
    customer.lastorderdate,
    customer.isblocked,
    customer.notes,
    customer.createdat,
    customer.createdby,
	json_build_object('en',(select to_json(json_build_object(
	                                                 'id', addr.id ,
	                                                 'name',addr.name ,
                                                     'latitude',addr.lat ,
	                                                 'longtitude', addr.lng ,
	                                                 'buildingno', addr.buildingnumber ,
	                                                 'streetname',addr.street,
	                                                 'details',addr.otherdetails,
	                                                 'addressname',addr.name,
	                                                 'city',ic.name_en,
                                                     'area',ia.name_en,
                                                     'subarea',addr.preferedsubarea
	                                        ))
from public.addresses addr
    join public.ishbekcities ic on addr.ishbekcityid = ic.cityid
    join public.ishbekareas ia on ia.areaid = addr.ishbekareaid and addr.ishbekcityid = ia.cityid
where addr.id = ord.deliveryaddress
                ),'ar', (select to_json(json_build_object(
                                                      'id', addr.id ,
	                                                 'name',addr.name ,
                                                     'latitude',addr.lat ,
	                                                 'longtitude', addr.lng ,
	                                                 'buildingno', addr.buildingnumber ,
	                                                 'streetname',addr.street,
	                                                 'details',addr.otherdetails,
	                                                 'addressname',addr.name,
	                                                 'city',ic.name_ar,
                                                     'area',ia.name_ar,
                                                     'subarea',addr.preferedsubarea
                                                        ))
from public.addresses addr
    join public.ishbekcities ic on addr.ishbekcityid = ic.cityid
    join public.ishbekareas ia on ia.areaid = addr.ishbekareaid and addr.ishbekcityid = ia.cityid
where addr.id = ord.deliveryaddress
))
from
    "order" ord
    left join customer on ord.customerid = customer.id
where
    ord.id = _orderid;
END;
$$;


--
-- Name: getpaymentbyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getpaymentbyid(_id uuid) RETURNS TABLE(value public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select (companyinfo.value)::citext from companyinfo where companyinfo.type = 'CallCenterpayment' and companyid = _id  and isdeleted = false and ispublished = true;
END;
$$;


--
-- Name: getpaymentbyidinterfaceishbek(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getpaymentbyidinterfaceishbek(_id uuid) RETURNS SETOF public.citext
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select companyinfo.value::citext from companyinfo where companyinfo.type = 'CallCenterpayment' and companyid = _id  and isdeleted = false and ispublished = true;
END;
$$;


--
-- Name: getpaymentcredentialsid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getpaymentcredentialsid(_id uuid DEFAULT NULL::uuid) RETURNS TABLE(apipassword public.citext, apiusername public.citext, merchant public.citext, interactionmerchantname public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select password,username,marchent,marchentname from restaurantpaymentcredentials where rid = _id;
END;
$$;


--
-- Name: getpaymentonholdordersid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getpaymentonholdordersid(_id uuid DEFAULT NULL::uuid) RETURNS TABLE(orderdetails jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select paymentonholdorders.orderdetails  from paymentonholdorders where orderpaymentid = _id;
END;
$$;


--
-- Name: payment; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.payment (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    name public.citext NOT NULL,
    isdeleted boolean DEFAULT false NOT NULL,
    arabicname public.citext
);


--
-- Name: getpayments(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getpayments() RETURNS SETOF public.payment
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select * from payment where isdeleted = false ;
END;
$$;


--
-- Name: getpopupcompanyphone(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getpopupcompanyphone(_companyid uuid) RETURNS TABLE(id uuid, companyname public.citext, companyid uuid, companyphone public.citext, createdat timestamp without time zone, createdby public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY

    select vpn.id, vpn.companyname, vpn.companyid, vpn.companyphone, vpn.createdat, vpn.createdby from viciphonenumber vpn where vpn.companyid = _companyid;


END;
$$;


--
-- Name: getposintegratoinid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getposintegratoinid(_companyid uuid) RETURNS TABLE(id uuid, intcompany uuid)
    LANGUAGE plpgsql
    AS $$

BEGIN
RETURN QUERY
    select posi.companyid,posi.integrationcompanyid from posintegration posi where companyid = _companyid;
		END;
$$;


--
-- Name: getposorderdata(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getposorderdata(_orderid uuid) RETURNS TABLE(id uuid, companyid uuid, branchorderid public.citext, price jsonb, products json, currentstatus public.citext, ordersource uuid, ordersourcename public.citext, deliveryname public.citext, deliverycompanyid uuid, orderprice jsonb, customerid uuid, scheduled timestamp without time zone, deliverytype uuid, branchid uuid, notes public.citext, numberofpeople public.citext, totalprice numeric, deliveryprice numeric, deliveryaddress uuid, subtotalprice numeric, referencenumber jsonb, totalpreparingtime public.citext, deliverystatus public.citext, paymenttype public.citext, createdat timestamp without time zone, createdby public.citext, branchname public.citext, customername public.citext, customerphoneno public.citext, customerfullphoneno public.citext, countrycode public.citext, orderrefrence json, address json, intcompany uuid, orderserialid public.citext)
    LANGUAGE plpgsql
    AS $$

BEGIN
    RETURN QUERY
        select ord.id,
               (select b.companyid from branch b where b.id = ord.branchid),
               ord.branchorderid,
               ord.price,
               to_json(Array(select to_json(json_build_object('id', ordpr.id, 'orderid', ordpr.orderid, 'productid',
                                                              ordpr.productid, 'productname', prd.name, 'img',
                                                              prd.imagepath, 'count', ordpr.itemcount, 'createdat',
                                                              prd.createdat, 'createdby', prd.createdby, 'price',
                                                              ordpr.price, 'attributes',
                                                              to_json(Array(select to_json(json_build_object('id',
                                                                                                             ordpratt.id,
                                                                                                             'orderproductid',
                                                                                                             ordpratt.orderproductid,
                                                                                                             'attributeid',
                                                                                                             ordpratt.attributeid,
                                                                                                             'attributename',
                                                                                                             prdatt.name,
                                                                                                             'pricesubtotal',
                                                                                                             ordpratt.pricesubtotal,
                                                                                                             'pricetaxvalue',
                                                                                                             ordpratt.pricetaxvalue,
                                                                                                             'pricetaxpercentage',
                                                                                                             ordpratt.pricetaxpercentage,
                                                                                                             'child',
                                                                                                             (ordpratt.children)::json,
                                                                                                             'notes',
                                                                                                             ordpratt.notes,
                                                                                                             'createdat',
                                                                                                             ordpratt.createdat,
                                                                                                             'createdby',
                                                                                                             ordpratt.createdby))
                                                                            from orderproductattribute ordpratt
                                                                                     left join productattribute prdatt on ordpratt.attributeid = prdatt.id
                                                                            where ordpratt.orderproductid = ordpr.id)),
                                                              'pricesubtotal', ordpr.pricesubtotal, 'pricetaxvalue',
                                                              ordpr.pricetaxvalue, 'pricetaxpercentage',
                                                              ordpr.pricetaxpercentage, 'notes', ordpr.notes))
                             from orderproduct ordpr
                                      inner join product prd on ordpr.productid = prd.id
                             where ordpr.orderid = ord.id)) products
                ,
               getorderstatus(ord.currentstatus),
               ord.ordersource,
               getlookupname(ord.ordersource),
               case
                   when (ord.deliverytype = 'ebf23c72-7003-4804-b981-727ef616e1d5')
                       then (select getlocaldeliveryname(ord.branchid))
                   else (Select getdeliverycompanynameforpos(ord.deliverytype)) end,
               getdeliverycompanyid(ord.deliverytype),
               ord.price,
               ord.customerid,
               ord.scheduled,
               ord.deliverytype,
               ord.branchid,
               ord.notes,
               ord.numberofpeople,
               ord.totalprice,
               ord.deliveryprice,
               ord.deliveryaddress,
               ord.subtotalprice,
               ord.referencenumber,
               ord.totalpreparingtime,
               ord.deliverystatus,
               ord.paymenttype,
               ord.createdat,
               ord.createdby,
               getbranchname(ord.branchid),
               c.name,
               c.phoneno,
               c.fullphonenumber,
               c.countrycode,
               json_build_object('channel', (SELECT nlk.name from namelookup nlk where nlk.id = ord.ordersource),
                                 'number', (CASE
                                                WHEN (ord.createdby = 'Careem' or ord.createdby = 'TALABAT')
                                                    THEN (select (CASE
                                                                      WHEN ord.createdby = 'careem'
                                                                          THEN (select (select trim(both '"' from (resoucevalue.resvalue))
                                                                                        from (SELECT value::citext as resvalue, key::citext as reskey
                                                                                              FROM jsonb_each((select ord1.referencenumber from "order" ord1 where ord1.id = ord.id))
                                                                                              where (value != 'null')
                                                                                              LIMIt 1) as resoucevalue))
                                                                      ELSE (select trim(both '"' from (resoucevalue.resvalue))
                                                                            from (SELECT (value::citext) as resvalue, key::citext as reskey
                                                                                  FROM jsonb_each((select ord1.referencenumber from "order" ord1 where ord1.id = ord.id))
                                                                                  where (value != 'null')) as resoucevalue
                                                                            WHERE (resoucevalue.reskey = 'deliveryPlatformID')) END))
                                                ELSE null END), 'shortcode', (CASE
                                                                                  WHEN ord.createdby = 'TALABAT'
                                                                                      THEN (select trim(both '"' from (resoucevalue.resvalue))
                                                                                            from (SELECT (value::citext) as resvalue, key::citext as reskey
                                                                                                  FROM jsonb_each((select ord1.referencenumber from "order" ord1 where ord1.id = ord.id))
                                                                                                  where (value != 'null')) as resoucevalue
                                                                                            WHERE (resoucevalue.reskey = 'shortCode')) END)),
               json_build_object('en', (select to_json(json_build_object('id', addr.id, 'name', name, 'subareaid',
                                                                         preferedsubarea, 'latitude', lat, 'longtitude',
                                                                         lng, 'buildingno', buildingnumber, 'streetno',
                                                                         street))
                                        from addresses addr
                                        where addr.id = ord.deliveryaddress), 'ar',
                                 (select to_json(json_build_object('id', addr.id, 'name', name, 'subareaid',
                                                                   preferedsubarea, 'latitude', lat, 'longtitude', lng,
                                                                   'buildingno', buildingnumber, 'streetno', street))
                                  from addresses addr
                                  where addr.id = ord.deliveryaddress)),
               (select posint.integrationcompanyid
                from posintegration posint
                where posint.companyid = (select b.companyid from branch b where b.id = ord.branchid)),
               cast(ord.ishbekserial as citext)
        from "order" ord
                 inner join customer c on ord.customerid = c.id
        where ord.id = _orderid;
END;
$$;


--
-- Name: getpriceforproduct(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getpriceforproduct(_id uuid DEFAULT NULL::uuid) RETURNS TABLE(price jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select product.price from product where product.id = _id and isdeleted = false and ispublished = true;
END;
$$;


--
-- Name: getproduct(uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproduct(_id uuid DEFAULT NULL::uuid, _languagecode public.citext DEFAULT 'en'::public.citext) RETURNS TABLE(id uuid, name jsonb, description jsonb, categoryid uuid, price jsonb, imagepath public.citext, sku public.citext, displaynumber integer, producttags jsonb, hour integer, min integer, shortdescription jsonb, fulldescription jsonb, isavailable boolean, isoffer boolean, ispublished boolean, createdat timestamp without time zone, createdby public.citext, aliasname jsonb, aliasdescription jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
        select product.id,
               product.name,
               product.description,
               product.categoryid,
               product.price,
               product.imagepath,
               product.sku,
               product.displaynumber,
               product.producttags,
               product.hour,
               product.min,
               product.shortdescription,
               product.fulldescription,
               product.isavailable,
               product.isoffer,
               product.ispublished,
               product.createdat,
               product.createdby,
               product.aliasname,
               product.aliasdescription
        from product
        where product.id = _id
          and product.isdeleted = false
          and product.ispublished = true
          and product.isavailable = true;

END;
$$;


--
-- Name: getproductattribute(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductattribute(_productid uuid) RETURNS SETOF public.productattribute
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select * from productattribute where productid = _productid and isdeleted = false and ispublished = true order by priority desc;
END;
$$;


--
-- Name: getproductattributeanswer(uuid[], uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductattributeanswer(_id uuid[], _menuid uuid, _channel public.citext) RETURNS TABLE(options json)
    LANGUAGE plpgsql
    AS $$
                  BEGIN
                  RETURN QUERY
                  
                  
    select
    to_json(array(select to_json(unnest(
            case
                when ((select doeshavechildren(lv2.id)))
                    then (select getoptionchildrenAnswer(_menuid,_channel,lv2.id))--create function to get 3lvls
                else
                    array(select to_json(json_build_object(
                            'questionid', lv2.attributeid,
                            'id', lv2.id,
                            'name', lv2.name,
                            'active', lv2.isavailable,
                            'minimumcount',lv2.minimumcount,
                            'maximumcount',lv2.maximumcount,
                            'isalergy',lv2.isalergy,
                            'controltype',lv2.controltype,
                            'description',lv2.description,
                            'discount',(select getattrbiuteiscountishbekinterface(_id := lv2.id,_channel := _channel)),
                            'branches',ARRAY(select getbranchforcategorybymenuidandchannel(_id := _menuid,_callid := lv2.id,_channel :=_channel)),
                             'price', case
                                         when ((lv1.price-> _channel is not null) and (lv2.price-> _channel is not null))
                                             then (
                                             (((lv1.price)-> _channel)::decimal) + (((lv2.price)-> _channel)::decimal)
                                             )
                                         else (  (((lv1.price::jsonb) ->>'default')::decimal) + (((lv2.price::jsonb) ->> 'default')::decimal)) end,
                            'priority', lv2.priority
                        )))::json[]
                end))
            from productattribute lv1
            inner join productattribute lv2 on lv1.id = lv2.attributeid
            where lv1.productid = any (_id)
                and lv1.attributeid is null and lv1.isdeleted = false and lv2.isdeleted = false ));
                  END;

$$;


--
-- Name: getproductattributeidanswer(uuid, uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductattributeidanswer(_id uuid, _menuid uuid, _channel public.citext) RETURNS TABLE(id uuid[])
    LANGUAGE plpgsql
    AS $$
                  BEGIN
                  RETURN QUERY
                  
                  
                  
                  
                  
                  
                  select (case when ((select doeshavechildren(lv2.id))) THEN (select  array(select getoptionchildrenidanswer(_menuid,_channel,lv2.id)))  else
                  
                  Array(select lv2.id ) 
                  end) 
             from productattribute lv1
            inner join productattribute lv2 on lv1.id = lv2.attributeid
            where lv1.id = _id
                  and lv1.attributeid is null and lv1.isdeleted = false and lv2.isdeleted = false ; 
                  
  
END;

$$;


--
-- Name: getproductattributeishbekinterface(uuid[], uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductattributeishbekinterface(_productid uuid[], _menuid uuid, _channel public.citext) RETURNS TABLE(productid uuid, id uuid, name jsonb, price numeric, isalergy boolean, isavailable boolean, ischatbotquestion boolean, minimumcount integer, maximumcount integer, controltype public.citext, description jsonb, priority integer, branches uuid[], options uuid[])
    LANGUAGE plpgsql
    AS $$
                  BEGIN
                  RETURN QUERY
                   select
                       pa.productid,
                       pa.id,
                       pa.name,
                       case
                                         when ((pa.price)-> _channel is not null)
                                             then (
                                             ((pa.price)-> _channel)::decimal
                                             )
                                         else (  (((pa.price::jsonb) ->>'default')::decimal)) end,
                       pa.isalergy,
                       pa.isavailable,
                       pa.ischatbotquestion,
                       pa.minimumcount,
                       pa.maximumcount,
                       pa.controltype,
                       pa.description,
                       pa.priority,
                       Array(select getbranchforcategorybymenuidandchannel(_id := _menuid,_callid := pa.id,_channel :=_channel)),
                       Array(select getproductunnestattributeidanswer(_id := pa.id,_menuid := _menuid,_channel :=_channel))
                       from productattribute pa
                        where pa.productid= any(_productid)
                        and isglobal !=true
                        and isdeleted = false
                        and ispublished = true
                        and attributeid is null
                        and isdeleted = false
                        order by pa.priority asc ;
                  END;

$$;


--
-- Name: getproductattributelevel(uuid[], uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductattributelevel(_id uuid[], _menuid uuid, _channel public.citext) RETURNS TABLE(questionid uuid, id uuid, name jsonb, price jsonb, isalergy boolean, isavailable boolean, minimumcount integer, maximumcount integer, controltype public.citext, description jsonb, priority integer, branches jsonb, children jsonb)
    LANGUAGE plpgsql
    AS $$
                  BEGIN
                  RETURN QUERY
                   select
                       ch.attributeid,
                       ch.id,
                       ch.name,
                       ch.price,
                       ch.isalergy,
                       ch.isavailable,
                       ch.minimumcount,
                       ch.maximumcount,
                       ch.controltype,
                       ch.description,
                       ch.priority,
                       (select to_json( array(select row_to_json(getbranchforcategorybymenuidandchannel(_id := _menuid,_callid := ch.id,_channel :=_channel)))))::jsonb,
                       (select to_json( array(select row_to_json(getproductattributelevelx(_id := ch.id,_menuid := _menuid,_channel :=_channel)))))::jsonb

                       from productattribute ch where ch.attributeid = any(_id) and ch.isdeleted = false
                           order by ch.priority,ch.createdat ASC;
                  END;

$$;


--
-- Name: getproductattributelevelx(uuid, uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductattributelevelx(_id uuid, _menuid uuid, _channel public.citext) RETURNS TABLE(questionid uuid, id uuid, name jsonb, price jsonb, isalergy boolean, isavailable boolean, minimumcount integer, maximumcount integer, controltype public.citext, description jsonb, priority integer, branches jsonb)
    LANGUAGE plpgsql
    AS $$
                  BEGIN
                  RETURN QUERY
                   select
                       ch.attributeid,
                       ch.id,
                       ch.name,
                       ch.price,
                       ch.isalergy,
                       ch.isavailable,
                       ch.minimumcount,
                       ch.maximumcount,
                       ch.controltype,
                       ch.description,
                       ch.priority,
                       (select to_json( array(select row_to_json(getbranchforcategorybymenuidandchannel(_id := _menuid,_callid := ch.id,_channel :=_channel)))))::jsonb

                       
                       from productattribute ch where ch.attributeid = _id and ch.isdeleted = false
                           order by ch.priority,ch.createdat ASC;
                  END;

$$;


--
-- Name: getproductattributelv(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductattributelv(_id uuid, _branchid uuid) RETURNS TABLE(id uuid, name jsonb, price jsonb, discountinfo jsonb, isalergy boolean, isavailable boolean, minimumcount integer, maximumcount integer, controltype public.citext, description jsonb, priority integer)
    LANGUAGE plpgsql
    AS $$
                  BEGIN
                  RETURN QUERY
                   select
                       ch.id,
                       ch.name,
                       ch.price,
                       (select to_json(jsonb_build_object( 
                                          'id',dinfo.id,
                                          'value',dinfo.value,
                                          'priority',dinfo.priority,
                                          'ispercentage',dinfo.ispercentage,
                                          'type',dinfo.type))
                                          from discountinfo dinfo
                                          left join discountattribute disprattr on disprattr.discountid = dinfo.id
                                          left join discountchannel disch on disch.discountid = dinfo.id
                                          left join discountbranch disbr on disbr.discountid = dinfo.id
                                          where
                                          ((case when (dinfo.availablefrom::time < dinfo.availableto::time) then
                                            case when ((dinfo.availablefrom::time <= ((now())::time + interval '3 hour')) and (dinfo.availableto::time >= (now())::time))  then 1 else 0 end
                                            else
                                            case when ((dinfo.availableto::time <= (now())::time + interval '3 hour') and (dinfo.availablefrom::time >= (now())::time))  then 0 else 1 end
                                            end) =1)
                                          and
                                          ((dinfo.availablefrom)::date) <= ((now())::date)  and ((dinfo.availableto)::date) >= ((now())::date)
                                          and
                                          (select to_char ( (now()), 'D'  )::integer) = any (dinfo.daysofweek)
                                          and disprattr.attributeid = ch.id
                                          and disch.channelid = (select nlk.id from namelookup nlk where nlk.name ='MobileApp')
                                          and disbr.branchid = _branchid
                                          and dinfo.ispublished is true
                                          and dinfo.isdeleted is not true
                                          and dinfo.type = 'Order' order by dinfo.priority desc,dinfo.createdat desc LIMIT 1)::jsonb,
                                          
                                          
                       
                       ch.isalergy,
                       ch.isavailable,
                       ch.minimumcount,
                       ch.maximumcount,
                       ch.controltype,
                       ch.description,
                       ch.priority
                       
                       from productattribute ch where ch.attributeid = _id and ch.isdeleted = false
                           and ch.id not in (select objectid from branchavailability where branchid =_branchid)
                           order by ch.priority,ch.createdat ASC;
                  END;

$$;


--
-- Name: getproductattributename(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductattributename(_childid uuid) RETURNS TABLE(children jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select name from productattribute where id = _childid;
END;
$$;


--
-- Name: getproductattributenotavailablebyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductattributenotavailablebyid(_id uuid) RETURNS TABLE(id uuid, name jsonb, isavailable boolean, isdeleted boolean, ispublished boolean)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select productattribute.id,productattribute.name,productattribute.isavailable,productattribute.isdeleted,productattribute.ispublished from productattribute where productattribute.id = _id ;
END;
$$;


--
-- Name: getproductattributes(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductattributes(_productid uuid, _companyid uuid) RETURNS SETOF public.productattribute
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select * from getproductattribute(_productid) 
union
select * from getglobalattributes(_companyid) order by priority;

END;
$$;


--
-- Name: getproductattributesastree(uuid, uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductattributesastree(_productid uuid, _branchid uuid, _channelname public.citext) RETURNS TABLE(id uuid, name jsonb, price jsonb, isrequired boolean, isalergy boolean, isavailable boolean, ischatbotquestion boolean, noofselection integer, minimumcount integer, maximumcount integer, controltype public.citext, description jsonb, priority integer, children jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select * from getproductattributestree(_productid,_branchid, _channelname);
--   SELECT (psa.attribute->>'attribute')::uuid,pa.name,(psa.attribute->>'isrequired')::boolean,(psa.attribute->>'isallergy')::boolean,(psa.attribute->>'isavailable')::boolean,pa.description,pa.noofselection,(psa.attribute->>'controltype')::citext,pa.price,
--  to_json( Array( select to_json(json_build_object(
--  'id',attributevalue.id,
--  'name',attributevalue.name,
--  'description',attributevalue.description,
--  'isrequired',attributevalue.isrequired,
--  'isalergy',attributevalue.description,
--  'noofselection',attributevalue.noofselection,
--  'price',attributevalue.price,
--  'controltype',attributevalue.controltype,
--  'children',  to_json( Array( select to_json(json_build_object(
-- 	 'id',subattributevalue.id,
--    	 'name',subattributevalue.name,
-- 	 'description',subattributevalue.description,
-- 	 'isrequired',subattributevalue.isrequired,
-- 	 'isalergy',subattributevalue.description,
-- 	 'noofselection',subattributevalue.noofselection,
-- 	 'price',subattributevalue.price,
-- 	 'controltype',subattributevalue.controltype
--
--  )) from productattribute subattributevalue where subattributevalue.attributeid =  attributevalue.id and (subattributevalue.id  not in (select objectid from branchavailability where objectid = subattributevalue.id and branchid = _branchid))and subattributevalue.isdeleted = false and subattributevalue.isavailable = true order by subattributevalue.priority ASC)),
-- 	 'discountinfo',(select to_json(array(select to_json(json_build_object('name' , discount.name,
-- 												 'ispercentage', discount.ispercentage,
-- 												 'discountpercent' , discount.discountpercent,
-- 												 'discountvalue' , discount.discountvalue,
-- 												 'maxdiscountprice' , discount.maxdiscountprice,
-- 												 'mindiscountquantity' , discount.mindiscountquantity,
-- 											     'mindiscountprice',discount.mindiscountprice))	from discount where
-- --time is available by now
-- ((fromtime is null ) or (fromtime::time <= (now() AT TIME ZONE 'Asia/Amman'::text)::time)) and
-- ((totime is null ) or (totime::time >= (now() AT TIME ZONE 'Asia/Amman'::text)::time)) and
-- --date is available by now
-- ((fromdate is null ) or (fromdate::date <= (now() AT TIME ZONE 'Asia/Amman'::text)::date)) and
-- ((todate is null ) or (todate::date >= (now() AT TIME ZONE 'Asia/Amman'::text)::date)) and
-- --today is actually on this offer
-- ((daysofweek is null ) or (select to_char((now() AT TIME ZONE 'Asia/Amman'::text)::timestamp,'D')::integer = any(daysofweek)))
-- and isdeleted = false
-- --without promocodes
-- and promocode is null
-- --attribute limitation
-- and attributevalue.id =any(attributeids)
-- --branch limitation
-- and _branchid =any(branchids))))::jsonb
--  )) from productattribute attributevalue where attributevalue.isdeleted = false and (attributevalue.id  not in (select objectid from branchavailability where objectid = attributevalue.id and branchid = _branchid)) and  attributevalue.isavailable = true and TO_JSON(attributevalue.attributeid)::jsonb =  psa.attribute->'attribute' order by attributevalue.priority ASC)) children
--
-- FROM productselectedattribute psa INNER JOIN productattribute pa on (TO_JSON(pa.id)::jsonb = psa.attribute->'attribute')
-- where psa.product =_productid
-- and psa.isdeleted = false
-- and psa.ispublished = true
-- and (select count (pv.id) from productattribute pv where pv.attributeid = (psa.attribute->>'attribute')::uuid and psa.isdeleted = false and psa.ispublished = true and pv.isavailable = true) > 0
-- order by psa.createdat ASC;
END;
$$;


--
-- Name: getproductattributesastree1(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductattributesastree1(_productid uuid) RETURNS TABLE(id uuid, name jsonb, description jsonb, isrequired boolean, isalergy boolean, noofselection integer, price public.citext, children jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
  select prodattribute.id,prodattribute.name,prodattribute.description,prodattribute.isrequired, prodattribute.isalergy , prodattribute.noofselection , prodattribute.price ,
  to_json( Array( select attribute,
 'children',  to_json( Array( select to_json(json_build_object(
	 'id',subattributevalue.id,
   	 'name',subattributevalue.name, 
	 'description',subattributevalue.description,
	 'isrequired',subattributevalue.isrequired,
	 'isalergy',subattributevalue.description,
	 'noofselection',subattributevalue.noofselection,
	 'price',subattributevalue.price
	 )) from productattribute subattributevalue where subattributevalue.attributeid =  attributevalue.id))))
		
 from productselectedattribute pratt
 inner join productattribute prodattribute on (pratt.product = prodattribute.productid and pratt.attribute->'attribute' = TO_JSON(prodattribute.id)::jsonb)
 where pratt.product = '64e7c80f-12ba-4741-bb74-86017c178b4b'
 and pratt.product = prodattribute.productid
 and prodattribute.isdeleted = false
 and pratt.isdeleted = false
 and pratt.ispublished = true
 and prodattribute.ispublished = true 
 and prodattribute.isavailable = true
 order by priority desc;
 END;
$$;


--
-- Name: getproductattributesastree2(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductattributesastree2(_productid uuid) RETURNS TABLE(id text, name text, isrequired text, isalergy text, isavailable text, description jsonb, noofselection integer, price public.citext, children json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
  SELECT psa.attribute->>'attribute'::citext,psa.attribute->>'name'::citext,psa.attribute->>'isallergy'::citext,psa.attribute->>'isrequired'::citext,psa.attribute->>'isavailable'::citext,pa.description,pa.noofselection,pa.price,
 to_json( Array( select to_json(json_build_object(
 'id',pa.id,
 'name',pa.name, 
 'description',pa.description,
 'isrequired',pa.isrequired,
 'isalergy',pa.description,
 'noofselection',pa.noofselection,
 'price',pa.price,
 'children',  to_json( Array( select to_json(json_build_object(
	 'id',subattributevalue.id,
   	 'name',subattributevalue.name, 
	 'description',subattributevalue.description,
	 'isrequired',subattributevalue.isrequired,
	 'isalergy',subattributevalue.description,
	 'noofselection',subattributevalue.noofselection,
	 'price',subattributevalue.price
	 )) from productattribute subattributevalue where subattributevalue.attributeid =  pa.id and subattributevalue.isdeleted = false and subattributevalue.isavailable = true))))
 ))
FROM productselectedattribute psa INNER JOIN productattribute pa on (TO_JSON(pa.id)::jsonb = psa.attribute->'attribute')
where psa.product =_productid
and psa.isdeleted = false
and psa.ispublished = true
 order by priority desc;
 END;
$$;


--
-- Name: getproductattributesastreeforonline(uuid, uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductattributesastreeforonline(_productid uuid, _branchid uuid, _channelname public.citext) RETURNS TABLE(id uuid, name jsonb, min integer, max integer, price jsonb, isrequired boolean, isalergy boolean, isavailable boolean, noofselection integer, controltype public.citext, description jsonb, priority integer, children jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select * from getproductattributestreeforonline(_productid,_branchid,_channelname);

END;
$$;


--
-- Name: getproductattributesastreesave(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductattributesastreesave(_productid uuid) RETURNS TABLE(id uuid, name jsonb, description jsonb, isrequired boolean, isalergy boolean, noofselection integer, price public.citext, children jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
  select  pratt.id,pratt.name,pratt.description,pratt.isrequired, pratt.isalergy , pratt.noofselection , pratt.price ,
 to_json( Array( select to_json(json_build_object(
 'id',attributevalue.id,
 'name',attributevalue.name, 
 'description',attributevalue.description,
 'isrequired',attributevalue.isrequired,
 'isalergy',attributevalue.description,
 'noofselection',attributevalue.noofselection,
 'price',attributevalue.price,
 'children',  to_json( Array( select to_json(json_build_object(
	 'id',subattributevalue.id,
   	 'name',subattributevalue.name, 
	 'description',subattributevalue.description,
	 'isrequired',subattributevalue.isrequired,
	 'isalergy',subattributevalue.description,
	 'noofselection',subattributevalue.noofselection,
	 'price',subattributevalue.price
	 
 )) from productattribute subattributevalue where subattributevalue.attributeid =  attributevalue.id))
 )) from productattribute attributevalue where attributevalue.attributeid =  pratt.id))::jsonb
 
 from productattribute pratt where pratt.productid = _productid and pratt.isdeleted = false and pratt.ispublished = true and pratt.isavailable = true order by priority desc;END;
$$;


--
-- Name: getproductattributesastreetest(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductattributesastreetest(_productid uuid, _branchid uuid) RETURNS TABLE(id uuid, name jsonb, price jsonb, isalergy boolean, isavailable boolean, ischatbotquestion boolean, minimumcount integer, maximumcount integer, controltype public.citext, description jsonb, priority integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select * from getproductattributestreetest(_productid,_branchid);
--   SELECT (psa.attribute->>'attribute')::uuid,pa.name,(psa.attribute->>'isrequired')::boolean,(psa.attribute->>'isallergy')::boolean,(psa.attribute->>'isavailable')::boolean,pa.description,pa.noofselection,(psa.attribute->>'controltype')::citext,pa.price,
--  to_json( Array( select to_json(json_build_object(
--  'id',attributevalue.id,
--  'name',attributevalue.name,
--  'description',attributevalue.description,
--  'isrequired',attributevalue.isrequired,
--  'isalergy',attributevalue.description,
--  'noofselection',attributevalue.noofselection,
--  'price',attributevalue.price,
--  'controltype',attributevalue.controltype,
--  'children',  to_json( Array( select to_json(json_build_object(
-- 	 'id',subattributevalue.id,
--    	 'name',subattributevalue.name,
-- 	 'description',subattributevalue.description,
-- 	 'isrequired',subattributevalue.isrequired,
-- 	 'isalergy',subattributevalue.description,
-- 	 'noofselection',subattributevalue.noofselection,
-- 	 'price',subattributevalue.price,
-- 	 'controltype',subattributevalue.controltype
--
--  )) from productattribute subattributevalue where subattributevalue.attributeid =  attributevalue.id and (subattributevalue.id  not in (select objectid from branchavailability where objectid = subattributevalue.id and branchid = _branchid))and subattributevalue.isdeleted = false and subattributevalue.isavailable = true order by subattributevalue.priority ASC)),
-- 	 'discountinfo',(select to_json(array(select to_json(json_build_object('name' , discount.name,
-- 												 'ispercentage', discount.ispercentage,
-- 												 'discountpercent' , discount.discountpercent,
-- 												 'discountvalue' , discount.discountvalue,
-- 												 'maxdiscountprice' , discount.maxdiscountprice,
-- 												 'mindiscountquantity' , discount.mindiscountquantity,
-- 											     'mindiscountprice',discount.mindiscountprice))	from discount where
-- --time is available by now
-- ((fromtime is null ) or (fromtime::time <= (now() AT TIME ZONE 'Asia/Amman'::text)::time)) and
-- ((totime is null ) or (totime::time >= (now() AT TIME ZONE 'Asia/Amman'::text)::time)) and
-- --date is available by now
-- ((fromdate is null ) or (fromdate::date <= (now() AT TIME ZONE 'Asia/Amman'::text)::date)) and
-- ((todate is null ) or (todate::date >= (now() AT TIME ZONE 'Asia/Amman'::text)::date)) and
-- --today is actually on this offer
-- ((daysofweek is null ) or (select to_char((now() AT TIME ZONE 'Asia/Amman'::text)::timestamp,'D')::integer = any(daysofweek)))
-- and isdeleted = false
-- --without promocodes
-- and promocode is null
-- --attribute limitation
-- and attributevalue.id =any(attributeids)
-- --branch limitation
-- and _branchid =any(branchids))))::jsonb
--  )) from productattribute attributevalue where attributevalue.isdeleted = false and (attributevalue.id  not in (select objectid from branchavailability where objectid = attributevalue.id and branchid = _branchid)) and  attributevalue.isavailable = true and TO_JSON(attributevalue.attributeid)::jsonb =  psa.attribute->'attribute' order by attributevalue.priority ASC)) children
--
-- FROM productselectedattribute psa INNER JOIN productattribute pa on (TO_JSON(pa.id)::jsonb = psa.attribute->'attribute')
-- where psa.product =_productid
-- and psa.isdeleted = false
-- and psa.ispublished = true
-- and (select count (pv.id) from productattribute pv where pv.attributeid = (psa.attribute->>'attribute')::uuid and psa.isdeleted = false and psa.ispublished = true and pv.isavailable = true) > 0
-- order by psa.createdat ASC;
END;
$$;


--
-- Name: getproductattributestree(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductattributestree(_productid uuid) RETURNS TABLE(id uuid, name jsonb, price jsonb, isrequired boolean, isalergy boolean, isavailable boolean, ischatbotquestion boolean, noofselection integer, minimumcount integer, maximumcount integer, controltype public.citext, description jsonb, priority integer, children jsonb)
    LANGUAGE plpgsql
    AS $$
                  BEGIN
                  RETURN QUERY
                   select
                       pa.id,
                       pa.name,
                       pa.price,
                       pa.isrequired,
                       pa.isalergy,
                       pa.isavailable,
                       pa.ischatbotquestion,
                       pa.noofselection,
                       pa.minimumcount,
                       pa.maximumcount,
                       pa.controltype,
                       pa.description,
                       pa.priority,
                       (select to_json(array (
                           select to_json(
                               jsonb_build_object(
                                      'id',ch.id,
                                      'name',ch.name,
                                      'price',ch.price,
                                      'isrequired',ch.isrequired,
                                      'isalergy',ch.isalergy,
                                      'isavailable',ch.isavailable,
                                      'noofselection',ch.noofselection,
                                      'minimumcount',ch.minimumcount,
                                      'maximumcount',ch.maximumcount,
                                      'priority',ch.priority,
                                      'description',ch.description,
                                      'controltype',ch.controltype,
                                      'children',(
                                          select to_json(array (
                                            select to_json(
                                              jsonb_build_object(
                                              'id',sub.id,
                                              'name',sub.name,
                                              'price',sub.price,
                                              'isrequired',sub.isrequired,
                                              'isalergy',sub.isalergy,
                                              'isavailable',sub.isavailable,
                                              'noofselection',sub.noofselection,
                                              'minimumcount',sub.minimumcount,
                                              'maximumcount',sub.maximumcount,
                                              'priority',sub.priority,
                                              'description',sub.description,
                                              'controltype',sub.controltype))
                           from productattribute sub where sub.attributeid =ch.id and sub.isdeleted = false order by sub.priority ASC)))))
                           from productattribute ch where ch.attributeid =pa.id and ch.isdeleted = false order by ch.priority ASC
                           ))::jsonb
                           as children)
                       from productattribute pa
                        where productid=_productid
                        and isglobal!=true
                        and isdeleted = false
                        and ispublished = true
                        and attributeid is null
                        and isdeleted = false
                        order by pa.priority ASC;
                  END;

$$;


--
-- Name: getproductattributestree(uuid, uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductattributestree(_productid uuid, _branchid uuid, _channelname public.citext) RETURNS TABLE(id uuid, name jsonb, price jsonb, isrequired boolean, isalergy boolean, isavailable boolean, ischatbotquestion boolean, noofselection integer, minimumcount integer, maximumcount integer, controltype public.citext, description jsonb, priority integer, children jsonb)
    LANGUAGE plpgsql
    AS $$
                  BEGIN
                  RETURN QUERY
                   select
                       pa.id,
                       pa.name,
                       pa.price,
                       pa.isrequired,
                       pa.isalergy,
                       pa.isavailable,
                       pa.ischatbotquestion,
                       pa.noofselection,
                       pa.minimumcount,
                       pa.maximumcount,
                       pa.controltype,
                       pa.description,
                       pa.priority,
                       (select to_json(array (
                           select to_json(
                               jsonb_build_object(
                                      'id',ch.id,
                                      'name',ch.name,
                                      'price',ch.price,
                                       'discountinfo',(select to_json( array(select row_to_json(getnowdiscountsforattribute(_attributeid := ch.id, _branchid := _branchid, _channelid := (select nlk.id from namelookup nlk where nlk.name ='callcenter'))))))::jsonb,
                                      'isrequired',ch.isrequired,
                                      'isalergy',ch.isalergy,
                                      'isavailable',ch.isavailable,
                                      'noofselection',ch.noofselection,
                                      'minimumcount',ch.minimumcount,
                                      'maximumcount',ch.maximumcount,
                                      'priority',ch.priority,
                                      'description',ch.description,
                                      'controltype',ch.controltype,
                                      'children',(
                                          select to_json(array (
                                            select to_json(
                                              jsonb_build_object(
                                              'id',sub.id,
                                              'name',sub.name,
                                              'price',sub.price,
                                              'discountinfo',(select to_json( array(select row_to_json(getnowdiscountsforattribute(_attributeid := sub.id, _branchid := _branchid, _channelid := (select nlk.id from namelookup nlk where nlk.name ='callcenter'))))))::jsonb,
                                              'isrequired',sub.isrequired,
                                              'isalergy',sub.isalergy,
                                              'isavailable',sub.isavailable,
                                              'noofselection',sub.noofselection,
                                              'minimumcount',sub.minimumcount,
                                              'maximumcount',sub.maximumcount,
                                              'priority',sub.priority,
                                              'description',sub.description,
                                              'controltype',sub.controltype))
                              from productattribute sub where sub.attributeid =ch.id and sub.isdeleted = false
                              and sub.id not in (select bav.objectid from branchavailability bav where bav.branchid =_branchid and bav.channelid = (select clk.id from channellookup clk where clk.name = _channelname))
                                order by sub.priority,sub.createdat ASC)))))
                           from productattribute ch where ch.attributeid =pa.id and ch.isdeleted = false
                           and ch.id not in (select bav.objectid from branchavailability bav where bav.branchid =_branchid and bav.channelid = (select clk.id from channellookup clk where clk.name = _channelname))
                           order by ch.priority,ch.createdat ASC
                           ))::jsonb
                           as children)
                        from productattribute pa
                        where productid=_productid
                        and isglobal!=true
                        and isdeleted = false
                        and ispublished = true
                        and attributeid is null
                        and isdeleted = false
                        and pa.id not in (select bav.objectid from branchavailability bav where bav.branchid =_branchid and bav.channelid = (select clk.id from channellookup clk where clk.name = _channelname))
                        order by pa.priority asc ;
                  END;

$$;


--
-- Name: getproductattributestreeforonline(uuid, uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductattributestreeforonline(_productid uuid, _branchid uuid, _channelname public.citext) RETURNS TABLE(id uuid, name jsonb, min integer, max integer, price jsonb, isrequired boolean, isalergy boolean, isavailable boolean, noofselection integer, controltype public.citext, description jsonb, priority integer, children jsonb)
    LANGUAGE plpgsql
    AS $$
                  BEGIN
                  RETURN QUERY
                   select
                       pa.id,
                       pa.name,
                       pa.minimumcount,
                       pa.maximumcount,
                       pa.price,
                       pa.isrequired,
                       pa.isalergy,
                       pa.isavailable,
                       pa.noofselection,
                       pa.controltype,
                       pa.description,
                       pa.priority,
                       (select to_json(array (
                           select to_json(
                               jsonb_build_object(
                                      'id',ch.id,
                                      'name',ch.name,
                                      'price',ch.price,
                                      'min', ch.minimumcount,
                                      'max', ch.maximumcount,
                                      'discountinfo',(select to_json( array(select row_to_json(getnowdiscountsforattribute(_attributeid := ch.id, _branchid := _branchid, _channelid := (select nlk.id from namelookup nlk where nlk.name ='OnlineOrdering'))))))::jsonb,
                                      'isrequired',ch.isrequired,
                                      'isalergy',ch.isalergy,
                                      'isavailable',ch.isavailable,
                                      'noofselection',ch.noofselection,
                                      'priority',ch.priority,
                                      'description',ch.description,
                                      'controltype',ch.controltype,
                                      'children',(
                                          select to_json(array (
                                            select to_json(
                                              jsonb_build_object(
                                              'id',sub.id,
                                              'name',sub.name,
                                              'price',sub.price,
                                              'min', sub.minimumcount,
                                              'max', sub.maximumcount,
                                              'discountinfo',(select to_json( array(select row_to_json(getnowdiscountsforattribute(_attributeid := sub.id, _branchid := _branchid, _channelid := (select nlk.id from namelookup nlk where nlk.name ='OnlineOrdering'))))))::jsonb,
                                              'isrequired',sub.isrequired,
                                              'isalergy',sub.isalergy,
                                              'isavailable',sub.isavailable,
                                              'noofselection',sub.noofselection,
                                              'priority',sub.priority,
                                              'description',sub.description,
                                              'controltype',sub.controltype))
                             from productattribute sub where sub.attributeid =ch.id and sub.isdeleted = false 
                             and sub.id not in (select bav.objectid from branchavailability bav where bav.branchid =_branchid and bav.channelid = (select clk.id from channellookup clk where clk.name = _channelname))
                             order by sub.priority ASC)))))
                           from productattribute ch where ch.attributeid =pa.id and ch.isdeleted = false 
                           and ch.id not in (select bav.objectid from branchavailability bav where bav.branchid =_branchid and bav.channelid = (select clk.id from channellookup clk where clk.name = _channelname))
                           order by ch.priority ASC
                           ))::jsonb
                           as children)
                       from productattribute pa
                        where productid=_productid
                        and isglobal!=true
                        and isdeleted = false
                        and ispublished = true
                        and attributeid is null
                        and isdeleted = false
                        and pa.id not in (select bav.objectid from branchavailability bav where bav.branchid =_branchid and bav.channelid = (select clk.id from channellookup clk where clk.name = _channelname))
                        order by pa.priority ASC;
                  END;

$$;


--
-- Name: getproductattributestreetest(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductattributestreetest(_productid uuid, _branchid uuid) RETURNS TABLE(id uuid, name jsonb, price jsonb, isalergy boolean, isavailable boolean, ischatbotquestion boolean, minimumcount integer, maximumcount integer, controltype public.citext, description jsonb, priority integer)
    LANGUAGE plpgsql
    AS $$
                  BEGIN
                  RETURN QUERY
                   select
                       pa.id,
                       pa.name,
                       pa.price,
                       pa.isalergy,
                       pa.isavailable,
                       pa.ischatbotquestion,
                       pa.minimumcount,
                       pa.maximumcount,
                       pa.controltype,
                       pa.description,
                       pa.priority
                        from productattribute pa
                        where productid=_productid
                        and isglobal!=true
                        and isdeleted = false
                        and ispublished = true
                        and attributeid is null
                        and isdeleted = false
                        and pa.id not in (select objectid from branchavailability where branchid =_branchid)
                        order by pa.priority asc ;
                  END;

$$;


--
-- Name: productavailability; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.productavailability (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    fromtime timestamp without time zone,
    totime timestamp without time zone,
    fromdate timestamp without time zone,
    todate timestamp without time zone,
    daysofweek integer[],
    productids uuid[],
    categoryids uuid[],
    channelids uuid[],
    isavailable boolean DEFAULT true NOT NULL,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext,
    attributeids uuid[],
    companyid uuid NOT NULL,
    beneficiary jsonb,
    name public.citext,
    branchids uuid[]
);


--
-- Name: getproductavailabilities(uuid, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductavailabilities(_companyid uuid, _pagenumber integer DEFAULT NULL::integer, _pagesize integer DEFAULT NULL::integer) RETURNS SETOF public.productavailability
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select * from productavailability where isdeleted = false and ispublished=true and companyid = _companyid
LIMIT _pagesize
OFFSET ((_pagenumber-1) * _pagesize);
END;
$$;


--
-- Name: getproductavailabilitybyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductavailabilitybyid(_id uuid) RETURNS TABLE(id uuid, daysofweek integer[], name public.citext, fromtime timestamp without time zone, totime timestamp without time zone, fromdate timestamp without time zone, todate timestamp without time zone, isavailable boolean, categories json, products json, branch json, productattribute json, channels json, beneficiary jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select pr.id,pr.daysofweek,pr.name,pr.fromtime, pr.totime,pr.fromdate,pr.todate,pr.isavailable,
to_json( Array ( select to_json(json_build_object('id' , category.id,'name',category.name, 'image', category.image)) from category where category.id = any(pr.categoryids))),
to_json( Array ( select to_json(json_build_object('id' , product.id,'name',product.name, 'image', product.imagepath)) from product where product.id = any(pr.productids))),
to_json( Array ( select to_json(json_build_object('id' , branch.id,'name',branch.name)) from branch where branch.id = any(pr.branchids))),
to_json( Array ( select to_json(json_build_object('id' , productattribute.id,'name',productattribute.name)) from productattribute where productattribute.id = any(pr.attributeids))),
to_json( Array ( select to_json(json_build_object('id' , benefeciary.id,'name',benefeciary.name,'image', benefeciary.imagepath)) from benefeciary where benefeciary.id = any(pr.channelids))),
pr.beneficiary
from productavailability pr where pr.id=_id and pr.isdeleted= false and pr.ispublished = true;
END;
$$;


--
-- Name: getproductavailabilitybyproductid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductavailabilitybyproductid(_id uuid) RETURNS SETOF public.productavailability
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select * from productavailability where isdeleted = false and ispublished=true and _id = any(productids);
END;
$$;


--
-- Name: getproductbranchavailability(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductbranchavailability(_productid uuid, _companyid uuid) RETURNS TABLE(branchesavailability json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select to_json(Array(select to_json(json_build_object(
		 'branchid' , branch.id,
		 'branchname' , branch.name ,
		 'status' , true,
		 'price' ,((product.price->'default'::text)::decimal)*(CASE when (((product.price->'priceTaxPercentage'::text)::decimal) is not null) then ((( product.price->'priceTaxPercentage'::text)::decimal)+1) else 1 end ) )) 
											from branch
											inner join menu on branch.menuid = menu.id 
											inner join menuproduct on (menu.id = menuproduct.menuid and menuproduct.productid = _productid)
											inner join product on product.id = _productid
											where branch.companyid = _companyid
										   ));
										   END
$$;


--
-- Name: getproductbranchavailable(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductbranchavailable(_id uuid, _branchid uuid) RETURNS TABLE(status boolean)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select (CASE WHEN COUNT(objectid) > 0 THEN true else false end)::boolean from branchavailability where objectid = _id
 and branchid = _branchid;
END;
$$;


--
-- Name: getproductbranchesreports(uuid, timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductbranchesreports(_companyid uuid, _fromtime timestamp without time zone DEFAULT NULL::timestamp without time zone, _totime timestamp without time zone DEFAULT NULL::timestamp without time zone) RETURNS TABLE(productarabicname public.citext, productenglishname public.citext, branchname json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select
       ((p.name)->>'ar')::citext,
       ((p.name)->>'en')::citext,
       (select to_json(array (
                           select to_json(
                               jsonb_build_object('productname',(select name from product where product.id = p.id),'name',br.name,'count',(select sum(itemcount) from orderproduct inner join "order" o2 on orderproduct.orderid = o2.id where orderproduct.productid = p.id and o2.branchid = br.id) )) from branch br where br.companyid = (select id from company where id = _companyid) ))) branchname

from product p
left join orderproduct op on p.id = op.productid
left join "order" o on o.id = op.orderid
left join category c on p.categoryid = c.id
where  p.categoryid = any(select c.id from category where c.companyid = (select id from company where id = _companyid))
GROUP BY p.name,p.id;
END
$$;


--
-- Name: getproductbyarraycategory(uuid[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductbyarraycategory(_id uuid[] DEFAULT NULL::uuid[]) RETURNS SETOF public.product
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select * from product where product.categoryid = ANY(_id) and isavailable = true and isdeleted = false and ispublished = true;

END;
$$;


--
-- Name: getproductbycategory(uuid, public.citext, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductbycategory(_id uuid DEFAULT NULL::uuid, _languagecode public.citext DEFAULT 'en'::public.citext, _menuid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, name jsonb, branches jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select distinct(pr.id),pr.name,
 (select to_json( array(select row_to_json(getbranchforcategorybymenuid(_id := _menuid,_callid := pr.id)))))::jsonb
from branch
inner join menuchannel mec on mec.branchid = branch.id
left join menu on menu.id = (select menu.id from menu where menu.id = any(select mch.menuid from menuchannel mch where mch.branchid = branch.id and mch.channelid =(select nlk.id from namelookup nlk where nlk.name ='callcenter')) and menu.isdeleted = false)
left join menuproduct on menu.id = menuproduct.menuid
left join product pr on pr.id = menuproduct.productid
where mec.menuid = _menuid and pr.isdeleted = false and pr.ispublished = true and pr.isavailable = true
and pr.categoryid = _id and pr.id is not null ;

END;
$$;


--
-- Name: getproductbycategoryandchannel(uuid[], uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductbycategoryandchannel(_categoryid uuid[], _menuid uuid, _channel public.citext) RETURNS TABLE(categoryid uuid, id uuid, name jsonb, image public.citext, description jsonb, shortdescription jsonb, price numeric, displaynumber integer, preptimemin integer, preptimehour integer, isavailable boolean, branches jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select product.categoryid,product.id , product.name ,CONCAT(getimagepathurl(product.imagepath),product.imagepath)::citext , product.fulldescription , product.shortdescription ,(case
                                         when ((product.price)-> _channel is not null)
                                             then (
                                             ((product.price)-> _channel)::decimal
                                             )
                                         else ((((product.price)->'default')::decimal)) end)::decimal
                                         ,product.displaynumber,product.min,product.hour,product.isavailable,
                (select to_json( array(select row_to_json(getbranchforcategorybymenuidandchannel(_id := _menuid,_callid := product.id,_channel :=_channel)))))::jsonb

from product 
where product.isdeleted = false and product.ispublished = true and product.isavailable = true and product.id not in (select distinct unnest(productids) from productavailability where productavailability.isavailable = false and productavailability.isdeleted = false and productavailability.ispublished = true)
and product.categoryid = any(_categoryid) and product.id is not null order by product.displaynumber ASC;
END;
$$;


--
-- Name: getproductbycategoryandchannelinterface(uuid[], uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductbycategoryandchannelinterface(_categoryid uuid[], _menuid uuid, _channel public.citext) RETURNS TABLE(categoryid uuid, id uuid, external_pos_id public.citext, name jsonb, image public.citext, description jsonb, shortdescription jsonb, price numeric, displaynumber integer, preptimemin integer, preptimehour integer, isavailable boolean, discount json, branches uuid[], groups uuid[])
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select product.categoryid,product.id,product.external_pos_id , product.name ,CONCAT(getimagepathurl(product.imagepath),product.imagepath)::citext , product.fulldescription , product.shortdescription ,
(case when ((product.price)-> _channel is not null) then (((product.price)-> _channel)::decimal ) else ((((product.price)->'default')::decimal)) end)::decimal
,product.displaynumber,product.min,product.hour,product.isavailable,
(select to_json(getproductdiscountishbekinterface(_productid := product.id,_channel := _channel))),
ARRAY(select getbranchforcategorybymenuidandchannel(_id := _menuid,_callid := product.id,_channel :=_channel)),
--(select to_json( array(select row_to_json(getbranchforcategorybymenuidandchannel(_id := _menuid,_callid := product.id,_channel :=_channel)))))::jsonb
ARRAY(select pa.id from productattribute pa
                        where pa.productid = product.id
                        and pa.isglobal !=true
                        and pa.isdeleted = false
                        and pa.ispublished = true
                        and pa.attributeid is null
                        and pa.isdeleted = false)
from product 
where product.isdeleted = false and product.ispublished = true and product.isavailable = true and product.id not in (select distinct unnest(productids) from productavailability where productavailability.isavailable = false and productavailability.isdeleted = false and productavailability.ispublished = true)
and product.categoryid = any(_categoryid) and product.id is not null order by product.displaynumber ASC;
END;
$$;


--
-- Name: getproductbycategoryandchanneltest(uuid, uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductbycategoryandchanneltest(_categoryid uuid, _menuid uuid, _channel public.citext) RETURNS TABLE(categoryid uuid, id uuid, name jsonb, image public.citext, description jsonb, shortdescription jsonb, price numeric, displaynumber integer, preptimemin integer, preptimehour integer, isavailable boolean, branches jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select product.categoryid,product.id , product.name ,CONCAT(getimagepathurl(product.imagepath),product.imagepath)::citext , product.fulldescription , product.shortdescription ,(case
                                         when ((product.price)-> _channel is not null)
                                             then (
                                             ((product.price)-> _channel)::decimal
                                             )
                                         else ((((product.price)->'default')::decimal)) end)::decimal
                                         ,product.displaynumber,product.min,product.hour,product.isavailable,
                (select to_json( array(select row_to_json(getbranchforcategorybymenuidandchannel(_id := _menuid,_callid := product.id,_channel :=_channel)))))::jsonb

from product 
where product.isdeleted = false and product.ispublished = true and product.isavailable = true and product.id not in (select distinct unnest(productids) from productavailability where productavailability.isavailable = false and productavailability.isdeleted = false and productavailability.ispublished = true)
and product.categoryid = _categoryid and product.id is not null order by product.displaynumber ASC;
END;
$$;


--
-- Name: getproductbycategorys(uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductbycategorys(_id uuid DEFAULT NULL::uuid, _languagecode public.citext DEFAULT 'en'::public.citext) RETURNS SETOF public.product
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select * from product where product.categoryid = _id and isdeleted = false and ispublished = true;

END;
$$;


--
-- Name: getproductbyids(uuid[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductbyids(_productids uuid[] DEFAULT NULL::uuid[]) RETURNS TABLE(id uuid, name jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select  product.id, product.name 
from product 
where product.id = any(_productids) and isdeleted = false and ispublished = true and isavailable = true;

END;
$$;


--
-- Name: getproductdiscount(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductdiscount(_productid uuid, _branchid uuid) RETURNS TABLE(id uuid, value numeric, priority integer, ispercentage boolean, type public.citext)
    LANGUAGE plpgsql
    AS $$
    BEGIN
    RETURN QUERY
        select dinfo.id, dinfo.value, dinfo.priority, dinfo.ispercentage, dinfo.type from discountinfo dinfo
               inner join discountproduct dispr on dispr.discountid = dinfo.id
               inner join discountchannel disch on disch.discountid = dinfo.id
               inner join discountbranch disbr on disbr.discountid = dinfo.id
        where
             ((case when (dinfo.availablefrom::time < dinfo.availableto::time) then
                 case when ((dinfo.availablefrom::time <= ((now())::time + interval '3 hour')) and (dinfo.availableto::time >= (now())::time))  then 1 else 0 end
             else
                 case when ((dinfo.availableto::time <= (now())::time + interval '3 hour') and (dinfo.availablefrom::time >= (now())::time))  then 0 else 1 end
		   end) =1)
            and
            ((dinfo.availablefrom)::date) <= ((now())::date)  and ((dinfo.availableto)::date) >= ((now())::date)
            and
            (select to_char ( (now()), 'D'  )::integer) = any (dinfo.daysofweek)
            and dispr.productid = _productid
            and disch.channelid = (select nlk.id from namelookup nlk where nlk.name ='MobileApp')
            and disbr.branchid =_branchid
            and dinfo.isdeleted is not true
            and dinfo.type = 'Order' order by dinfo.priority desc,dinfo.createdat desc LIMIT 1;
    END;
$$;


--
-- Name: getproductdiscountishbekinterface(uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductdiscountishbekinterface(_productid uuid, _channel public.citext) RETURNS TABLE(value numeric, ispercentage boolean, priceafterdiscount numeric)
    LANGUAGE plpgsql
    AS $$
    BEGIN
    RETURN QUERY
        select dinfo.value,dinfo.ispercentage,
        (CASE WHEN dinfo.ispercentage THEN (((select (case when ((product.price)-> _channel is not null) then (((product.price)-> _channel)::decimal ) else ((((product.price)->'default')::decimal)) end)::decimal from product where id = _productid )::decimal) - ((select (case when ((product.price)-> _channel is not null) then (((product.price)-> _channel)::decimal ) else ((((product.price)->'default')::decimal)) end)::decimal from product where id = _productid )::decimal) * (dinfo.value / 100))::decimal else
        (((select (case when ((product.price)-> _channel is not null) then (((product.price)-> _channel)::decimal ) else ((((product.price)->'default')::decimal)) end)::decimal from product where id = _productid )::decimal) - (dinfo.value)::decimal)::decimal end)::decimal
        from discountinfo dinfo
               inner join discountproduct dispr on dispr.discountid = dinfo.id
               inner join discountchannel disch on disch.discountid = dinfo.id
        where
             ((case when (dinfo.availablefrom::time < dinfo.availableto::time) then
                 case when ((dinfo.availablefrom::time <= ((now())::time + interval '3 hour')) and (dinfo.availableto::time >= (now())::time))  then 1 else 0 end
             else
                 case when ((dinfo.availableto::time <= (now())::time + interval '3 hour') and (dinfo.availablefrom::time >= (now())::time))  then 0 else 1 end
		   end) =1)
            and
            ((dinfo.availablefrom)::date) <= ((now())::date)  and ((dinfo.availableto)::date) >= ((now())::date)
            and
            (select to_char ( (now()), 'D'  )::integer) = any (dinfo.daysofweek)
            and dispr.productid = _productid
            and disch.channelid = (select nlk.id from namelookup nlk where nlk.name =_channel)
            and dinfo.isdeleted is not true
            and dinfo.type = 'Order' order by dinfo.priority desc,dinfo.createdat desc LIMIT 1;
    END;
$$;


--
-- Name: getproductidofcategory(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductidofcategory(_companyid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY

select id as productid from product where product.categoryid
IN(select category.id from category where category.companyid = _companyid )
and product.isdeleted = false and product.isavailable = true and product.ispublished = true;
END;
$$;


--
-- Name: getproductimage(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductimage(_id uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, imagepath public.citext, productid uuid, createdat timestamp without time zone, createdby public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select productimages.id, productimages.imagepath, productimages.productid, productimages.createdat, productimages.createdby 
from productimages where productimages.id = _id and isdeleted = false and ispublished = true;

END;
$$;


--
-- Name: getproductimages(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductimages(_pagenumber integer DEFAULT NULL::integer, _pagesize integer DEFAULT NULL::integer) RETURNS TABLE(id uuid, imagepath public.citext, productid uuid, createdat timestamp without time zone, createdby public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select  
productimages.id, productimages.imagepath, productimages.productid, productimages.createdat, productimages.createdby 
from productimages where isdeleted = false and ispublished = true
LIMIT _pagesize
OFFSET ((_pagenumber-1) * _pagesize);

END;
$$;


--
-- Name: getproductnamebyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductnamebyid(_id uuid) RETURNS TABLE(name public.citext)
    LANGUAGE sql
    AS $$
select (name->>'en')::citext from product where id =_id
$$;


--
-- Name: getproductnotavailable(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductnotavailable(_id uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, name jsonb, isavailable boolean, isdeleted boolean, ispublished boolean)
    LANGUAGE plpgsql
    AS $$

BEGIN
RETURN QUERY
 select product.id,product.name,product.isavailable,product.isdeleted,product.ispublished from product where product.id = _id ;

END;
$$;


--
-- Name: getproductofcategory(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductofcategory(_companyid uuid DEFAULT NULL::uuid) RETURNS SETOF public.product
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY

select
    id,
    categoryid,
    concat(getimagepath(imagepath),imagepath)::citext,
    isdeleted,
    ispublished,
    createdat,
    createdby,
    updatedat,
    updatedby,
    deletedat,
    deletedby,
    price,
    description,
    name,
    shortdescription,
    sku,
    fulldescription,
    isavailable,
    hour,
    min,
    displaynumber,
    isoffer,
    producttags,
    istopselling,
    branchprice,
    aliasdescription,
    aliasname,
    concat(getimagepath(thumbimage),thumbimage)::citext,
    external_pos_id
 from product where product.categoryid 
IN(select category.id from category where category.companyid = _companyid )
and product.isdeleted = false and product.isavailable = true and product.ispublished = true;
END;
$$;


--
-- Name: getproductofcategorydto(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductofcategorydto(_companyid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, name public.citext, isdeleted boolean)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY

select product.id,(product.name->>'en')::citext ,product.isdeleted from product where product.categoryid
IN(select category.id from category where category.companyid = _companyid );
END;
$$;


--
-- Name: getproductreports(uuid[], uuid[], uuid[], timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductreports(_branchids uuid[], _source uuid[], _products uuid[], _fromtime timestamp without time zone DEFAULT NULL::timestamp without time zone, _totime timestamp without time zone DEFAULT NULL::timestamp without time zone) RETURNS TABLE(id uuid, productname jsonb, proen public.citext, proar public.citext, createdat timestamp without time zone, isdeleted boolean, productnotes public.citext, pricewithouttax numeric, pricewithtax numeric, categoryname public.citext, branchname public.citext, orderid uuid, orderno public.citext, quantity integer, ordersource public.citext, ordertype public.citext, currentstatus public.citext, ordernote public.citext, ordercancel boolean, orderdeclined boolean, customername public.citext, phone public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
SELECT opro.id,pro.name as productname,(pro.name->>'en')::citext as proen,(pro.name->>'ar')::citext as proar
,pro.createdat, pro.isdeleted,opro.notes as productnotes,opro.pricesubtotal as pricewithouttax,opro.pricetaxvalue as pricewithtax,
(ca.name->>'en')::citext as categoryname,br.name as branchname,ord.id as orderid,ord.branchorderid as orderno,
opro.itemcount as quantity,
getlookupname(ord.ordersource) as ordersource,getdeliverycompanyname(ord.deliverytype) as ordertype,
getorderstatus(ord.currentstatus) as currentstatus,ord.notes as ordernote,
ord.iscanceled as ordercancel,ord.isdeclined as orderdeclined,
cu.name as customername,cu.phoneno as phone
FROM orderproduct opro LEFT JOIN product pro on pro.id = opro.productid
INNER JOIN category ca on ca.id = pro.categoryid
INNER join "order" ord on ord.id = opro.orderid
INNER JOIN branch br on br.id = ord.branchid
INNER JOIN customer cu on cu.id = ord.customerid
where ((_fromtime is null) or( _fromtime <= opro.createdat))
and ((_totime is null) or( _totime >= opro.createdat))
and ord.branchid = any(_branchids)
and ord.ordersource = any(_source)
and opro.productid = any(_products)
order by opro.createdat ASC;
END;
$$;


--
-- Name: getproductreports1(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductreports1() RETURNS TABLE(id uuid, productname jsonb, proen public.citext, proar public.citext, createdat timestamp without time zone, productnotes public.citext, pricewithouttax numeric, pricewithtax numeric, categoryname jsonb, branchname public.citext, orderid uuid, orderno public.citext, quantity integer, ordersource public.citext, ordertype public.citext, currentstatus public.citext, ordernote public.citext, ordercancel boolean, orderdeclined boolean, customername public.citext, phone public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
SELECT opro.id,pro.name as productname,(pro.name->>'en')::citext as proen,(pro.name->>'ar')::citext as proar
,pro.createdat,opro.notes as productnotes,opro.pricesubtotal as pricewithouttax,opro.pricetaxvalue as pricewithtax,
ca.name as categoryname,br.name as branchname,ord.id as orderid,ord.branchorderid as orderno,
opro.itemcount as quantity,
getlookupname(ord.ordersource) as ordersource,getdeliverycompanyname(ord.deliverytype) as ordertype,
getorderstatus(ord.currentstatus) as currentstatus,ord.notes as ordernote,
ord.iscanceled as ordercancel,ord.isdeclined as orderdeclined,
cu.name as customername,cu.phoneno as phone
FROM orderproduct opro LEFT JOIN product pro on pro.id = opro.productid 
LEFT JOIN category ca on ca.id = pro.categoryid 
LEFT join "order" ord on ord.id = opro.orderid
LEFT JOIN branch br on br.id = ord.branchid
LEFT JOIN customer cu on cu.id = ord.customerid
order by opro.createdat ASC;
END;
$$;


--
-- Name: getproducts(public.citext, integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproducts(_languagecode public.citext DEFAULT 'en'::public.citext, _pagenumber integer DEFAULT NULL::integer, _pagesize integer DEFAULT NULL::integer) RETURNS SETOF public.product
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select  
* from product where isdeleted = false and ispublished = true
LIMIT _pagesize
OFFSET ((_pagenumber-1) * _pagesize);

END;
$$;


--
-- Name: getproductsalesreport(uuid, timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductsalesreport(_companyid uuid, _fromtime timestamp without time zone DEFAULT NULL::timestamp without time zone, _totime timestamp without time zone DEFAULT NULL::timestamp without time zone) RETURNS text
    LANGUAGE plpgsql
    AS $$
    declare branch branch;
    declare querytoexec text;
BEGIN
    querytoexec = 'select to_json(Array(select to_json(query) from
                          (select p.name->>'||concat('''','en','''')||'as englishname ,p.name->>'||concat('''','ar','''')||'as arabicname , ';
     foreach branch in array( select array_agg(b) FROM branch b where companyid = _companyid and b.isdeleted = false)
    loop
    querytoexec = querytoexec || 'gettablecellproductbranchsalescounts('|| concat('''', branch.id , '''')  || ' , p.id, '|| concat('''', _fromtime , '''')  || ', '|| concat('''', _totime, '''')  || ') as ' || replace(replace(replace( branch.name,' ',''),'.',''),'-','') || '_Count'  ||' , ';
    querytoexec = querytoexec || 'gettablecellproductbranchsalesvalues('|| concat('''', branch.id , '''')  || ' , p.id, '|| concat('''', _fromtime , '''')  || ', '|| concat('''', _totime, '''')  || ') as ' || replace(replace(replace( branch.name,' ',''),'.',''),'-','') || '_Amount'   ||' , ';
   END LOOP;
    querytoexec =  substr(querytoexec , 1 , length(querytoexec) - 2);
    querytoexec = querytoexec || 'from category join product p on category.id = p.categoryid where companyid = '|| concat('''' ,  _companyid ,'''') ||') query))';
    return querytoexec;

 END;
$$;


--
-- Name: getproductsattribute(uuid[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductsattribute(_productids uuid[] DEFAULT NULL::uuid[]) RETURNS TABLE(id uuid)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select productattribute.id as attid from productattribute where productattribute.productid = ANY(_productids) and isavailable = true and isdeleted = false and ispublished = true;
END;
$$;


--
-- Name: getproductsattributes(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductsattributes() RETURNS SETOF public.productattribute
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select  * from productattribute where isdeleted = false and ispublished = true;

END;
$$;


--
-- Name: getproductsavailability(uuid[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductsavailability(_id uuid[] DEFAULT NULL::uuid[]) RETURNS SETOF public.productavailability
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select * from productavailability  
where productids = ANY (select productids from productavailability where productids <@ ( _id) 
and isavailable = true
and isdeleted =false
and ispublished = true) and isavailable = true
and isdeleted =false
and ispublished = true;

END; 
$$;


--
-- Name: getproductscategoryfordiscount(uuid[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductscategoryfordiscount(_categoryid uuid[]) RETURNS SETOF uuid[]
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select array_agg(p.id) from product p where p.categoryid = any(_categoryid) and p.isdeleted = false and p.ispublished = true;
END;
$$;


--
-- Name: producttags; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.producttags (
    productid uuid NOT NULL,
    nametags public.citext[],
    sizetags public.citext[],
    ingredienttags public.citext[],
    createdat timestamp without time zone DEFAULT now()
);


--
-- Name: getproductstagsbyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductstagsbyid(_productid uuid) RETURNS SETOF public.producttags
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select  * from producttags pt where pt.productid = _productid;
END;
$$;


--
-- Name: getproductstax(uuid[], uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductstax(_id uuid[] DEFAULT NULL::uuid[], _sourceid uuid DEFAULT NULL::uuid) RETURNS TABLE(productid uuid, name public.citext, taxpercentage numeric, price numeric)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select p.id,(p.price->'priceTaxPercentage')::citext,(p.price->'priceTaxPercentage')::numeric,
 coalesce(((p.price->(select nml.name from namelookup nml where id = _sourceid))::numeric),((p.price->>'default')::numeric)) from product p  where p.id = any(_id);
END;
$$;


--
-- Name: getproductunnestattributeidanswer(uuid, uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getproductunnestattributeidanswer(_id uuid, _menuid uuid, _channel public.citext) RETURNS TABLE(id uuid)
    LANGUAGE plpgsql
    AS $$
                  BEGIN
                  RETURN QUERY
                  select unnest(getproductattributeidanswer(_id := _id,_menuid := _menuid,_channel :=_channel)); 
                  
  
END;

$$;


--
-- Name: getpromocodebyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getpromocodebyid(_id uuid) RETURNS TABLE(id uuid, name public.citext, type public.citext, ispercentage boolean, daysofweek integer[], description public.citext, value numeric, maxvalue numeric, minquantity integer, minprice numeric, availablefrom timestamp without time zone, availableto timestamp without time zone, priority integer, isdaily boolean, numberofuse integer, numberofusecustomer integer, descriptionlanguage jsonb, promocodebranch json, promocodechannel json, promocodecategory json, promocodecustomer json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
SELECT prc.id ,prc.name, prc.type,prc.ispercentage,
prc.daysofweek,prc.description,prc.value,prc.maxvalue,prc.minquantity,prc.minprice,prc.availablefrom,prc.availableto,prc.priority,prc.isdaily,(prc.numberofuse) :: integer,prc.numberofusecustomer,prc.descriptionlanguage,
(SELECT to_json(
	array(
	select to_json(
		jsonb_build_object(
			'id',dbr.branchid,
			'name',br.name
		)
	)from promocodebranch dbr left join  branch br on br.id=dbr.branchid where dbr.promocodeid=prc.id 
	))) --promocode branch
    ,(select to_json(
	array(
	select to_json(
	jsonb_build_object(
		'id',dischl.channelid,
	    'name', (select nlk.name where nlk.id = any(select dischl.channelid))
	)) from promocodechannel dischl inner join namelookup nlk on nlk.id = dischl.channelid  where dischl.promocodeid = prc.id
	)
	))--promocode channels
    ,(SELECT to_json(
	array(
	select to_json(
		jsonb_build_object(
			'id',prcat.categoryid,
			'name',cat.name
		)
	)from promocodecategory prcat left join category cat on cat.id=prcat.categoryid where prcat.promocodeid=prc.id 
	)))--promocode category
    ,(SELECT to_json(array (select to_json(json_build_object(
                      'id',cus.id,
                       'name',cus.name,
                       'phoneno',cus.phoneno
                      )) from promocodecustomers pcus
                         inner join customer cus on cus.id = pcus.customerid
                         where pcus.promocodeid = prc.id group by(cus.id,cus.name,cus.phoneno)
                      )))--promocode customer
              
              
              
 from promocode prc WHERE prc.id=_id;
	
END;
$$;


--
-- Name: getpromocodebyname(public.citext, uuid, uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getpromocodebyname(_promocode public.citext, _branchid uuid DEFAULT NULL::uuid, _customerid uuid DEFAULT NULL::uuid, _channel public.citext DEFAULT NULL::public.citext) RETURNS TABLE(id uuid, name public.citext, type public.citext, value numeric, maxvalue numeric, minquantity integer, minprice numeric, numberofusecustomer integer, numberofusage integer, isdaily boolean, ispercentage boolean, numberofuse bigint, customerids jsonb, customerorder jsonb)
    LANGUAGE plpgsql
    AS $$

    BEGIN
    RETURN QUERY
        select proc.id, proc.name, proc.type, proc.value, proc.maxvalue, proc.minquantity, proc.minprice, proc.numberofusecustomer, proc.numberofusage, proc.isdaily, proc.ispercentage, proc.numberofuse,
        (select to_json(array (
                           select to_json(
                               jsonb_build_object( 'customerid',procus.customerid,
                                                   'promocodeid',procus.promocodeid,
                                                   'numberofusage',procus.numberofusage,
                                                   'lasttime', ((now() + interval '3 hour') - (lastusetime))::time
                                                 ))
                               from promocodecustomers procus where promocodeid = proc.id ))::jsonb),
        (select to_json(array (
                           select to_json(
                               jsonb_build_object( 'customerid',ord.customerid,
                                                   'numberofusage',count(ord.id),
                                                   'lasttime', ((now() + interval '3 hour') - (max(ord.createdat)))::time
                                                 ))
                               from promocode prc INNER JOIN "order" ord on(((ord.price->>'PromoCode')::Json)->>'Id')::uuid = prc.id where proc.id = (((ord.price->>'PromoCode')::Json)->>'Id')::uuid and ord.customerid = _customerid group by ord.customerid ))::jsonb)
                               
        from promocode proc INNER JOIN promocodebranch prbr on prbr.promocodeid = proc.id
        INNER JOIN promocodechannel proch on proch.promocodeid = proc.id
        where
            ((case when (proc.availablefrom::time < proc.availableto::time) then
                 case when ((proc.availablefrom::time <= ((now())::time + interval '3 hour')) and (proc.availableto::time >= (now())::time))  then 1 else 0 end
             else
                 case when ((proc.availableto::time <= (now())::time + interval '3 hour') and (proc.availablefrom::time >= (now())::time))  then 0 else 1 end
		   end) =1) and
            ((proc.availablefrom)::date) <= ((now())::date)  and ((proc.availableto)::date) >= ((now())::date)
            and
            (select to_char ( (now()), 'D'  )::integer) = any (proc.daysofweek)
            and proc.name = _promocode
            and prbr.branchid = _branchid
            and proch.channelid = (select nlm.id from namelookup nlm where nlm.name = _channel)
            and proc.isavailable = true and proc.isdeleted = false  
            order by proc.priority desc,proc.createdat desc LIMIT 1;
    END;
$$;


--
-- Name: getqrcodesbycompanyandchannel(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getqrcodesbycompanyandchannel(_companyid uuid, _channelid uuid) RETURNS TABLE(qrcode public.citext, branch_name public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        concat(getimagepath(mqr.qrcode),mqr.qrcode)::citext as qrcode ,
        b.name
    FROM
        public.menuqrcode mqr
        JOIN public.menuchannel mc ON mc.branchid = mqr.branchid
        JOIN public.branch b ON b.id = mqr.branchid
    WHERE
        b.companyid = _companyid AND
        mc.channelid = _channelid;
END;
$$;


--
-- Name: getrelatedproductsforproduct(uuid, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getrelatedproductsforproduct(_id uuid DEFAULT NULL::uuid, _languagecode public.citext DEFAULT 'en'::public.citext) RETURNS TABLE(id uuid, name public.citext, description public.citext, categoryid uuid, price jsonb, imagepath public.citext, createdat timestamp without time zone, createdby public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select  relatedproduct.relatedproductid,getvalue(_languagecode,'productName',relatedproduct.relatedproductid,1), product.description, product.categoryid, product.price, product.imagepath, product.createdat  , product.createdby
from relatedproduct
left join product on product.id =relatedproduct.relatedproductid
where relatedproduct.productid = _id and product.isdeleted = false and product.ispublished = true and relatedproduct.isdeleted = false and relatedproduct.ispublished = true;
END;
$$;


--
-- Name: getrestaurantcustomerbycompnyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getrestaurantcustomerbycompnyid(_companyid uuid) RETURNS TABLE(id uuid, customerid uuid, restaurantid uuid, lastpointdate timestamp without time zone, currentpoints numeric, currentstatus integer, name public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select rc.id,
           rc.customerid,
           rc.restaurantid,
           rc.lastpointdate,
           rc.currentpoints,
           rc.currentstatus,
           lk.name
    from restaurantcustomer rc
    inner join lookup lk on lk.id = rc.currentstatus
    where rc.restaurantid = _companyid;

END
$$;


--
-- Name: getrestaurantentityid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getrestaurantentityid(_companyid uuid) RETURNS TABLE(entityid public.citext, authid public.citext, entityidapplepay public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select rpc.marchent, rpc.authid , rpc.marchentapplepay from restaurantpaymentcredentials rpc where rid = _companyid;
END;
$$;


--
-- Name: getrestaurantintegrationrequestfortalabat(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getrestaurantintegrationrequestfortalabat(_companyid uuid) RETURNS TABLE(channelid uuid, status public.citext, isactive boolean, createdby public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
    return query select c.channelid, c.status, c.isactive,  c.createdby from companyactiveintegrations c where c.channelid = '35f7e99f-ad6e-48b3-8975-d9124896e15d' and c.companyid = _companyid;
end
$$;


--
-- Name: getrestaurantparams(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getrestaurantparams(_companyid uuid) RETURNS TABLE(restaurantid uuid, period integer, loyalityperiod integer, loyalitycount integer, loyalityamount numeric, createdby public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select rp.restaurantid,
           rp.period,
           rp.loyalityperiod,
           rp.loyalitycount,
           rp.loyalityamount,
           rp.createdby
           from restaurantparams rp
    where rp.restaurantid = _companyid;
END
$$;


--
-- Name: getrestaurntmenuwithbrandid(uuid, public.citext, boolean); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getrestaurntmenuwithbrandid(_companyid uuid, _brandid public.citext, _istaxable boolean) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
        SELECT json_build_object(
                       'paperboyURL', '',
                       'callbackURL', '',
                       'scheduledOn', '',
                       'categories', to_json(
                               ARRAY(
                                       SELECT to_json(
                                                      json_build_object(
                                                              'id', c.id,
                                                              'arabicName', coalesce(c.name ->> 'ar', c.name ->> 'en'),
                                                              'englishName', coalesce(c.name ->> 'en', c.name ->> 'ar'),
                                                              'sortOrder', c.displaynumber,
                                                              'items', to_json(
                                                                      ARRAY(
                                                                              SELECT to_json(
                                                                                             json_build_object(
                                                                                                     'id', p.id,
                                                                                                     'arabicName',
                                                                                                     coalesce(p.name ->> 'ar', p.name ->> 'en'),
                                                                                                     'englishName',
                                                                                                     coalesce(p.name ->> 'en', p.name ->> 'ar'),
                                                                                                     'englishDescription',
                                                                                                     coalesce(p.shortdescription ->> 'en', p.shortdescription ->> 'ar'),
                                                                                                     'arabicDescription',
                                                                                                     coalesce(p.shortdescription ->> 'ar', p.shortdescription ->> 'en'),
                                                                                                     'price', CASE
                                                                                                                  WHEN _istaxable
                                                                                                                      THEN
                                                                                                                      coalesce(
                                                                                                                              ((p.price ->> 'talabat')::NUMERIC) *
                                                                                                                              (((p.price ->> 'priceTaxPercentage')::NUMERIC) + 1),
                                                                                                                              ((p.price ->> 'default')::NUMERIC) *
                                                                                                                              (((p.price ->> 'priceTaxPercentage')::NUMERIC) + 1))
                                                                                                                  ELSE
                                                                                                                      coalesce(
                                                                                                                              (p.price ->> 'talabat')::NUMERIC,
                                                                                                                              (p.price ->> 'default')::NUMERIC)
                                                                                                         END,
                                                                                                     'isAvailable',
                                                                                                     p.isavailable,
                                                                                                     'sortOrder',
                                                                                                     p.displaynumber,
                                                                                                     'availableFrom',
                                                                                                     '00:00',
                                                                                                     'availableTo',
                                                                                                     '23:59',
                                                                                                     'availableDays',
                                                                                                     '0,1,2,3,4,5,6',
                                                                                                     'imageURL',
                                                                                                     concat(getimagepath(p.imagepath), p.imagepath),
                                                                                                     'thumbnail', '',
                                                                                                     'itemDiscount',
                                                                                                     NULL, -- Assume unchanged
                                                                                                     'branchesAvailability',
                                                                                                     to_json(
                                                                                                             ARRAY(
                                                                                                                     SELECT to_json(
                                                                                                                                    json_build_object(
                                                                                                                                            'branchId',
                                                                                                                                            b.id,
                                                                                                                                            'status',
                                                                                                                                            check_branch_availability(
                                                                                                                                                    p.id,
                                                                                                                                                    p.categoryid,
                                                                                                                                                    b.id,
                                                                                                                                                    '35f7e99f-ad6e-48b3-8975-d9124896e15d',
                                                                                                                                                    p.isavailable
                                                                                                                                            ),
                                                                                                                                            'price',
                                                                                                                                            CASE
                                                                                                                                                WHEN _istaxable
                                                                                                                                                    THEN
                                                                                                                                                    coalesce(
                                                                                                                                                            ((p.price ->> 'talabat')::NUMERIC) *
                                                                                                                                                            (((p.price ->> 'priceTaxPercentage')::NUMERIC) + 1),
                                                                                                                                                            ((p.price ->> 'default')::NUMERIC) *
                                                                                                                                                            (((p.price ->> 'priceTaxPercentage')::NUMERIC) + 1))
                                                                                                                                                ELSE
                                                                                                                                                    coalesce(
                                                                                                                                                            (p.price ->> 'talabat')::NUMERIC,
                                                                                                                                                            (p.price ->> 'default')::NUMERIC)
                                                                                                                                                END
                                                                                                                                    )
                                                                                                                            )
                                                                                                                     FROM branch b
                                                                                                                              JOIN talabatcredential tc ON b.id = ishbekbranchid
                                                                                                                     WHERE talabatbrandid = _brandid
                                                                                                                       AND b.companyid = _companyid
                                                                                                                       AND
                                                                                                                         b.id IN
                                                                                                                         (SELECT branchid
                                                                                                                          FROM menuchannel
                                                                                                                          WHERE channelid = '35f7e99f-ad6e-48b3-8975-d9124896e15d')
                                                                                                                       AND b.isdeleted = FALSE
                                                                                                                       AND
                                                                                                                         (SELECT COUNT(*)
                                                                                                                          FROM menuproduct
                                                                                                                          WHERE productid = p.id
                                                                                                                            AND
                                                                                                                              menuid = ANY
                                                                                                                              (SELECT menuid
                                                                                                                               FROM menuchannel
                                                                                                                               WHERE menuchannel.branchid = b.id)) >
                                                                                                                         0
                                                                                                             )
                                                                                                     ),
                                                                                                     'choiceCategories',
                                                                                                     (to_json(Array
                                                                                                              (select to_json(json_build_object(
                                                                                                                     'id',
                                                                                                                     pa.id,
                                                                                                                     'englishName',
                                                                                                                     pa.name ->>
                                                                                                                     'en',
                                                                                                                     'arabicName',
                                                                                                                     pa.name ->>
                                                                                                                     'ar',
                                                                                                                 --'minimumSelections', case when(pa.isrequired) then 1 else 0 end ,
                                                                                                                 --'maximumSelections', case when(pa.noofselection>99)then 99 else pa.noofselection end,
                                                                                                                     'minimumSelections',
                                                                                                                     pa.minimumcount,
                                                                                                                     'maximumSelections',
                                                                                                                     pa.maximumcount,
                                                                                                                     'sortOrder',
                                                                                                                     pa.priority,
                                                                                                                     'choices',
                                                                                                                     (to_json(Array(
                                                                                                                         --case when lvl 2 or 3
                                                                                                                             select (
                                                                                                                                        case
                                                                                                                                            when (not (select doeshavechildren(psa.id)))
                                                                                                                                                then
                                                                                                                                                to_json(json_build_object(
                                                                                                                                                        'id',
                                                                                                                                                        psa.id,
                                                                                                                                                        'englishName',
                                                                                                                                                        psa.name ->>
                                                                                                                                                        'en',
                                                                                                                                                        'arabicName',
                                                                                                                                                        psa.name ->>
                                                                                                                                                        'ar',
                                                                                                                                                        'price',
                                                                                                                                                        coalesce(
                                                                                                                                                                ((pa.price ->> 'talabat')::numeric),
                                                                                                                                                                ((pa.price ->> 'default')::numeric)
                                                                                                                                                        )
                                                                                                                                                            +
                                                                                                                                                        coalesce(
                                                                                                                                                                ((psa.price ->> 'talabat')::numeric),
                                                                                                                                                                ((psa.price ->> 'default')::numeric)
                                                                                                                                                        ),
                                                                                                                                                        'isAvailable',
                                                                                                                                                        true, --get is available from branchavailability and psa.isavailable
                                                                                                                                                        'sortOrder',
                                                                                                                                                        psa.priority,
                                                                                                                                                        'imageURL',
                                                                                                                                                        '',
                                                                                                                                                        'thumbnail',
                                                                                                                                                        '',
                                                                                                                                                        'branchesAvailability',
                                                                                                                                                        (to_json(Array(select to_json(json_build_object(
                                                                                                                                                                'branchId',
                                                                                                                                                                mcl.branchid,
                                                                                                                                                                'status',check_modifire_branch_availability(pa.id,psa.id,mcl.branchid,'35f7e99f-ad6e-48b3-8975-d9124896e15d',psa.isavailable),
                                                                                                                                                                'price',
                                                                                                                                                                coalesce(
                                                                                                                                                                        ((pa.price ->> 'talabat')::numeric),
                                                                                                                                                                        ((pa.price ->> 'default')::numeric)
                                                                                                                                                                )
                                                                                                                                                                    +
                                                                                                                                                                coalesce(
                                                                                                                                                                        ((psa.price ->> 'talabat')::numeric),
                                                                                                                                                                        ((psa.price ->> 'default')::numeric)
                                                                                                                                                                )
                                                                                                                                                                                      ))
                                                                                                                                                                       from menuproduct mp
                                                                                                                                                                                inner join menu m on m.id = mp.menuid
                                                                                                                                                                                inner join menuchannel mcl on mcl.menuid = m.id
                                                                                                                                                                                left join branch b on b.menuid = mcl.branchid
                                                                                                                                                                       where p.id = mp.productid
                                                                                                                                                                         and
                                                                                                                                                                           m.id = any
                                                                                                                                                                           (select menu.id
                                                                                                                                                                            from menu
                                                                                                                                                                            where
                                                                                                                                                                                menu.id = any
                                                                                                                                                                                (select mch.menuid
                                                                                                                                                                                 from menuchannel mch
                                                                                                                                                                                 where
                                                                                                                                                                                     mch.branchid = any
                                                                                                                                                                                     (select b.id
                                                                                                                                                                                      from branch b
                                                                                                                                                                                               join talabatcredential on b.id = ishbekbranchid
                                                                                                                                                                                      where talabatbrandid = _brandid
                                                                                                                                                                                        and b.companyid = _companyid)
                                                                                                                                                                                   and
                                                                                                                                                                                     mch.channelid =
                                                                                                                                                                                     (select nlp.id
                                                                                                                                                                                      from namelookup nlp
                                                                                                                                                                                      where nlp.name = 'talabat'
                                                                                                                                                                                        and nlp.tabletype = 'ordersource'))
                                                                                                                                                                              and menu.isdeleted = false)
                                                                                                                                                                 )))
                                                                                                                                                        ))
                                                                                                                                            else to_json(json_build_object(
                                                                                                                                                    'id',
                                                                                                                                                    pssa.id,
                                                                                                                                                    'englishName',
                                                                                                                                                    concat(psa.name ->> 'en', ' - ', pssa.name ->> 'en'),
                                                                                                                                                    'arabicName',
                                                                                                                                                    concat(pssa.name ->> 'ar', ' - ', psa.name ->> 'ar'),
                                                                                                                                                    'price',
                                                                                                                                                    coalesce(
                                                                                                                                                            ((pa.price ->> 'talabat')::numeric),
                                                                                                                                                            ((pa.price ->> 'default')::numeric)) +
                                                                                                                                                    coalesce(
                                                                                                                                                            ((psa.price ->> 'talabat')::numeric),
                                                                                                                                                            ((psa.price ->> 'default')::numeric)) +
                                                                                                                                                    coalesce(
                                                                                                                                                            ((pssa.price ->> 'talabat')::numeric),
                                                                                                                                                            ((pssa.price ->> 'default')::numeric)),
                                                                                                                                                    'isAvailable',
                                                                                                                                                    true, --get is available from branchavailability and psa.isavailable
                                                                                                                                                    'sortOrder',
                                                                                                                                                    pssa.priority,
                                                                                                                                                    'imageURL',
                                                                                                                                                    '',
                                                                                                                                                    'thumbnail',
                                                                                                                                                    '',
                                                                                                                                                    'branchesAvailability',
                                                                                                                                                    (to_json(Array(select to_json(json_build_object(
                                                                                                                                                            'branchId',
                                                                                                                                                            mcl.branchid,
                                                                                                                                                            'status',
                                                                                                                                                            case
                                                                                                                                                                when (
                                                                                                                                                                    (select count(*)
                                                                                                                                                                     from branchavailability ba
                                                                                                                                                                     where ba.objecttype = 'attribute'
                                                                                                                                                                       and ba.objectid = pa.id
                                                                                                                                                                       and ba.branchid = b.id
                                                                                                                                                                       and ba.channelid = '35f7e99f-ad6e-48b3-8975-d9124896e15d') >
                                                                                                                                                                    0)
                                                                                                                                                                    then false
                                                                                                                                                                when (
                                                                                                                                                                    (select count(*)
                                                                                                                                                                     from branchavailability ba
                                                                                                                                                                     where ba.objecttype = 'attribute'
                                                                                                                                                                       and ba.objectid = psa.id
                                                                                                                                                                       and ba.branchid = b.id
                                                                                                                                                                       and ba.channelid = '35f7e99f-ad6e-48b3-8975-d9124896e15d') >
                                                                                                                                                                    0)
                                                                                                                                                                    then false
                                                                                                                                                                when (
                                                                                                                                                                    (select count(*)
                                                                                                                                                                     from branchavailability ba
                                                                                                                                                                     where ba.objecttype = 'attribute'
                                                                                                                                                                       and ba.objectid = pssa.id
                                                                                                                                                                       and ba.branchid = b.id
                                                                                                                                                                       and ba.channelid = '35f7e99f-ad6e-48b3-8975-d9124896e15d') >
                                                                                                                                                                    0)
                                                                                                                                                                    then false
                                                                                                                                                                else psa.isavailable end,
                                                                                                                                                            'price',
                                                                                                                                                            coalesce(
                                                                                                                                                                    ((pa.price ->> 'talabat')::numeric),
                                                                                                                                                                    ((pa.price ->> 'default')::numeric)
                                                                                                                                                            )
                                                                                                                                                                +
                                                                                                                                                            coalesce(
                                                                                                                                                                    ((psa.price ->> 'talabat')::numeric),
                                                                                                                                                                    ((psa.price ->> 'default')::numeric)
                                                                                                                                                            )
                                                                                                                                                                +
                                                                                                                                                            coalesce(
                                                                                                                                                                    ((pssa.price ->> 'talabat')::numeric),
                                                                                                                                                                    ((pssa.price ->> 'default')::numeric)
                                                                                                                                                            )
                                                                                                                                                                                  ))
                                                                                                                                                                   from menuproduct mp
                                                                                                                                                                            inner join menu m on m.id = mp.menuid
                                                                                                                                                                            inner join menuchannel mcl on mcl.menuid = m.id
                                                                                                                                                                            left join branch b on b.menuid = mcl.branchid
                                                                                                                                                                   where p.id = mp.productid
                                                                                                                                                                     and
                                                                                                                                                                       m.id = any
                                                                                                                                                                       (select menu.id
                                                                                                                                                                        from menu
                                                                                                                                                                        where
                                                                                                                                                                            menu.id = any
                                                                                                                                                                            (select mch.menuid
                                                                                                                                                                             from menuchannel mch
                                                                                                                                                                             where
                                                                                                                                                                                 mch.branchid = any
                                                                                                                                                                                 (select b.id
                                                                                                                                                                                  from branch b
                                                                                                                                                                                           join talabatcredential on b.id = ishbekbranchid
                                                                                                                                                                                  where talabatbrandid = _brandid
                                                                                                                                                                                    and b.companyid = _companyid)
                                                                                                                                                                               and
                                                                                                                                                                                 mch.channelid =
                                                                                                                                                                                 (select nlp.id
                                                                                                                                                                                  from namelookup nlp
                                                                                                                                                                                  where nlp.name = 'talabat'
                                                                                                                                                                                    and nlp.tabletype = 'ordersource'))
                                                                                                                                                                          and menu.isdeleted = false)
                                                                                                                                                             )))
                                                                                                                                                         ))
                                                                                                                                            end
                                                                                                                                        )
                                                                                                                             from productattribute psa
                                                                                                                                      left join productattribute pssa on pssa.attributeid = psa.id
                                                                                                                             where psa.attributeid = pa.id
                                                                                                                               and psa.isdeleted = false
                                                                                                                              )))
                                                                                                                              ))
                                                                                                               from productattribute pa
                                                                                                               where pa.productid = p.id
                                                                                                                 and pa.isdeleted = false
                                                                                                                 and pa.attributeid is null
                                                                                                              )))
                                                                                             )
                                                                                     )
                                                                              FROM product p
                                                                              WHERE p.categoryid = c.id
                                                                                AND p.isdeleted = FALSE
                                                                                AND EXISTS (SELECT 1
                                                                                            FROM menuproduct mpc
                                                                                            WHERE mpc.productid = p.id
                                                                                              AND mpc.menuid = ANY
                                                                                                  (SELECT menu.id
                                                                                                   FROM menu
                                                                                                   WHERE menu.id = ANY
                                                                                                         (SELECT mch.menuid
                                                                                                          FROM menuchannel mch
                                                                                                          WHERE
                                                                                                              mch.branchid = ANY
                                                                                                              (SELECT b.id
                                                                                                               FROM branch b
                                                                                                                        JOIN talabatcredential tc ON b.id = ishbekbranchid
                                                                                                               WHERE talabatbrandid = _brandid
                                                                                                                 AND b.companyid = _companyid)
                                                                                                            AND
                                                                                                              mch.channelid =
                                                                                                              (SELECT nlp.id
                                                                                                               FROM namelookup nlp
                                                                                                               WHERE nlp.name = 'talabat'
                                                                                                                 AND nlp.tabletype = 'ordersource'))))
                                                                      )
                                                                       )
                                                      )
                                              )
                                       FROM category c
                                       WHERE c.companyid = _companyid
                                         AND c.isdeleted = FALSE
                                         AND c.id = ANY (SELECT mc.categoryid
                                                         FROM menucategories mc
                                                         WHERE mc.menuid = ANY (SELECT menu.id
                                                                                FROM menu
                                                                                WHERE menu.id = ANY (SELECT mch.menuid
                                                                                                     FROM menuchannel mch
                                                                                                     WHERE
                                                                                                         mch.branchid = ANY
                                                                                                         (SELECT b.id
                                                                                                          FROM branch b
                                                                                                                   JOIN talabatcredential tc ON b.id = ishbekbranchid
                                                                                                          WHERE talabatbrandid = _brandid
                                                                                                            AND b.companyid = _companyid)
                                                                                                       AND
                                                                                                         mch.channelid =
                                                                                                         (SELECT nlp.id
                                                                                                          FROM namelookup nlp
                                                                                                          WHERE nlp.name = 'talabat'
                                                                                                            AND nlp.tabletype = 'ordersource'))
                                                                                  AND menu.isdeleted = FALSE))
                               )
                                     )
               );
END;
$$;


--
-- Name: getschedueledorders(uuid[]); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getschedueledorders(_branchid uuid[]) RETURNS TABLE(branchorderid public.citext, id uuid, customername public.citext, customerphone public.citext, branchid uuid, ordersource public.citext, deliverytype public.citext, scheduled boolean, currentstatus public.citext, statuscolor public.citext, scheduledate timestamp without time zone)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select
    "order".branchorderid,
    "order".id,cus.name,
    cus.phoneno,
    "order".branchid,
    getlookupname("order".ordersource),
    getdeliverycompanyname("order".deliverytype),
    CASE
        when "order".scheduled is not null  then true
    else false
  END ,
    getorderstatus("order".currentstatus ),
    getorderstatuscolor("order".currentstatus),
    "order".scheduled
from "order"
inner join customer cus on cus.id = "order".customerid
where ("order".branchid = Any (_branchid) and "order".scheduled is not null
or ("order".reminder > ((now() AT TIME ZONE 'Asia/Amman'::text)::timestamp))
and ( "order".reminder < (now() AT TIME ZONE 'Asia/Amman'::text)::timestamp)) and (("order".reminder is null) or ( "order".reminder > (now() AT TIME ZONE 'Asia/Amman'::text)::timestamp)) and ( "order".scheduled > (now() AT TIME ZONE 'Asia/Amman'::text)::timestamp)
and "order".iscanceled = false
order by "order".scheduled asc;
END;
$$;


--
-- Name: getselectedproductattribute(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getselectedproductattribute(_id uuid DEFAULT NULL::uuid) RETURNS TABLE(attribute jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select productselectedattribute.attribute from productselectedattribute where product = _id and isdeleted = false ;
END;
$$;


--
-- Name: getservices(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getservices(_companyid uuid) RETURNS TABLE(type public.citext, name json)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY

select ourintegration.type,to_json(
    Array(
        select to_json(
            json_build_object(
                'name',oi.name,
                'image',oi.image,
                'isactive',coalesce(cai.isactive,false),
                'channelid', oi.referenceid
                )
            ) from ourintegration oi
              left join companyactiveintegrations cai
              on cai.companyid = _companyid and oi.referenceid = cai.channelid
              where oi.type = ourintegration.type
        )
    ) from ourintegration

      group by ourintegration.type;

END;
$$;


--
-- Name: getstandardbranch(uuid, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getstandardbranch(_branchid uuid, _latitude double precision, _longtitude double precision) RETURNS TABLE(branchname public.citext, branchphone public.citext, branchaddress public.citext, branchlatitude numeric, branchlongtitude numeric, branchdistance double precision, deliverytime integer, calculatorprice numeric, integrateddeliveries uuid[])
    LANGUAGE plpgsql
    AS $$
    BEGIN
    RETURN QUERY
    select
        que.name,
        que.phonenumber ,
        que.addressname ,
        que.latitude ,
        que.longtitude ,
        que.distance ,
        45 ,
       (select getbranchdeliverycalculatorprice(que.id ,(que.distance::numeric) ) limit 1),
       (select array_agg(deliverycompanyid)::uuid[] from branchdelivery where branchid = que.id and ((maxdistance::numeric) >= (que.distance::numeric)))
    from getbranchfordistancemainbybranch(_branchid,_latitude,_longtitude) que
    where (((select getbranchdeliverycalculatorprice(que.id, (que.distance::numeric))) is not null)
               or
           (select count(*) from branchdelivery bd where bd.branchid = que.id and que.distance <= (maxdistance::numeric)) > 0
           );
    END;

$$;


--
-- Name: getstandardbranch_ai(uuid, double precision, double precision); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getstandardbranch_ai(_branchid uuid, _latitude double precision, _longtitude double precision) RETURNS TABLE(branchname public.citext, branchphone public.citext, branchaddress public.citext, branchlatitude numeric, branchlongtitude numeric, branchdistance double precision, deliverytime integer, calculatorprice numeric, integrateddeliveries uuid[])
    LANGUAGE plpgsql
    AS $$
    BEGIN
    RETURN QUERY
    select
        que.name,
        que.phonenumber ,
        que.addressname ,
        que.latitude ,
        que.longtitude ,
        que.distance ,
        45 ,
       (select getbranchdeliverycalculatorprice_ai(que.id ,(que.distance::numeric) ) limit 1),
       (select array_agg(deliverycompanyid)::uuid[] from branchdelivery where branchid = que.id and ((maxdistance::numeric) >= (que.distance::numeric)))
    from getbranchfordistancemainbybranch_ai(_branchid,_latitude,_longtitude) que
    where (((select getbranchdeliverycalculatorprice_ai(que.id, (que.distance::numeric))) is not null)
               or
           (select count(*) from branchdelivery bd where bd.branchid = que.id and que.distance <= (maxdistance::numeric)) > 0
           );
    END;

$$;


--
-- Name: getstatuscolor(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getstatuscolor(_id uuid DEFAULT NULL::uuid) RETURNS SETOF public.citext
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select st.color from orderstatuspossibilities st where id = _id and isdeleted = false and ispublished = true;
END;
$$;


--
-- Name: getstatuslookup(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getstatuslookup(_companyid uuid) RETURNS TABLE(id bigint, name public.citext, rname public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select l.id,l.name,rl.rname from lookup l left join rlookup rl on (l.id = rl.sid  and  rl.rid =_companyid)
    order by l.id asc ;

END
$$;


--
-- Name: getsubattributevalues(uuid[], uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getsubattributevalues(_attributeid uuid[] DEFAULT NULL::uuid[], _menuid uuid DEFAULT NULL::uuid) RETURNS TABLE(id uuid, name jsonb, branches jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select pratt.id,pratt.name,
 (select to_json( array(select row_to_json(getbranchforcategorybymenuid(_id := _menuid,_callid := pratt.id)))))::jsonb 
 from productattribute pratt where pratt.attributeid = Any (_attributeid) and pratt.isdeleted = false and pratt.ispublished = true order by pratt.priority desc;
END;
$$;


--
-- Name: gettablecellproductbranchsales(uuid, uuid, timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.gettablecellproductbranchsales(_branchid uuid, _productid uuid, _fromtime timestamp without time zone DEFAULT NULL::timestamp without time zone, _totime timestamp without time zone DEFAULT NULL::timestamp without time zone) RETURNS TABLE(salesdata text)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select
    replace(replace(
    json_build_object(
        'count' , coalesce(sum(op.itemcount),0::numeric),
        'totalprice' , coalesce(sum((op.price->>'ProductTotal')::numeric),0::numeric))::text ,
        '{',''),'}','')
             from "order" o
             join orderproduct op on o.id = op.orderid
             where o.branchid = _branchid
             and op.productid = _productid
             and ((_fromtime is null) or (o.createdat >= _fromtime))
             and ((_totime is null) or (o.createdat < _totime));
 END;
$$;


--
-- Name: gettablecellproductbranchsalescounts(uuid, uuid, timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.gettablecellproductbranchsalescounts(_branchid uuid, _productid uuid, _fromtime timestamp without time zone DEFAULT NULL::timestamp without time zone, _totime timestamp without time zone DEFAULT NULL::timestamp without time zone) RETURNS TABLE(salesdata numeric)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select
    coalesce(sum(op.itemcount),0::numeric)
             from "order" o
             join orderproduct op on o.id = op.orderid
             where o.branchid = _branchid
             and op.productid = _productid
             and ((_fromtime is null) or (o.createdat >= _fromtime))
             and ((_totime is null) or (o.createdat < _totime));
 END;
$$;


--
-- Name: gettablecellproductbranchsalesvalues(uuid, uuid, timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.gettablecellproductbranchsalesvalues(_branchid uuid, _productid uuid, _fromtime timestamp without time zone DEFAULT NULL::timestamp without time zone, _totime timestamp without time zone DEFAULT NULL::timestamp without time zone) RETURNS TABLE(salesdata numeric)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select
         coalesce(sum((op.pricesubtotal)::numeric),0::numeric)
             from "order" o
             join orderproduct op on o.id = op.orderid
             where o.branchid = _branchid
             and op.productid = _productid
             and ((_fromtime is null) or (o.createdat >= _fromtime))
             and ((_totime is null) or (o.createdat < _totime));
 END;
$$;


--
-- Name: gettalabatbranchids(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.gettalabatbranchids(_companyid uuid DEFAULT NULL::uuid) RETURNS TABLE(ishbekbranchid uuid, talabatbrandid public.citext, talabatbranchid public.citext, name public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
return query
   select b.id as ishbekbranchid, tc.talabatbrandid, tc.talabatbranchid, b.name from branch b
   left join talabatcredential tc on b.id=tc.ishbekbranchid where b.companyid = _companyid and b.isdeleted=false;
END;
$$;


--
-- Name: gettalabatexistanceorder(public.citext, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.gettalabatexistanceorder(_referencenumber public.citext, _talabatordersource uuid) RETURNS SETOF uuid
    LANGUAGE plpgsql
    AS $$

BEGIN
RETURN QUERY
    select id from "order" where ordersource = _talabatordersource and referencenumber2 = _referencenumber;
END
$$;


--
-- Name: gettalabatid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.gettalabatid(_id uuid) RETURNS SETOF text
    LANGUAGE plpgsql
    AS $$
BEGIN
    return query
    select  referencenumber->>'deliveryPlatformID'
from "order" where id =_id;
end;
$$;


--
-- Name: gettalabatmenu(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.gettalabatmenu(_companyid uuid) RETURNS TABLE(categoryid uuid, categoryname jsonb, productid uuid, productname jsonb, branches jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select category.id categoryid, 
to_json(Array(select to_json(json_build_object('en' , getvalue('en','categoryName',category.id,1) ,'ar', getvalue('ar','categoryName',category.id,1)))))::jsonb categoryname
,product.id productid, product.name productname,
to_json(Array(select to_json(json_build_object('branch' , branch.name)) from branch
                                                  inner join menu on menu.id = branch.menuid
                                                  inner join menuproduct on (menu.id = menuproduct.menuid and menuproduct.productid = product.id) 
                                                  where category.companyid = _companyid)) :: jsonb branches
from category 
inner join product on product.categoryid = category.id
where product.isdeleted = false and category.companyid = _companyid and category.isdeleted =false;
END
$$;


--
-- Name: gettalabatmenurequestlogbycompanyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.gettalabatmenurequestlogbycompanyid(_companyid uuid) RETURNS TABLE(response public.citext, method public.citext, creationtime timestamp without time zone, brandid public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select ml.response, ml.method, ml.creationtime, ml.brandid from menurequestlog ml where ml.brandid = any(select talabatbrandid from talabatcredential where ishbekbranchid = any(select id from branch where companyid = _companyid)) order by creationtime desc  limit 10;END;
$$;


--
-- Name: gettalabatorderbodyrequest(public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.gettalabatorderbodyrequest(_deliveryplatformid public.citext) RETURNS TABLE(requestbody public.citext)
    LANGUAGE plpgsql
    AS $$

BEGIN
RETURN QUERY
    select rl.requestbody from requestlog rl where rl.deliveryplatformid = _deliveryplatformid;
END
$$;


--
-- Name: gettalabatorderid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.gettalabatorderid(_orderid uuid DEFAULT NULL::uuid) RETURNS TABLE(branchid uuid, referencenumber public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select ord.branchid, ord.referencenumber from "order" ord where ord.id = _orderid ;
END;
$$;


--
-- Name: gettalabatreferencenumber(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.gettalabatreferencenumber(_ishbekorderid uuid, _talabatordersource uuid) RETURNS TABLE(referencenumber2 public.citext)
    LANGUAGE plpgsql
    AS $$

BEGIN
RETURN QUERY
    select o.referencenumber2 from "order" o where o.id = _ishbekorderid and o.ordersource = _talabatordersource;
END
$$;


--
-- Name: tax; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.tax (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    name public.citext NOT NULL,
    countryid uuid,
    cityid uuid,
    taxcategoryid uuid NOT NULL,
    value numeric NOT NULL,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext
);


--
-- Name: gettaxbyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.gettaxbyid(_id uuid DEFAULT NULL::uuid) RETURNS SETOF public.tax
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select * from tax where id = _id and isdeleted = false and ispublished = true;
END;
$$;


--
-- Name: taxcategory; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.taxcategory (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    companyid uuid,
    name public.citext NOT NULL,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext
);


--
-- Name: gettaxcategorybyid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.gettaxcategorybyid(_id uuid DEFAULT NULL::uuid) RETURNS SETOF public.taxcategory
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select * from taxcategory where id = _id and isdeleted = false and ispublished = true;
END;
$$;


--
-- Name: gettaxes(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.gettaxes(pagenumber integer DEFAULT NULL::integer, pagesize integer DEFAULT NULL::integer) RETURNS SETOF public.tax
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select * from tax  where isdeleted = false and ispublished = true
LIMIT PageSize
OFFSET ((PageNumber-1) * PageSize);
END;
$$;


--
-- Name: gettaxescategories(integer, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.gettaxescategories(pagenumber integer DEFAULT NULL::integer, pagesize integer DEFAULT NULL::integer) RETURNS SETOF public.taxcategory
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select * from taxcategory  where isdeleted = false and ispublished = true
LIMIT PageSize
OFFSET ((PageNumber-1) * PageSize);
END;
$$;


--
-- Name: gettopsellingitem_ai(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.gettopsellingitem_ai(_companyid uuid) RETURNS SETOF public.product
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN QUERY
    select p.* from product p WHERE p.id = any(select mp.productid from menuproduct mp INNER JOIN menu m ON m.id = mp.menuid WHERE m.companyid =_companyid and m.isdeleted = false and m.ispublished = true )
    and p.isdeleted = false and p.isavailable = true and p.istopselling = true order by p.createdat desc ;
END;
$$;


--
-- Name: gettopsellingitemsreport(uuid[], uuid[], timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.gettopsellingitemsreport(_branchids uuid[], _channels uuid[] DEFAULT NULL::uuid[], _from timestamp without time zone DEFAULT NULL::timestamp without time zone, _to timestamp without time zone DEFAULT NULL::timestamp without time zone) RETURNS TABLE(data json)
    LANGUAGE plpgsql
    AS $$
BEGIN
return query 
select to_json(Array(select to_json(json_build_object('Count',sum(itemcount) , 'ItemId',product.id , 'Item',product.name ,
 'Price',sum(orderproduct.pricetaxvalue*orderproduct.itemcount)
 ))from orderproduct 
 inner join "order" on "order".id = orderproduct.orderid 
 inner join product on orderproduct.productid = product.id
 where  branchid  =any(_branchids) 
  and ((_channels is null) or ("order".ordersource=any(_channels)))
  and ((_from is null) or ("order".createdat >=  to_char(_from,'YYYY-MM-DD 00:00:00')::timestamp))
  and ((_to is null) or ("order".createdat <= to_char(_to,'YYYY-MM-DD 23:59:59')::timestamp))
  and "order".isdeclined = false and "order".iscanceled = false
 group by(productid,product.id) order by (count(itemcount)) desc));
END
$$;


--
-- Name: getunavailableproductofcategory(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getunavailableproductofcategory(_companyid uuid DEFAULT NULL::uuid) RETURNS SETOF public.product
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select id, categoryid, concat(getimagepath(imagepath),imagepath)::citext, isdeleted, ispublished, createdat, createdby, updatedat, updatedby, deletedat, deletedby, price, description, name, shortdescription, sku, fulldescription, isavailable, hour, min, displaynumber, isoffer, producttags, istopselling, branchprice,product.aliasname,product.aliasdescription
from product where product.categoryid
IN(select category.id from category where category.companyid = _companyid )
and product.isdeleted = false;
END;
$$;


--
-- Name: getuserauth(public.citext, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getuserauth(_username public.citext, _password public.citext) RETURNS TABLE(id uuid, name public.citext, companyid uuid)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY

select uauth.id,uauth.username,uauth.companyid from userauth uauth where uauth.username = _username and uauth.passowrd = md5(_password);
END;
$$;


--
-- Name: getvalue(public.citext, public.citext, uuid, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getvalue(_languagecode public.citext, _key public.citext, _objectid uuid, _type integer) RETURNS TABLE(result public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select value as "Value" from languageresource lr
  where lr.key = _key and lr.objectid=_objectid and lr.languagecode=_languagecode  and lr.type = _type
  and lr.ispublished=true and lr.isdeleted=false;
END;
$$;


--
-- Name: getvaluelocalization(public.citext, public.citext, uuid, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getvaluelocalization(_languagecode public.citext, _key public.citext, _objectid uuid, _type integer) RETURNS TABLE(result public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 
SELECT (CASE
    WHEN COUNT(lr.value) = 0 THEN null
    ELSE (SELECT lr.value from languageresource lr
  where lr.key = _key and (lr.objectid=_objectid) and lr.languagecode=_languagecode  and lr.type = _type
  and lr.ispublished=true and lr.isdeleted=false)
  END) as value from languageresource lr
  where lr.key = _key and (lr.objectid=_objectid) and lr.languagecode=_languagecode  and lr.type = _type
  and lr.ispublished=true and lr.isdeleted=false ;

END;
$$;


--
-- Name: getwaapiclientinstances(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.getwaapiclientinstances(_companyid uuid) RETURNS TABLE(id uuid, companyid uuid, instanceid integer, owner public.citext, name public.citext, webhooks public.citext[], phonenumber public.citext, createdat timestamp without time zone)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select wc.id,
           wc.companyid as "companyId",
           wc.instanceid as "instanceId",
           wc.owner,
           wc.name,
           wc.webhooks as "webHooks",
           wc.phonenumber as "phoneNumber",
           wc.createdat as "createdAt"
    from waapiclients wc
    where wc.companyid = _companyid;
END;
$$;


--
-- Name: handlepreferedsubarea(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.handlepreferedsubarea(IN _deliveryaddressid uuid, IN _preferedsubarea public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
    update addresses set preferedsubarea = _preferedsubarea where id = _deliveryaddressid;
END;
$$;


--
-- Name: insertashyaeemappedentities(uuid, integer); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.insertashyaeemappedentities(IN _ishbekid uuid, IN _ashyaeeid integer)
    LANGUAGE plpgsql
    AS $$
BEGIN

    INSERT INTO ashyaeemappedentities(ishbekid, ashyaeeid)
    VALUES (_ishbekid, _ashyaeeid)
    ON CONFLICT DO NOTHING;
END;
$$;


--
-- Name: insertbranchdeliverycalculator(uuid, numeric, numeric, numeric, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.insertbranchdeliverycalculator(IN _branchid uuid, IN _startperiod numeric, IN _endperiod numeric, IN _price numeric, IN _createdby public.citext)
    LANGUAGE plpgsql
    AS $$
begin
INSERT INTO public.branchcalculator(branchid,startperiod,endperiod,price,createdby)
	VALUES(_branchid,_startperiod,_endperiod,_price,_createdby);
end;
$$;


--
-- Name: insertbranchdeliverycharge(uuid, uuid, public.citext, public.citext, public.citext, numeric, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.insertbranchdeliverycharge(IN _id uuid, IN _branchid uuid, IN _city public.citext, IN _area public.citext, IN _subarea public.citext, IN _fees numeric, IN _createdby public.citext)
    LANGUAGE plpgsql
    AS $$
begin
if _id is not null then
  if _branchid is not null then update branchdeliverycharge set branchid = _branchid  where id = _id ; end if;
  if _city is not null then update branchdeliverycharge set city = _city  where id = _id ; end if;
  if _area is not null then update branchdeliverycharge set area = _area  where id = _id ; end if;
  if _subarea is not null then update branchdeliverycharge set subarea = _subarea  where id = _id ; end if;
  if _fees is not null then update branchdeliverycharge set fees = _fees  where id = _id ; end if;  
else
 INSERT INTO public.branchdeliverycharge(branchid,city,area,subarea,fees,createdby,companyid)
	VALUES(_branchid,_city,_area,_subarea,_fees,_createdby,(select companyid from branch where id = _branchid));
end if;
end;
$$;


--
-- Name: insertcheckorderprint(uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.insertcheckorderprint(IN _id uuid)
    LANGUAGE plpgsql
    AS $$
begin 
--USE
DELETE FROM printingorderlogs WHERE createdat < (now() AT TIME ZONE 'Asia/Amman'::text) - INTERVAL '96 HOURS';
INSERT INTO printingorderlogs(orderid) VALUES (_id);
END;
$$;


--
-- Name: insertcustomerdetails(uuid, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.insertcustomerdetails(IN _customerid uuid, IN _name public.citext, IN _phoneno public.citext)
    LANGUAGE plpgsql
    AS $$
declare
begin
    if((select count(customerid) from customerdetail where customerid = _customerid)=0 ) then
        insert into customerdetail (customerid, name, phonenumber) values (_customerid,_name,_phoneno);
    else
        null;
    end if;

end;
$$;


--
-- Name: insertdeliveryorderrequest(uuid, uuid, public.citext, public.citext, public.citext, jsonb, jsonb, timestamp without time zone); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.insertdeliveryorderrequest(IN _orderid uuid, IN _deliverycompanyid uuid, IN _name public.citext, IN _baseurl public.citext, IN _apiurl public.citext, IN _body jsonb, IN _response jsonb, IN _executiontime timestamp without time zone)
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO scheduledeliveryorderrequest (orderid,deliverycompanyid,name,baseurl,apiurl,body,reponse,executiontime)
    VALUES (_orderid,_deliverycompanyid,_name,_baseurl,_apiurl,_body,_response,_executiontime);
END;
$$;


--
-- Name: insertintomenuqrcode(uuid, uuid, uuid, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.insertintomenuqrcode(IN _menuid uuid, IN _channelid uuid, IN _branchid uuid, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
begin



  INSERT INTO menuqrcode(menuid, channelid, branchid)
    VALUES (_menuid, _channelid, _branchid)
    ON CONFLICT (channelid, branchid) DO NOTHING  RETURNING id INTO _id;
    if not FOUND then
        _id = '00000000-0000-0000-0000-000000000000'::uuid;
    end if;


END;
$$;


--
-- Name: insertishbekmapzones(public.citext, integer, public.citext, integer, jsonb, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.insertishbekmapzones(IN _cityname public.citext, IN _cityid integer, IN _areaname public.citext, IN _areaid integer, IN _coordinates jsonb, IN _createdby public.citext DEFAULT 'system'::public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN

    INSERT INTO ishbekmapzones (cityname, cityid,areaname, areaid, coordinates, createdby)
    VALUES (_cityname, _cityid, _areaname, _areaid ,_coordinates ,_createdby );
END;
$$;


--
-- Name: insertlogstatus(uuid, integer, integer, uuid, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.insertlogstatus(IN _crid uuid, IN _status integer, IN _previousstatus integer, IN _customerid uuid, IN _restaurantid uuid)
    LANGUAGE plpgsql
    AS $$
declare
begin
    insert into statuslog(crid, status, previousstatus, customerid, restaurantid)
    values
    (
        _crid,
        _status,
        _previousstatus,
        _customerid,
        _restaurantid
    );
end;
$$;


--
-- Name: insertpaymentonoholdorders(public.citext, public.citext, public.citext, jsonb, uuid, uuid, uuid, numeric, public.citext, numeric, jsonb, timestamp without time zone, public.citext, numeric, uuid, uuid, jsonb, public.citext, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.insertpaymentonoholdorders(IN _sessionid public.citext, IN _result public.citext, IN _response public.citext, IN _order jsonb, IN _customerid uuid, IN _branchid uuid, IN _ordersource uuid, IN _totalprice numeric, IN _paymenttype public.citext, IN _subtotalprice numeric, IN _price jsonb DEFAULT NULL::jsonb, IN _scheduled timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _notes public.citext DEFAULT NULL::public.citext, IN _deliveryprice numeric DEFAULT NULL::numeric, IN _deliveryaddress uuid DEFAULT NULL::uuid, IN _deliverytype uuid DEFAULT NULL::uuid, IN _referencenumber jsonb DEFAULT '{}'::json, IN _referencenumber2 public.citext DEFAULT NULL::public.citext, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$

begin
insert into paymentonholdorders
     (sessionid, resultind, response, orderdetails,branchorderid,
      ordersource,
      scheduled,
      deliverytype,
      customerid,
      branchid,
      notes,
      totalprice,
      price,
      deliveryprice,
      deliveryaddress,
      subtotalprice,
      paymenttype,
      currentstatus,
      referencenumber,
      referencenumber2)
values (_sessionid,_result,_response,_order,getorderseq(_branchid),
                     _ordersource,
                     _scheduled,
                     _deliverytype,
                     _customerid,
                     _branchid,
                     _notes,
                     _totalprice,
                     _price,
                     _deliveryprice,
                     _deliveryaddress,
                     _subtotalprice,
                     _paymenttype,
                     --(select getfirststatusforbranch(_branchid)), --old
                      (select osp1.id from orderstatuspossibilities1 osp1 where osp1.isfirststatus = true),
                     _referencenumber,
                     _referencenumber2)
                     returning orderpaymentid into _id;
end;
$$;


--
-- Name: insertpointlog(uuid, double precision, uuid, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.insertpointlog(IN _crid uuid, IN _amount double precision, IN _channelid uuid, IN _orderid uuid)
    LANGUAGE plpgsql
    AS $$
declare
    _cr restaurantcustomer = (select rc from restaurantcustomer rc where id = _crid);
begin

    insert into pointlog (crid , amount, customerid, restaurantid, channelid, orderid)
    values               (_crid, _amount,_cr.customerid, _cr.restaurantid, _channelid, _orderid);
end;
$$;


--
-- Name: insertqrintomenuqrcode(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.insertqrintomenuqrcode(IN _id uuid, IN _qrcode public.citext)
    LANGUAGE plpgsql
    AS $$
begin

 update public.menuqrcode set qrcode = _qrcode where menuqrcode.id = _id;

END;
$$;


--
-- Name: insertrlookup(uuid, bigint, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.insertrlookup(IN _rid uuid, IN _sid bigint, IN _rname public.citext)
    LANGUAGE plpgsql
    AS $$
begin
    insert into rlookup (rid,sid,rname) values (_rid,_sid,_rname);
end;
$$;


--
-- Name: integrationactive(uuid, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.integrationactive(_companyid uuid, _channelid uuid) RETURNS TABLE(status public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select c.status from companyactiveintegrations c where companyid=_companyid and channelid=_channelid;
END
$$;


--
-- Name: integrationcomapnystatus(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.integrationcomapnystatus(_id uuid DEFAULT NULL::uuid) RETURNS TABLE(status public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select ca.status from companyactiveintegrations ca where companyid = _id and channelid=(select id from namelookup where tabletype='ordersource' and name='talabat');
END;
$$;


--
-- Name: integrationcomapnystatuscareem(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.integrationcomapnystatuscareem(_id uuid DEFAULT NULL::uuid) RETURNS TABLE(status public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select ca.status from companyactiveintegrations ca where companyid = _id and channelid=(select id from namelookup where tabletype='ordersource' and name='careem');
END;
$$;


--
-- Name: isattributeashyaeelevel3(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.isattributeashyaeelevel3(_attributeid uuid) RETURNS SETOF boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select(case when(p.attributeid is null) then false else true end) from productattribute p where p.id = (select attributeid from productattribute c where c.id = _attributeid);
END;
$$;


--
-- Name: jsonbupdateproperties(jsonb, text, anyelement); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.jsonbupdateproperties(json jsonb, key_to_set text, value_to_set anyelement) RETURNS jsonb
    LANGUAGE sql IMMUTABLE STRICT
    AS $$
SELECT concat('{', string_agg(to_jsonb("key") || ':' || "value", ','), '}')::jsonb
  FROM (SELECT *
          FROM jsonb_each("json")
         WHERE "key" <> "key_to_set"
         UNION ALL
        SELECT "key_to_set", to_jsonb("value_to_set")) AS "fields"
$$;


--
-- Name: jsonsetpropertiesany(json, character varying, anyelement); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.jsonsetpropertiesany(json json, key_to_set character varying, value_to_set anyelement) RETURNS json
    LANGUAGE sql IMMUTABLE STRICT
    AS $$
SELECT concat('{', string_agg(to_json("key") || ':' || "value", ','), '}')::json
  FROM (SELECT *
          FROM json_each("json")
         WHERE "key" <> "key_to_set"
         UNION ALL
        SELECT "key_to_set", to_json("value_to_set")) AS "fields"
$$;


--
-- Name: jsonsetpropertiesnumeric(json, character varying, numeric); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.jsonsetpropertiesnumeric(json json, key_to_set character varying, value_to_set numeric) RETURNS json
    LANGUAGE sql IMMUTABLE STRICT
    AS $$
SELECT concat('{', string_agg(to_json("key") || ':' || "value", ','), '}')::json
  FROM (SELECT *
          FROM json_each("json")
         WHERE "key" <> "key_to_set"
         UNION ALL
        SELECT "key_to_set", to_json("value_to_set")) AS "fields"
$$;


--
-- Name: jsonupdateproperties(json, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.jsonupdateproperties(json json, key_to_set character varying, value_to_set character varying) RETURNS json
    LANGUAGE sql IMMUTABLE STRICT
    AS $$
SELECT concat('{', string_agg(to_json("key") || ':' || "value", ','), '}')::json
  FROM (SELECT *
          FROM json_each("json")
         WHERE "key" <> "key_to_set"
         UNION ALL
        SELECT "key_to_set", to_json("value_to_set")) AS "fields"
$$;


--
-- Name: jsonupdateproperties(jsonb, text, anyelement); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.jsonupdateproperties(json jsonb, key_to_set text, value_to_set anyelement) RETURNS json
    LANGUAGE sql IMMUTABLE STRICT
    AS $$
SELECT concat('{', string_agg(to_json("key") || ':' || "value", ','), '}')::json
  FROM (SELECT *
          FROM json_each("json")
         WHERE "key" <> "key_to_set"
         UNION ALL
        SELECT "key_to_set", to_json("value_to_set")) AS "fields"
$$;


--
-- Name: log_notice(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.log_notice(text) RETURNS void
    LANGUAGE plpgsql
    AS $_$
BEGIN
  RAISE NOTICE '%', $1;
END;
$_$;


--
-- Name: markorderasready(uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.markorderasready(IN _orderid uuid)
    LANGUAGE plpgsql
    AS $$
begin
    update "order" set isready = true where id = _orderid;
end;
$$;


--
-- Name: modifycustomeraddress(uuid, integer, bigint, public.citext, public.citext, double precision, double precision, public.citext, public.citext, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.modifycustomeraddress(IN _addressid uuid, IN _ishbekcityid integer, IN _ishbekareaid bigint, IN _preferedsubarea public.citext, IN _name public.citext, IN _lat double precision, IN _lng double precision, IN _street public.citext, IN _buildingnumber public.citext, IN _otherdetails public.citext, IN _notes public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
    UPDATE addresses
    SET

        ishbekcityid = _ishbekcityid,
        ishbekareaid = _ishbekareaid,
        preferedsubarea = _preferedsubarea,
        name = _name,
        lat = _lat,
        lng = _lng,
        street = _street,
        buildingnumber = _buildingnumber,
        otherdetails = _otherdetails,
        notes = _notes
    WHERE id = _addressid;
END;
$$;


--
-- Name: moveordertocurrent(uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.moveordertocurrent(IN _orderid uuid)
    LANGUAGE plpgsql
    AS $$
begin 
update "order" SET scheduled = null where id = _orderid;
end;
$$;


--
-- Name: perfectemployeereport(uuid[], timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.perfectemployeereport(_branchids uuid[], _fromtime timestamp without time zone DEFAULT NULL::timestamp without time zone, _totime timestamp without time zone DEFAULT NULL::timestamp without time zone) RETURNS TABLE(operatorname public.citext, sales numeric, ordersn bigint)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
    select oh.createdby as operatorname,
       (select sum((o.price->>'Total')::numeric)) as sales,
       (select count(o.id)) as ordersn
from orderhistory oh
inner join "order" o on o.id = oh.id
inner join branch b on o.branchid = b.id
and  ((_fromtime is null) or( _fromtime <= o.createdat))
and ((_totime is null) or( _totime >= o.createdat))
and o.branchid = any(_branchids)
group by oh.createdby;
END;
$$;


--
-- Name: posorderdata(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.posorderdata(_orderid uuid) RETURNS TABLE(id uuid, companyid uuid, branchorderid public.citext, price jsonb, products json, currentstatus public.citext, ordersource uuid, ordersourcename public.citext, deliveryname public.citext, deliverycompanyid uuid, orderprice jsonb, customerid uuid, scheduled timestamp without time zone, deliverytype uuid, branchid uuid, notes public.citext, numberofpeople public.citext, totalprice numeric, deliveryprice numeric, deliveryaddress uuid, subtotalprice numeric, referencenumber jsonb, totalpreparingtime public.citext, deliverystatus public.citext, paymenttype public.citext, createdat timestamp without time zone, createdby public.citext, branchname public.citext, customername public.citext, customerphoneno public.citext, customerfullphoneno public.citext, countrycode public.citext, address json)
    LANGUAGE plpgsql
    AS $$

BEGIN
RETURN QUERY

select
    ord.id,(select b.companyid from branch b where b.id = ord.branchid ), ord.branchorderid, ord.price, to_json(Array(select to_json( json_build_object(
                        'id',ordpr.id,
                        'orderid', ordpr.orderid,
                        'productid', ordpr.productid,
                        'productname', prd.name,
                        'img', prd.imagepath,
						'count', ordpr.itemcount,
						'createdat', prd.createdat,
						'createdby', prd.createdby,
                        'price', ordpr.price,
                        'attributes',
                        to_json(
                            Array(
                                select
                                    to_json(
                                        json_build_object(
                                            'id', ordpratt.id,
                                            'orderproductid', ordpratt.orderproductid,
                                            'attributeid', ordpratt.attributeid,
                                            'attributename', prdatt.name,
                                            'pricesubtotal', ordpratt.pricesubtotal,
                                            'pricetaxvalue', ordpratt.pricetaxvalue,
                                            'pricetaxpercentage', ordpratt.pricetaxpercentage,
											'values',(ordpratt.children)::json,
                                            'notes', ordpratt.notes,
											'createdat', ordpratt.createdat,
											'createdby', ordpratt.createdby
                                        )
                                    )
                                from
                                    orderproductattribute ordpratt
                                    left join productattribute prdatt on ordpratt.attributeid = prdatt.id
								where ordpratt.orderproductid = ordpr.id
                            )
                        ),
                        'pricesubtotal', ordpr.pricesubtotal,
                        'pricetaxvalue', ordpr.pricetaxvalue,
                        'pricetaxpercentage', ordpr.pricetaxpercentage,
                        'notes', ordpr.notes
                    )
                )
            from
                orderproduct ordpr
                inner join product prd on ordpr.productid = prd.id
			where ordpr.orderid = ord.id
        )
    ) products,
    getorderstatus(ord.currentstatus), --1
    ord.ordersource, --2
	getlookupname(ord.ordersource), --3 ordersourcename
	case when (ord.deliverytype = 'ebf23c72-7003-4804-b981-727ef616e1d5') --4 deliveryname
	    then (select getlocaldeliveryname(ord.branchid))
	    else (Select getdeliverycompanyname(ord.deliverytype))
        end,
    getdeliverycompanyid(ord.deliverytype),
    ord.price,
    ord.customerid,
	ord.scheduled,
    ord.deliverytype,
    ord.branchid,
    ord.notes,
	ord.numberofpeople,
    ord.totalprice,
    ord.deliveryprice,
    ord.deliveryaddress,
    ord.subtotalprice,
    ord.referencenumber,
    ord.totalpreparingtime,
    ord.deliverystatus,
    ord.paymenttype,
    ord.createdat,
    ord.createdby,
	getbranchname(ord.branchid),
    c.name,
    c.phoneno,
    c.fullphonenumber,
    c.countrycode,

	json_build_object('en',(select to_json(json_build_object( 'id', addr.id, 'name',name, 'subareaid', subareaname, 'latitude',latitude, 'longtitude', longtitude, 'buildingno', buildingno, 'streetno',streetno ))
                                            from address addr where addr.id = ord.deliveryaddress and isdeleted = false and ispublished = true ),
	                  'ar',(select to_json(json_build_object('id', addr.id, 'name',name , 'subareaid', subareaname, 'latitude',latitude, 'longtitude', longtitude, 'phoneno',phoneno , 'buildingno', buildingno, 'streetno',streetno))
                                        from address addr where addr.id = ord.deliveryaddress and isdeleted = false and ispublished = true
))
from
    "order" ord
    inner join customer c on ord.customerid = c.id
where
    ord.id = _orderid;
END;
$$;


--
-- Name: printingorder(uuid, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.printingorder(IN _orderid uuid, IN _branchid uuid)
    LANGUAGE plpgsql
    AS $$
begin
--use
DELETE FROM manualprintingorder where branchid = _branchid;
INSERT INTO manualprintingorder (id,branchid, orderid)
    VALUES(_orderid,_branchid,_orderid);

END;
$$;


--
-- Name: promote(uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.promote(IN _crid uuid)
    LANGUAGE plpgsql
    AS $$
declare
    currst integer= (select currentstatus from restaurantcustomer where id = _crid);
    custid uuid=(select customerid from restaurantcustomer where id = _crid);
    resid uuid=(select restaurantid from restaurantcustomer where id = _crid);
    period interval = (select (resp.period||'day')::interval from restaurantparams resp where resp.restaurantid = resid)::interval;
    loyalityperiod interval = (select (resp.loyalityperiod||'day')::interval from restaurantparams resp where resp.restaurantid = resid)::interval;
    loyalitycount integer = (select resp.loyalitycount from restaurantparams resp where resp.restaurantid = resid);
    loyalityamount numeric = (select resp.loyalityamount from restaurantparams resp where resp.restaurantid = resid);
    lpd timestamp without time zone = (select lastpointdate from restaurantcustomer where id = _crid); --lastpointdate


begin
    case when currst = 1 or currst = 2 or currst = 4 then
        update restaurantcustomer set currentstatus = currst + 1 where id = _crid;
        call insertlogstatus(
                             _crid,
                             currst + 1,
                             currst ,
                             custid,
                             resid
                            );

    when currst = 5 then
        update restaurantcustomer set currentstatus = 3 where id = _crid;
                   call insertlogstatus(
                             _crid,
                             3,
                             currst ,
                             custid,
                             resid
                            );
    when (loyalityperiod is not null  and loyalitycount is not null and loyalityamount is not null )  then
            if ((  ( select count(*) from pointlog where createdat >= ((now() - period) ::date) and crid = _crid) >= coalesce(loyalitycount,1) ) and
                (  ( select sum(amount) from pointlog where createdat >= ((now() - period) ::date) and crid = _crid) >= coalesce(loyalityamount,0) ) and
                ((now()::date) <= ((lpd::timestamp without time zone) + coalesce(loyalityperiod,period))::date))
                then
                     update restaurantcustomer set currentstatus = 6 where id = _crid;
                     call insertlogstatus(
                             _crid,
                             6,
                             currst ,
                             custid,
                             resid
                            );
            end if;

    else null;
    end case;
end;
$$;


--
-- Name: registercompany(public.citext, public.citext, public.citext, public.citext, character varying, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.registercompany(IN _name public.citext, IN _phone public.citext, IN _email public.citext, IN _address public.citext, IN _logo character varying, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
begin 
INSERT INTO company(name,logo,createdby)
	VALUES(_name,_logo,_createdby)
	RETURNING id INTO _id;
--phonenumber
call createbasiccompanyinfo(_id,'phone',_phone,_createdby);
--email
call createbasiccompanyinfo(_id,'email',_email,_createdby);
--address
call createbasiccompanyinfo(_id,'address',_address,_createdby);
--companychannels
call createcompanychannels(_id,_createdby);
END;
--calling languages is outside this shit
$$;


--
-- Name: registercompanylanguage(uuid, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.registercompanylanguage(IN _companyid uuid, IN _languagename public.citext, IN _createdby public.citext)
    LANGUAGE plpgsql
    AS $$
DECLARE companyid uuid;
begin 
call createbasiccompanyinfo(_companyid,'language',_languagename,_createdby);
END;
$$;


--
-- Name: removecustomeraddress(uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.removecustomeraddress(IN _addressid uuid)
    LANGUAGE plpgsql
    AS $$
begin
    update addresses  set isdeleted = true where id = _addressid;
end;
$$;


--
-- Name: removequotation(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.removequotation() RETURNS TABLE(children jsonb)
    LANGUAGE plpgsql
    AS $$
begin
-- missing source code
end;
$$;


--
-- Name: removequotation(jsonb, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.removequotation(_children jsonb, _orderproductid uuid) RETURNS TABLE(children jsonb)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
select  replace((orp.children)::text,'\"','')::jsonb from orderproductattribute orp where orderproductid = _orderproductid;
END;
$$;


--
-- Name: resourceexist(public.citext, uuid, public.citext, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.resourceexist(_languagecode public.citext, _objectid uuid, _key public.citext, _type integer) RETURNS TABLE(resourceid uuid)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY 
select id from languageresource where languagecode=_languagecode and objectid = _objectid and key =_key and type=_type and ispublished = true and isdeleted = false;
END;
$$;


--
-- Name: searchaddressbyaddressid(uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.searchaddressbyaddressid(addressid uuid) RETURNS TABLE(name public.citext)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY

select distinct  concat(city.value,' - ',area.value,' - ',subarea.value)::citext as name from address 
left join languageresourcee city on address.cityname = city.objectid
left join languageresourcee area on address.areaname = area.objectid
left join languageresourcee subarea on address.subareaname = subarea.objectid
where 
 address.id = addressid and city.value is not null and area.value is not null and subarea.value is not null;
END;
$$;


--
-- Name: setattributeavailable(uuid, uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.setattributeavailable(IN _id uuid, IN _branchid uuid, IN _updatedby public.citext)
    LANGUAGE plpgsql
    AS $$
begin
delete from branchavailability where objectid = _id and branchid = _branchid ;end;
$$;


--
-- Name: setattributeunavailable(uuid, uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.setattributeunavailable(IN _id uuid, IN _branchid uuid, IN _createdby public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
insert into branchavailability(objectid,objecttype,branchid,createdby) 
values(_id,'attribute',_branchid,_createdby);
End;
$$;


--
-- Name: setcategoryavailable(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.setcategoryavailable(IN _id uuid, IN _updatedby public.citext)
    LANGUAGE plpgsql
    AS $$
begin update product set isavailable = true , updatedby = _updatedby,updatedat = now() where categoryid = _id;end;
$$;


--
-- Name: setcategoryunavailable(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.setcategoryunavailable(IN _id uuid, IN _updatedby public.citext)
    LANGUAGE plpgsql
    AS $$
begin update product set isavailable = false, updatedby = _updatedby where categoryid = _id;end;
$$;


--
-- Name: setentitiesimagetonull(uuid[], public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.setentitiesimagetonull(IN _entityids uuid[], IN _entityname public.citext)
    LANGUAGE plpgsql
    AS $$
begin
    if _entityname = 'category' then
        update category set image = null where category.id = any (_entityids);
    elseif _entityname = 'product' then
        update product set imagepath = null where product.id = any (_entityids);
    end if;

END;
$$;


--
-- Name: setentitiesimagetonull(uuid[], public.citext, uuid[]); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.setentitiesimagetonull(IN _entityids uuid[], IN _entityname public.citext, INOUT returnuuid uuid[])
    LANGUAGE plpgsql
    AS $$
begin
    if _entityname = 'category' then
        update category set image = null where category.id = any(_entityids) returning category.id into returnuuid;
    elseif _entityname = 'product' then
        update product set imagepath = null where product.id = any(_entityids) returning product.id into returnuuid;
    end if;
END;
$$;


--
-- Name: setordernextstatus(uuid, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.setordernextstatus(IN _orderid uuid DEFAULT NULL::uuid, IN _updatedby public.citext DEFAULT 'System'::public.citext, INOUT _status public.citext DEFAULT NULL::public.citext)
    LANGUAGE plpgsql
    AS $$
declare currentstatus uuid;
declare islast boolean;
declare isfirst boolean;
declare newcurrentstatus uuid;
declare orderstatus citext;

begin 
 	currentstatus = (select "order".currentstatus from "order" where id = _orderid);
	islast = (select islaststatus from orderstatuspossibilities1 where id = currentstatus);
	isfirst = (select isfirststatus from orderstatuspossibilities1 where id = currentstatus);
	if (islast = true) then _status =( select  getorderstatus(currentstatus)) ;
	else
	newcurrentstatus = (select  getnextstatus( currentstatus));
	update "order" 
	set currentstatus = newcurrentstatus
	where "order".id = _orderid;
	_status= (select  getorderstatus(newcurrentstatus)); 
	end if;
	orderstatus = (select getorderstatus(newcurrentstatus));
-- 	if (isfirst = true)
-- 	    then call createorderhistory(_orderid,'Created','',_updatedby);
-- 	else
	    call createorderhistory(_orderid,orderstatus,'',_updatedby);
-- 	end if;
END;
$$;


--
-- Name: setproductavailable(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.setproductavailable(IN _id uuid, IN _updatedby public.citext)
    LANGUAGE plpgsql
    AS $$
begin update product set isavailable = true, updatedby = _updatedby , updatedat = now() where id = _id;end;
$$;


--
-- Name: setproductunavailable(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.setproductunavailable(IN _id uuid, IN _updatedby public.citext)
    LANGUAGE plpgsql
    AS $$
begin update product set isavailable = false, updatedby = _updatedby,updatedat = now() where id = _id;end;
$$;


--
-- Name: settopreparingstatus(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.settopreparingstatus(IN _orderid uuid DEFAULT NULL::uuid, IN _updatedby public.citext DEFAULT 'System'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin
    update "order" o
    set currentstatus = '8e553803-89a4-4dc0-9023-13ae7aeffb43', -- preparing
        updatedby = _updatedby
    where o.id = _orderid;
END;
$$;


--
-- Name: testdeleteduplicates(public.citext[]); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.testdeleteduplicates(IN _customerphones public.citext[])
    LANGUAGE plpgsql
    AS $$
    declare
        customerNEWID uuid;
        customerDupIDS uuid[];
        _customerphone citext;
begin
        foreach _customerphone in array _customerphones loop
           customerNEWID =(select id  from customer where phoneno = _customerPhone order by (select count(*) from "order" where "order".customerid = customer.id) desc limit 1);
           customerDupIDS= (select array_agg(id) from customer where phoneno = _customerPhone and id != (select id  from customer where phoneno = _customerPhone order by (select count(*) from "order" where "order".customerid = customer.id) desc limit 1));
           update customeraddress set customerid = customerNEWID where customerid =any(customerDupIDS);
           update "order" set customerid = customerNEWID where customerid =any(customerDupIDS);
           delete from customer where id =any(customerDupIDS);
           end loop;

END;
$$;


--
-- Name: toggleisavailablediscount(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.toggleisavailablediscount(IN _discountid uuid, IN _updatedby public.citext)
    LANGUAGE plpgsql
    AS $$
begin
if((select isavailable from discountinfo where id = _discountid) = true) then
    update discountinfo set isavailable = false,updatedby=_updatedby,updatedat=now() where id = _discountid;
    else
    update discountinfo set isavailable = true,updatedby=_updatedby,updatedat=now() where id = _discountid;
end if;

end
$$;


--
-- Name: trackingorder_ai(public.citext, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.trackingorder_ai(_clientphone public.citext DEFAULT NULL::public.citext, _customerphone public.citext DEFAULT NULL::public.citext) RETURNS TABLE(tracklink public.citext, currentstatus public.citext, deliverystatus public.citext, domainurl public.citext)
    LANGUAGE plpgsql
    AS $$
-- get customerid
Declare cid uuid = (select id from customer where phoneno like concat('%',_customerphone,'%')  limit  1);
_companyid uuid = (select * from getcompanybyphone_ai(_clientphone));
BEGIN
--check if customer has orders
if ((select count(*) from getordersbeforethreehours_ai(cid,_companyid)) > 0) then
return query 
-- get customer orders before 3 hours
select *, null::citext from getordersbeforethreehours_ai(cid,_companyid);
else return query 
select null::citext,null::citext,null::citext, restaurantdomain from orderconfig where companyid = _companyid;
end if;
END;
$$;


--
-- Name: updateattribute(uuid, uuid, jsonb, jsonb, boolean, boolean, boolean, uuid, public.citext, integer, boolean, boolean, public.citext, jsonb, uuid, public.citext, integer, integer, integer); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updateattribute(IN _id uuid, IN _productid uuid DEFAULT NULL::uuid, IN _name jsonb DEFAULT NULL::jsonb, IN _description jsonb DEFAULT NULL::jsonb, IN _isrequired boolean DEFAULT NULL::boolean, IN _isalergy boolean DEFAULT NULL::boolean, IN _isavailable boolean DEFAULT NULL::boolean, IN _attributeid uuid DEFAULT NULL::uuid, IN _controltype public.citext DEFAULT NULL::public.citext, IN _priority integer DEFAULT NULL::integer, IN _ispreselected boolean DEFAULT NULL::boolean, IN _isglobal boolean DEFAULT NULL::boolean, IN _weight public.citext DEFAULT NULL::public.citext, IN _price jsonb DEFAULT NULL::jsonb, IN _companyid uuid DEFAULT NULL::uuid, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext, IN _noofselection integer DEFAULT NULL::integer, IN _minimumcount integer DEFAULT NULL::integer, IN _maximumcount integer DEFAULT NULL::integer)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select ispublished from productattribute where id = _id) = true) and ((select isdeleted from productattribute where id = _id) = false)) then 
if _productid is not null then update productattribute SET productid = _productid , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _name is not null then update productattribute SET name = _name , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _description is not null then update productattribute SET description = _description , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _isrequired is not null then update productattribute SET isrequired = _isrequired , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _isalergy is not null then update productattribute SET isalergy = _isalergy , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _isavailable is not null then update productattribute SET isavailable = _isavailable , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _attributeid is not null then update productattribute SET attributeid = _attributeid , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _controltype is not null then update productattribute SET controltype = _controltype , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _priority is not null then update productattribute SET priority = _priority , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _ispreselected is not null then update productattribute SET ispreselected = _ispreselected , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _isglobal is not null then update productattribute SET isglobal = _isglobal , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _price is not null then update productattribute SET price = _price , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _companyid is not null then update productattribute SET companyid = _companyid , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _noofselection is not null then update productattribute SET noofselection = _noofselection , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _minimumcount is not null then update productattribute SET minimumcount = _minimumcount , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _maximumcount is not null then update productattribute SET maximumcount = _maximumcount , updatedat = now(), updatedby = _updatedby where id = _id; end if;

END if;
end;
$$;


--
-- Name: updateattribute(uuid, uuid, jsonb, jsonb, boolean, boolean, boolean, boolean, uuid, public.citext, integer, boolean, boolean, public.citext, jsonb, uuid, public.citext, integer, integer, integer); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updateattribute(IN _id uuid, IN _productid uuid DEFAULT NULL::uuid, IN _name jsonb DEFAULT NULL::jsonb, IN _description jsonb DEFAULT NULL::jsonb, IN _isrequired boolean DEFAULT NULL::boolean, IN _isalergy boolean DEFAULT NULL::boolean, IN _ischatbotquestion boolean DEFAULT NULL::boolean, IN _isavailable boolean DEFAULT NULL::boolean, IN _attributeid uuid DEFAULT NULL::uuid, IN _controltype public.citext DEFAULT NULL::public.citext, IN _priority integer DEFAULT NULL::integer, IN _ispreselected boolean DEFAULT NULL::boolean, IN _isglobal boolean DEFAULT NULL::boolean, IN _weight public.citext DEFAULT NULL::public.citext, IN _price jsonb DEFAULT NULL::jsonb, IN _companyid uuid DEFAULT NULL::uuid, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext, IN _noofselection integer DEFAULT NULL::integer, IN _minimumcount integer DEFAULT NULL::integer, IN _maximumcount integer DEFAULT NULL::integer)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select ispublished from productattribute where id = _id) = true) and ((select isdeleted from productattribute where id = _id) = false)) then 
if _productid is not null then update productattribute SET productid = _productid , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _name is not null then update productattribute SET name = _name , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _description is not null then update productattribute SET description = _description , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _isrequired is not null then update productattribute SET isrequired = _isrequired , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _isalergy is not null then update productattribute SET isalergy = _isalergy , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _ischatbotquestion is not null then update productattribute SET ischatbotquestion = _ischatbotquestion , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _isavailable is not null then update productattribute SET isavailable = _isavailable , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _attributeid is not null then update productattribute SET attributeid = _attributeid , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _controltype is not null then update productattribute SET controltype = _controltype , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _priority IS NOT NULL THEN if _priority != 0 then UPDATE productattribute SET priority = _priority, updatedat = NOW(), updatedby = _updatedby WHERE id = _id; end if; end if;
if _ispreselected is not null then update productattribute SET ispreselected = _ispreselected , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _isglobal is not null then update productattribute SET isglobal = _isglobal , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _price is not null then update productattribute SET price = _price , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _companyid is not null then update productattribute SET companyid = _companyid , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _noofselection is not null then update productattribute SET noofselection = _noofselection , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _minimumcount is not null then update productattribute SET minimumcount = _minimumcount , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _maximumcount is not null then update productattribute SET maximumcount = _maximumcount , updatedat = now(), updatedby = _updatedby where id = _id; end if;

END if;
end;
$$;


--
-- Name: updateattributeforintegration(uuid, uuid, jsonb, jsonb, boolean, boolean, boolean, uuid, public.citext, integer, boolean, boolean, public.citext, jsonb, uuid, public.citext, integer, integer, integer, boolean, boolean, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updateattributeforintegration(IN _id uuid, IN _productid uuid DEFAULT NULL::uuid, IN _name jsonb DEFAULT NULL::jsonb, IN _description jsonb DEFAULT NULL::jsonb, IN _isrequired boolean DEFAULT NULL::boolean, IN _isalergy boolean DEFAULT NULL::boolean, IN _isavailable boolean DEFAULT NULL::boolean, IN _attributeid uuid DEFAULT NULL::uuid, IN _controltype public.citext DEFAULT NULL::public.citext, IN _priority integer DEFAULT NULL::integer, IN _ispreselected boolean DEFAULT NULL::boolean, IN _isglobal boolean DEFAULT NULL::boolean, IN _weight public.citext DEFAULT NULL::public.citext, IN _price jsonb DEFAULT NULL::jsonb, IN _companyid uuid DEFAULT NULL::uuid, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext, IN _noofselection integer DEFAULT NULL::integer, IN _minimumcount integer DEFAULT NULL::integer, IN _maximumcount integer DEFAULT NULL::integer, IN _ischatbotqestion boolean DEFAULT NULL::boolean, IN _is_deleted boolean DEFAULT NULL::boolean, IN _externalposid public.citext DEFAULT NULL::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if _productid is not null then update productattribute SET productid = _productid , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _name is not null then update productattribute SET name = _name , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _description is not null then update productattribute SET description = _description , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _isrequired is not null then update productattribute SET isrequired = _isrequired , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _isalergy is not null then update productattribute SET isalergy = _isalergy , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _isavailable is not null then update productattribute SET isavailable = _isavailable , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _attributeid is not null then update productattribute SET attributeid = _attributeid , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _controltype is not null then update productattribute SET controltype = _controltype , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _priority != 0 then update productattribute SET priority = _priority , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _ispreselected is not null then update productattribute SET ispreselected = _ispreselected , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _isglobal is not null then update productattribute SET isglobal = _isglobal , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _price is not null then update productattribute SET price = _price , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _companyid is not null then update productattribute SET companyid = _companyid , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _noofselection is not null then update productattribute SET noofselection = _noofselection , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _minimumcount is not null then update productattribute SET minimumcount = _minimumcount , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _maximumcount is not null then update productattribute SET maximumcount = _maximumcount , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _ischatbotqestion is not null then update productattribute SET ischatbotquestion = _ischatbotqestion , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _is_deleted is not null then update productattribute SET isdeleted = _is_deleted , ispublished = Not _is_deleted , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _externalposid is not null then update productattribute SET external_pos_id = _externalposid , updatedat = now(), updatedby = _updatedby where id = _id; end if;

end;
$$;


--
-- Name: updateattributevalue(uuid, public.citext, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updateattributevalue(IN _id uuid, IN _languagecode public.citext DEFAULT 'en'::public.citext, IN _weight public.citext DEFAULT NULL::public.citext, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select ispublished from category where id = _id) = true) and ((select isdeleted from category where id = _id) = false)) then 
if _weight is not null then update category SET weight = _weight , updatedat = now(), updatedby = _updatedby where id = _id; end if;
END if;
end;
$$;


--
-- Name: updateattributevalue(uuid, public.citext, jsonb, public.citext, jsonb, integer, boolean, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updateattributevalue(IN _id uuid, IN _languagecode public.citext DEFAULT 'en'::public.citext, IN _name jsonb DEFAULT NULL::jsonb, IN _weight public.citext DEFAULT NULL::public.citext, IN _price jsonb DEFAULT NULL::jsonb, IN _priority integer DEFAULT NULL::integer, IN _ispreselected boolean DEFAULT NULL::boolean, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select ispublished from productattribute where attributeid = _id) = true) and ((select isdeleted from productattribute where id = _id) = false)) then 
if _name is not null then update productattribute SET name = _name , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _weight is not null then update productattribute SET weight = _weight , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _price is not null then update productattribute SET price = _price , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _priority is not null then update productattribute SET priority = _priority , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _ispreselected is not null then update productattribute SET ispreselected = _ispreselected , updatedat = now(), updatedby = _updatedby where id = _id; end if;
END if;
end;
$$;


--
-- Name: updatebranch(uuid, uuid, public.citext, uuid, uuid, integer, public.citext, timestamp without time zone, timestamp without time zone, public.citext, numeric, numeric, jsonb, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatebranch(IN _id uuid, IN _countryid uuid, IN _name public.citext DEFAULT NULL::public.citext, IN _companyid uuid DEFAULT NULL::uuid, IN _addressid uuid DEFAULT NULL::uuid, IN _status integer DEFAULT NULL::integer, IN _phonenumber public.citext DEFAULT NULL::public.citext, IN _opentime timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _closetime timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _address public.citext DEFAULT NULL::public.citext, IN _latitude numeric DEFAULT NULL::numeric, IN _longtitude numeric DEFAULT NULL::numeric, IN _namelanguage jsonb DEFAULT NULL::jsonb, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select ispublished from branch where id = _id) = true) and ((select isdeleted from branch where id = _id) = false)) then 
if _countryid is not null then update branch SET name = _countryid , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _name is not null then update branch SET name = _name , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _companyid is not null then update branch SET companyid = _companyid , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _addressid is not null then update branch SET addressid = _addressid , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _status is not null then update branch SET status = _status , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _phonenumber is not null then update branch SET phonenumber = _phonenumber , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _opentime is not null then update branch SET opentime = _opentime , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _closetime is not null then update branch SET closetime = _closetime , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _address is not null then update branch SET addressname = _address , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _latitude is not null then update branch SET latitude = _latitude , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _longtitude is not null then update branch SET longtitude = _longtitude , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _namelanguage is not null then update branch SET namelanguage = _namelanguage, updatedat = now(), updatedby = _updatedby where id = _id; end if;

END if;
end;
$$;


--
-- Name: updatebranchstatusfromcashier(uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatebranchstatusfromcashier(IN _branchid uuid)
    LANGUAGE plpgsql
    AS $$
begin
-- missing source code
end;
$$;


--
-- Name: updatebranchstatusfromcashier(uuid, integer); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatebranchstatusfromcashier(IN _branchid uuid, IN _status integer)
    LANGUAGE plpgsql
    AS $$
begin 
UPDATE branch
	set status = _status
	where id = _branchid;
	END;
$$;


--
-- Name: updatebranchtemplate(uuid, public.citext, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatebranchtemplate(IN _branchid uuid, IN _type public.citext, IN _islogo boolean, IN _isrestaurantname boolean, IN _isphonenumber boolean, IN _isbranchname boolean, IN _isorderinfo boolean, IN _isproductinfo boolean, IN _isordertype boolean, IN _isordersource boolean, IN _isscheduletime boolean, IN _iscreatetime boolean, IN _isordernote boolean, IN _isdeliveryfees boolean, IN _isorderprice boolean, IN _istaxvalue boolean, IN _istotal boolean, IN _iscustomername boolean, IN _iscustomerphone boolean, IN _iscustomeraddress boolean, IN _isdeliverynote boolean, IN _istaxnumber boolean, IN _isattribute boolean, IN _issubattribute boolean, IN _isproductnote boolean, IN _isordernumber boolean, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if ((select Count(islogo) from branchtemplate where branchid = _branchid and type = _type) < 1 ) then
INSERT INTO public.branchtemplate(
	branchid, type, islogo, isrestaurantname, isphonenumber, isbranchname, isorderinfo, isproductinfo, createdby, isordertype, isordersource, isscheduletime, iscreatetime, isordernote, isdeliveryfees, isorderprice, istaxvalue, istotal, iscustomername, iscustomerphone, iscustomeraddress, isdeliverynote, istaxnumber, isattribute, issubattribute, isproductnote, isordernumber)
	VALUES (_branchid, _type, _islogo, _isrestaurantname, _isphonenumber, _isbranchname, _isorderinfo, _isproductinfo, _updatedby, _isordertype, _isordersource, _isscheduletime, _iscreatetime, _isordernote, _isdeliveryfees, _isorderprice, _istaxvalue, _istotal, _iscustomername, _iscustomerphone, _iscustomeraddress, _isdeliverynote, _istaxnumber, _isattribute, _issubattribute, _isproductnote, _isordernumber);
else
if _islogo is not null then update branchtemplate SET islogo = _islogo , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _isrestaurantname is not null then update branchtemplate SET isrestaurantname = _isrestaurantname , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _isphonenumber is not null then update branchtemplate SET isphonenumber = _isphonenumber , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _isbranchname is not null then update branchtemplate SET isbranchname = _isbranchname , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _isorderinfo is not null then update branchtemplate SET isorderinfo = _isorderinfo , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _isproductinfo is not null then update branchtemplate SET isproductinfo = _isproductinfo , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _isordertype is not null then update branchtemplate SET isordertype = _isordertype , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _isordersource is not null then update branchtemplate SET isordersource = _isordersource , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _isscheduletime is not null then update branchtemplate SET isscheduletime = _isscheduletime , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _iscreatetime is not null then update branchtemplate SET iscreatetime = _iscreatetime , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _isordernote is not null then update branchtemplate SET isordernote = _isordernote , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _isdeliveryfees is not null then update branchtemplate SET isdeliveryfees = _isdeliveryfees  , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _isorderprice is not null then update branchtemplate SET isorderprice = _isorderprice , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _istaxvalue is not null then update branchtemplate SET istaxvalue = _istaxvalue , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _istotal is not null then update branchtemplate SET istotal = _istotal , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _iscustomername is not null then update branchtemplate SET iscustomername = _iscustomername , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _iscustomerphone is not null then update branchtemplate SET iscustomerphone = _iscustomerphone , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _iscustomeraddress is not null then update branchtemplate SET iscustomeraddress = _iscustomeraddress , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _isdeliverynote is not null then update branchtemplate SET isdeliverynote = _isdeliverynote , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _istaxnumber is not null then update branchtemplate SET istaxnumber = _istaxnumber , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _isattribute is not null then update branchtemplate SET isattribute = _isattribute , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _issubattribute is not null then update branchtemplate SET issubattribute = _issubattribute , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _isproductnote is not null then update branchtemplate SET isproductnote = _isproductnote , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _isordernumber is not null then update branchtemplate SET isordernumber = _isordernumber , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;

END if;
end;
$$;


--
-- Name: updatebranchtemplate(uuid, public.citext, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatebranchtemplate(IN _branchid uuid, IN _type public.citext, IN _paid boolean, IN _islogo boolean, IN _isrestaurantname boolean, IN _isphonenumber boolean, IN _isbranchname boolean, IN _isorderinfo boolean, IN _isproductinfo boolean, IN _isordertype boolean, IN _isordersource boolean, IN _isscheduletime boolean, IN _iscreatetime boolean, IN _isordernote boolean, IN _isdeliveryfees boolean, IN _isorderprice boolean, IN _istaxvalue boolean, IN _istotal boolean, IN _iscustomername boolean, IN _iscustomerphone boolean, IN _iscustomeraddress boolean, IN _isdeliverynote boolean, IN _istaxnumber boolean, IN _isattribute boolean, IN _issubattribute boolean, IN _isproductnote boolean, IN _isordernumber boolean, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext, IN _taxnumbervalue public.citext DEFAULT NULL::public.citext)
    LANGUAGE plpgsql
    AS $$

begin

--use

if ((select Count(islogo) from branchtemplate where branchid = _branchid and type = _type) < 1 ) then
INSERT INTO public.branchtemplate(
	branchid, type, islogo, isrestaurantname, isphonenumber, isbranchname, isorderinfo, isproductinfo, createdby, isordertype, isordersource, isscheduletime, iscreatetime, isordernote, isdeliveryfees, isorderprice, istaxvalue, istotal, iscustomername, iscustomerphone, iscustomeraddress, isdeliverynote, istaxnumber, isattribute, issubattribute, isproductnote, isordernumber,taxnumbervalue)
	VALUES (_branchid, _type, _islogo, _isrestaurantname, _isphonenumber, _isbranchname, _isorderinfo, _isproductinfo, _updatedby, _isordertype, _isordersource, _isscheduletime, _iscreatetime, _isordernote, _isdeliveryfees, _isorderprice, _istaxvalue, _istotal, _iscustomername, _iscustomerphone, _iscustomeraddress, _isdeliverynote, _istaxnumber, _isattribute, _issubattribute, _isproductnote
            , _isordernumber,_taxnumbervalue);
else
if _islogo is not null then update branchtemplate SET islogo = _islogo , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _isrestaurantname is not null then update branchtemplate SET isrestaurantname = _isrestaurantname , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _isphonenumber is not null then update branchtemplate SET isphonenumber = _isphonenumber , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _isbranchname is not null then update branchtemplate SET isbranchname = _isbranchname , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _isorderinfo is not null then update branchtemplate SET isorderinfo = _isorderinfo , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _isproductinfo is not null then update branchtemplate SET isproductinfo = _isproductinfo , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _isordertype is not null then update branchtemplate SET isordertype = _isordertype , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _isordersource is not null then update branchtemplate SET isordersource = _isordersource , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _isscheduletime is not null then update branchtemplate SET isscheduletime = _isscheduletime , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _iscreatetime is not null then update branchtemplate SET iscreatetime = _iscreatetime , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _isordernote is not null then update branchtemplate SET isordernote = _isordernote , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _isdeliveryfees is not null then update branchtemplate SET isdeliveryfees = _isdeliveryfees  , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _isorderprice is not null then update branchtemplate SET isorderprice = _isorderprice , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _istaxvalue is not null then update branchtemplate SET istaxvalue = _istaxvalue , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _istotal is not null then update branchtemplate SET istotal = _istotal , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _iscustomername is not null then update branchtemplate SET iscustomername = _iscustomername , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _iscustomerphone is not null then update branchtemplate SET iscustomerphone = _iscustomerphone , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _iscustomeraddress is not null then update branchtemplate SET iscustomeraddress = _iscustomeraddress , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _isdeliverynote is not null then update branchtemplate SET isdeliverynote = _isdeliverynote , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _istaxnumber is not null then update branchtemplate SET istaxnumber = _istaxnumber , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _isattribute is not null then update branchtemplate SET isattribute = _isattribute , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _issubattribute is not null then update branchtemplate SET issubattribute = _issubattribute , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _isproductnote is not null then update branchtemplate SET isproductnote = _isproductnote , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _isordernumber is not null then update branchtemplate SET isordernumber = _isordernumber , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _paid is not null then update branchtemplate SET paid = _paid , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;
if _taxnumbervalue is not null then update branchtemplate SET taxnumbervalue = _taxnumbervalue , updatedat = now(), updatedby = _updatedby where branchid = _branchid and type = _type; end if;

END if;
end;
$$;


--
-- Name: updatecategory(uuid, public.citext, public.citext, uuid, public.citext, uuid, integer, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatecategory(IN _id uuid, IN _arname public.citext DEFAULT NULL::public.citext, IN _enname public.citext DEFAULT NULL::public.citext, IN _categorytag uuid DEFAULT NULL::uuid, IN _image public.citext DEFAULT NULL::public.citext, IN _parentcategoryid uuid DEFAULT NULL::uuid, IN _displaynumber integer DEFAULT 1, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select ispublished from category where id = _id) = true) and ((select isdeleted from category where id = _id) = false)) then 
if _enname is not null then update category set name = jsonb_set(name, '{en}', to_jsonb(_enname::citext)) , updatedat = now(), updatedby = _updatedby where id = _id ; end if;
if _arname is not null then update category set name = jsonb_set(name, '{ar}', to_jsonb(_arname::citext)) , updatedat = now(), updatedby = _updatedby where id = _id ; end if;
if _categorytag is not null then update category SET categorytag = _categorytag , updatedat = now(), updatedby = _updatedby where id = _id ; end if;
if _image is not null then update category SET image = _image , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _parentcategoryid is not null then update category SET parentcategoryid = _parentcategoryid , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _displaynumber is not null then update category SET displaynumber = _displaynumber , updatedat = now(), updatedby = _updatedby where id = _id; end if;
END if;
end;
$$;


--
-- Name: updatecategoryforintegration(uuid, public.citext, public.citext, uuid, public.citext, uuid, integer, public.citext, boolean, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatecategoryforintegration(IN _id uuid, IN _arname public.citext DEFAULT NULL::public.citext, IN _enname public.citext DEFAULT NULL::public.citext, IN _categorytag uuid DEFAULT NULL::uuid, IN _image public.citext DEFAULT NULL::public.citext, IN _parentcategoryid uuid DEFAULT NULL::uuid, IN _displaynumber integer DEFAULT 1, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext, IN _is_deleted boolean DEFAULT false, IN _externalposid public.citext DEFAULT NULL::public.citext)
    LANGUAGE plpgsql
    AS $$
begin
        if _enname is not null then
            update category
            set name      = jsonb_set(name, '{en}', to_jsonb(_enname::citext)),
                updatedat = now(),
                updatedby = _updatedby
            where id = _id;
        end if;
        if _arname is not null then
            update category
            set name      = jsonb_set(name, '{ar}', to_jsonb(_arname::citext)),
                updatedat = now(),
                updatedby = _updatedby
            where id = _id;
        end if;
        if _categorytag is not null then
            update category SET categorytag = _categorytag, updatedat = now(), updatedby = _updatedby where id = _id;
        end if;
        if _parentcategoryid is not null then
            update category
            SET parentcategoryid = _parentcategoryid, updatedat = now(), updatedby = _updatedby
            where id = _id;
        end if;
        if _is_deleted is not null then
            update category
            SET isdeleted   = _is_deleted,
                ispublished = Not _is_deleted,
                updatedat   = (now() AT TIME ZONE 'Asia/Amman'::text),
                updatedby   = 'Moayyad'
            where id = _id;
        end if;
        if _externalposid is not null then
            update category
            SET external_pos_id = _externalposid,
                ispublished     = Not _is_deleted,
                updatedat       = (now() AT TIME ZONE 'Asia/Amman'::text),
                updatedby       = 'Moayyad'
            where id = _id;
        end if;
end;
$$;


--
-- Name: updateclientintegration(uuid, uuid, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updateclientintegration(IN _companyid uuid DEFAULT NULL::uuid, IN _intcompanyid uuid DEFAULT NULL::uuid, IN _name public.citext DEFAULT NULL::public.citext, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select ispublished from clientintegration where companyid = _id) = true) and ((select isdeleted from clientintegration where companyid = _id) = false)) then 
if _intcompanyid is not null then update clientintegration SET intcompanyid = _intcompanyid , updatedat = now(), updatedby = _updatedby where companyid = _id; end if;
if _name is not null then update clientintegration SET name = _name , updatedat = now(), updatedby = _updatedby where companyid = _id; end if;
END if;
end;
$$;


--
-- Name: updatecompany(uuid, public.citext, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatecompany(IN _id uuid, IN _name public.citext DEFAULT NULL::public.citext, IN _logo public.citext DEFAULT NULL::character varying, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select ispublished from company where id = _id) = true) and ((select isdeleted from company where id = _id) = false)) then 
if _name is not null then update company SET name = _name , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _logo is not null then update company SET logo = _logo , updatedat = now(), updatedby = _updatedby where id = _id; end if;
END if;
END;
$$;


--
-- Name: updatecompanychannelactivation(uuid, uuid, boolean); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatecompanychannelactivation(IN _companyid uuid, IN _channelid uuid, IN _value boolean)
    LANGUAGE plpgsql
    AS $$
begin
    update companychannels set isactive = _value where companyid = _companyid and channelid = _channelid;
end;
$$;


--
-- Name: updatecompanyfaq(uuid, public.citext, public.citext, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatecompanyfaq(IN _id uuid, IN _question public.citext DEFAULT NULL::public.citext, IN _answer1 public.citext DEFAULT NULL::public.citext, IN _answer2 public.citext DEFAULT NULL::public.citext, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select ispublished from companyfaq where id = _id) = true) and ((select isdeleted from companyfaq where id = _id) = false)) then 
if _question is not null then update companyfaq SET question = _question , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _answer1 is not null then update companyfaq SET answer1 = _answer1 , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _answer2 is not null then update companyfaq SET answer2 = _answer2 , updatedat = now(), updatedby = _updatedby where id = _id; end if;
end if;
END;
$$;


--
-- Name: updatecompanyinfo(uuid, public.citext, uuid, integer, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatecompanyinfo(IN _id uuid, IN _languagecode public.citext, IN _companyid uuid DEFAULT NULL::uuid, IN _type integer DEFAULT NULL::integer, IN _value public.citext DEFAULT NULL::public.citext, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select ispublished from companyinfo where id = _id) = true) and ((select isdeleted from companyinfo where id = _id) = false)) then 
if _companyid is not null then update companyinfo SET companyid = _companyid , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _type is not null then update companyinfo SET type = _type , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _value is not null then call createlanguageresource('companyInfo' , _value , _id , _languagecode ,1 , _updatedby) ; end if;
END if;
END;
$$;


--
-- Name: updatecompanyprofile(uuid, public.citext, public.citext, public.citext, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatecompanyprofile(IN _companyid uuid, IN _logo public.citext, IN _email public.citext, IN _name public.citext, IN _phone public.citext, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if _logo is not null then update company SET logo = _logo , updatedat = now(), updatedby = _updatedby where company.id = _companyid; end if;
if _name is not null then update company SET name = _name , updatedat = now(), updatedby = _updatedby where company.id = _companyid; end if;
if _email is not null then update companyinfo SET value = _email , updatedat = now(), updatedby = _updatedby where companyinfo.companyid = _companyid and type = 'email' ; end if;
if _phone is not null then update companyinfo SET value = _phone , updatedat = now(), updatedby = _updatedby where companyinfo.companyid = _companyid and type = 'phone' ; end if;
END;
$$;


--
-- Name: updatecompanyservicesactivation(uuid, uuid, boolean); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatecompanyservicesactivation(IN _companyid uuid, IN _serviceid uuid, IN _value boolean)
    LANGUAGE plpgsql
    AS $$

begin
   if((select count(cs.companyid) from companyservices cs where cs.companyid =_companyid and serviceid = _serviceid ) > 0)
   THEN
    update companyservices set isactive = _value, updatedat = now() where companyid = _companyid and serviceid = _serviceid;
    else
    INSERT INTO companyservices(companyid,serviceid,isactive)
	VALUES (_companyid,_serviceid,_value);
    END IF;
end;
$$;


--
-- Name: updatecompanyuser(uuid, public.citext, public.citext, public.citext, public.citext, uuid[], numeric, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatecompanyuser(IN _id uuid, IN _usertype public.citext, IN _username public.citext, IN _email public.citext, IN _name public.citext, IN _branchid uuid[], IN _phonenumber numeric, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select isactive from companyuser where id = _id) = true) and ((select isdeleted from companyuser where id = _id) = false)) then 
if _usertype is not null then update companyuser SET usertype = _usertype , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _username is not null then update companyuser SET username = _username , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _email is not null then update companyuser SET email = _email , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _name is not null then update companyuser SET name = _name , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _branchid is not null then update companyuser SET branchid = _branchid , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _phonenumber is not null then update companyuser SET phonenumber = _phonenumber , updatedat = now(), updatedby = _updatedby where id = _id; end if;

END if;
end;
$$;


--
-- Name: updatecoupon(uuid, uuid, integer, numeric, numeric, integer, integer, numeric, boolean, integer, uuid[], public.citext, timestamp without time zone, timestamp without time zone, timestamp without time zone, timestamp without time zone, numeric, boolean, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatecoupon(IN _id uuid, IN _offerid uuid DEFAULT NULL::uuid, IN _coupontype integer DEFAULT NULL::integer, IN _minprice numeric DEFAULT NULL::numeric, IN _maxprice numeric DEFAULT NULL::numeric, IN _minquantity integer DEFAULT NULL::integer, IN _maxquantity integer DEFAULT NULL::integer, IN _couponvalue numeric DEFAULT NULL::numeric, IN _isunlimited boolean DEFAULT false, IN _numberofuses integer DEFAULT NULL::integer, IN _customerids uuid[] DEFAULT NULL::uuid[], IN _code public.citext DEFAULT NULL::public.citext, IN _fromdate timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _todate timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _fromtime timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _totime timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _newprice numeric DEFAULT NULL::numeric, IN _ispercentage boolean DEFAULT false, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select ispublished from coupon where id = _id) = true) and ((select isdeleted from coupon where id = _id) = false)) then 
if _coupontype is not null then update coupon SET coupontype = _coupontype , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _offerid is not null then update coupon SET offerid = _offerid , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _minprice is not null then update coupon SET minprice = _minprice , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _maxprice is not null then update coupon SET maxprice = _maxprice , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _minquantity is not null then update coupon SET minquantity = _minquantity , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _maxquantity is not null then update coupon SET maxquantity = _maxquantity , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _couponvalue is not null then update coupon SET couponvalue = _couponvalue , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _isunlimited is not null then update coupon SET isunlimited = _isunlimited , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _numberofuses is not null then update coupon SET numberofuses = _numberofuses , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _customerids is not null then update coupon SET customerids = _customerids , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _code is not null then update coupon SET code = _code , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _fromdate is not null then update coupon SET fromdate = _fromdate , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _todate is not null then update coupon SET todate = _todate , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _fromtime is not null then update coupon SET fromtime = _fromtime , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _totime is not null then update coupon SET totime = _totime , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _newprice is not null then update coupon SET newprice = _newprice , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _ispercentage is not null then update coupon SET ispercentage = _ispercentage , updatedat = now(), updatedby = _updatedby where id = _id; end if;

END if;
end;
$$;


--
-- Name: updatecustomer_ai(uuid, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatecustomer_ai(IN _id uuid, IN _name public.citext DEFAULT NULL::public.citext, IN _email public.citext DEFAULT NULL::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select ispublished from "customer" where id = _id) = true) and ((select isdeleted from "customer" where id = _id) = false)) then 
if _name is not null then update "customer" SET name = _name , updatedat = now(), updatedby = 'MobileApp' where id = _id; end if;
if _email is not null then update "customer" SET email = _email , updatedat = now(), updatedby = 'MobileApp' where id = _id; end if;
END if;
end;
$$;


--
-- Name: updatecustomeraddress(uuid, uuid, uuid, public.citext, public.citext, public.citext, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatecustomeraddress(IN _customerid uuid, IN _addressid uuid, IN _incomingaddressid uuid DEFAULT NULL::uuid, IN _buildingno public.citext DEFAULT NULL::public.citext, IN _streetname public.citext DEFAULT NULL::public.citext, IN _details public.citext DEFAULT NULL::public.citext, IN _name public.citext DEFAULT NULL::public.citext, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin
update customeraddress SET buildingno = _buildingno , updatedat = now(), updatedby = _updatedby where addressid = _addressid and customerid = _customerid;
update customeraddress SET streetname = _streetname , updatedat = now(), updatedby = _updatedby where addressid = _addressid and customerid = _customerid;
update customeraddress SET details = _details , updatedat = now(), updatedby = _updatedby where addressid = _addressid and customerid = _customerid;
update customeraddress SET name = _name , updatedat = now(), updatedby = _updatedby where addressid = _addressid and customerid = _customerid;
if _incomingaddressid is not null then update customeraddress SET addressid = _incomingaddressid , updatedat = now(), updatedby = _updatedby where addressid = _addressid and customerid = _customerid; end if;
end;
$$;


--
-- Name: updatecustomeraddress_ai(uuid, numeric, numeric, public.citext, public.citext, public.citext, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatecustomeraddress_ai(IN _id uuid, IN _latitude numeric, IN _longtitude numeric, IN _buildingno public.citext DEFAULT NULL::public.citext, IN _details public.citext DEFAULT NULL::public.citext, IN _name public.citext DEFAULT NULL::public.citext, IN _departmentno public.citext DEFAULT NULL::public.citext, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if _buildingno is not null then update customeraddress SET buildingno = _buildingno , updatedat = now(), updatedby = _updatedby where addressid = _id ; end if;
if _departmentno is not null then update customeraddress SET departmentno = _departmentno , updatedat = now(), updatedby = _updatedby where addressid = _id; end if;
if _details is not null then update customeraddress SET details = _details , updatedat = now(), updatedby = _updatedby where addressid = _id; end if;
if _name is not null then update customeraddress SET name = _name , updatedat = now(), updatedby = _updatedby where addressid = _id;  end if;
if _latitude is not null then update customeraddress SET latitude = _latitude , updatedat = now(), updatedby = _updatedby where addressid = _id;  end if;
if _longtitude is not null then update customeraddress SET longtitude = _longtitude , updatedat = now(), updatedby = _updatedby where addressid = _id;  end if;

end;
$$;


--
-- Name: updatecustomeraddressbydistance(uuid, uuid, public.citext, numeric, numeric, public.citext, public.citext, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatecustomeraddressbydistance(IN _customerid uuid, IN _addressid uuid, IN _name public.citext, IN _latitude numeric DEFAULT NULL::numeric, IN _longtitude numeric DEFAULT NULL::numeric, IN _details public.citext DEFAULT 'SYSTEM'::public.citext, IN _buildingno public.citext DEFAULT NULL::public.citext, IN _streetname public.citext DEFAULT NULL::public.citext, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
update customeraddress SET buildingno = _buildingno , updatedat = now(), updatedby = _updatedby where addressid = _addressid and customerid = _customerid;
update customeraddress SET streetname = _streetname , updatedat = now(), updatedby = _updatedby where addressid = _addressid and customerid = _customerid;
update customeraddress SET details = _details , updatedat = now(), updatedby = _updatedby where addressid = _addressid and customerid = _customerid;
update customeraddress SET name = _name , updatedat = now(), updatedby = _updatedby where addressid = _addressid and customerid = _customerid;
update customeraddress SET latitude = _latitude , updatedat = now(), updatedby = _updatedby where addressid = _addressid and customerid = _customerid;
update customeraddress SET longtitude = _longtitude , updatedat = now(), updatedby = _updatedby where addressid = _addressid and customerid = _customerid;

update address SET latitude = _latitude , updatedat = now(), updatedby = _updatedby where id = _addressid;
update address SET longtitude = _longtitude , updatedat = now(), updatedby = _updatedby where id = _addressid;



end;
$$;


--
-- Name: updatecustomeraddressbydistance_ai(uuid, uuid, public.citext, numeric, numeric, public.citext, public.citext, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatecustomeraddressbydistance_ai(IN _customerid uuid, IN _addressid uuid, IN _name public.citext, IN _latitude numeric DEFAULT NULL::numeric, IN _longtitude numeric DEFAULT NULL::numeric, IN _details public.citext DEFAULT 'SYSTEM'::public.citext, IN _buildingno public.citext DEFAULT NULL::public.citext, IN _streetname public.citext DEFAULT NULL::public.citext, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
update customeraddress SET buildingno = _buildingno , updatedat = now(), updatedby = _updatedby where addressid = _addressid and customerid = _customerid;
update customeraddress SET streetname = _streetname , updatedat = now(), updatedby = _updatedby where addressid = _addressid and customerid = _customerid;
update customeraddress SET details = _details , updatedat = now(), updatedby = _updatedby where addressid = _addressid and customerid = _customerid;
update customeraddress SET name = _name , updatedat = now(), updatedby = _updatedby where addressid = _addressid and customerid = _customerid;
update customeraddress SET latitude = _latitude , updatedat = now(), updatedby = _updatedby where addressid = _addressid and customerid = _customerid;
update customeraddress SET longtitude = _longtitude , updatedat = now(), updatedby = _updatedby where addressid = _addressid and customerid = _customerid;

update address SET latitude = _latitude , updatedat = now(), updatedby = _updatedby where id = _addressid;
update address SET longtitude = _longtitude , updatedat = now(), updatedby = _updatedby where id = _addressid;

end;
$$;


--
-- Name: updatecustomeraddressgeo(uuid, public.citext, public.citext, public.citext, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatecustomeraddressgeo(IN _addressid uuid, IN _buildingno public.citext DEFAULT NULL::public.citext, IN _streetname public.citext DEFAULT NULL::public.citext, IN _details public.citext DEFAULT NULL::public.citext, IN _note public.citext DEFAULT NULL::public.citext, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if _buildingno is not null then update customeraddress SET buildingno = _buildingno , updatedat = now(), updatedby = _updatedby,georeflected = true where addressid = _addressid; end if;
if _streetname is not null then update customeraddress SET streetname = _streetname , updatedat = now(), updatedby = _updatedby,georeflected = true where addressid = _addressid; end if;
if _details is not null then update customeraddress SET details = _details , updatedat = now(), updatedby = _updatedby,georeflected = true where addressid = _addressid; end if;
if _note is not null THEN update customeraddress SET notes = _note , updatedat = now(), updatedby = _updatedby,georeflected = true where addressid = _addressid;  end if;

end;
$$;


--
-- Name: updatedeliverycompany(uuid, jsonb, boolean, public.citext, uuid, timestamp without time zone, timestamp without time zone, public.citext, boolean, public.citext, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatedeliverycompany(INOUT _id uuid, IN _name jsonb DEFAULT NULL::jsonb, IN _isaggregated boolean DEFAULT NULL::boolean, IN _phonenumber public.citext DEFAULT NULL::public.citext, IN _addressid uuid DEFAULT NULL::uuid, IN _opentime timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _closetime timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _currency public.citext DEFAULT NULL::public.citext, IN _isavailable boolean DEFAULT NULL::boolean, IN _logo public.citext DEFAULT NULL::public.citext, IN _website public.citext DEFAULT NULL::public.citext, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select ispublished from deliverycompany where id = _id) = true) and ((select isdeleted from deliverycompany where id = _id) = false)) then 
if _name is not null then update deliverycompany SET name = _name , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _isaggregated is not null then update deliverycompany SET isaggregated = _isaggregated , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _phonenumber is not null then update deliverycompany SET phonenumber = _phonenumber , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _addressid is not null then update deliverycompany SET addressid = _addressid , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _opentime is not null then update deliverycompany SET opentime = _opentime , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _closetime is not null then update deliverycompany SET closetime = _closetime , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _currency is not null then update deliverycompany SET currency = _currency , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _isavailable is not null then update deliverycompany SET isavailable = _isavailable , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _logo is not null then update deliverycompany SET logo = _logo , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _website is not null then update deliverycompany SET website = _website , updatedat = now(), updatedby = _updatedby where id = _id; end if;

END if;
end;
$$;


--
-- Name: updatediscount(uuid, public.citext, public.citext, uuid[], uuid[], uuid[], uuid[], uuid[], uuid[], numeric, integer, numeric, numeric, integer, boolean, timestamp without time zone, timestamp without time zone, integer[], public.citext, public.citext, public.citext, public.citext, boolean, integer, integer, jsonb); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatediscount(IN _id uuid, IN _name public.citext DEFAULT NULL::public.citext, IN _discounttype public.citext DEFAULT NULL::public.citext, IN _productids uuid[] DEFAULT NULL::uuid[], IN _attributeids uuid[] DEFAULT NULL::uuid[], IN _categoryids uuid[] DEFAULT NULL::uuid[], IN _channelids uuid[] DEFAULT NULL::uuid[], IN _branchids uuid[] DEFAULT NULL::uuid[], IN _customerids uuid[] DEFAULT NULL::uuid[], IN _discountvalue numeric DEFAULT NULL::numeric, IN _mindiscountquantity integer DEFAULT NULL::integer, IN _maxdiscountprice numeric DEFAULT NULL::integer, IN _mindiscountprice numeric DEFAULT NULL::integer, IN _priority integer DEFAULT NULL::integer, IN _ispercentage boolean DEFAULT NULL::boolean, IN _availablefrom timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _availableto timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _daysofweek integer[] DEFAULT NULL::integer[], IN _promocode public.citext DEFAULT NULL::public.citext, IN _description public.citext DEFAULT NULL::public.citext, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext, IN _level public.citext DEFAULT NULL::public.citext, IN _isdaily boolean DEFAULT false, IN _noofusefrocustomer integer DEFAULT NULL::integer, IN _noofuse integer DEFAULT NULL::integer, IN _descriptionlanguage jsonb DEFAULT NULL::jsonb)
    LANGUAGE plpgsql
    AS $$

declare cid uuid;
declare pid uuid;
declare attid uuid;
declare brid uuid;
declare chid uuid;
declare cus uuid;
begin
if _name is not null then update discountinfo SET name = _name , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _discounttype is not null then update discountinfo SET type = _discounttype , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _customerids is not null then update discount SET customerids = _customerids , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _discountvalue is not null then update discountinfo SET value = _discountvalue , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _promocode is not null then update discountinfo SET promocode = _promocode , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _mindiscountquantity is not null then update discountinfo SET minquantity = _mindiscountquantity , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _maxdiscountprice is not null then update discountinfo SET maxvalue = _maxdiscountprice , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _mindiscountprice is not null then update discountinfo SET minprice = _mindiscountprice , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _priority is not null then update discountinfo SET priority = _priority , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _ispercentage is not null then update discountinfo SET ispercentage = _ispercentage , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _availablefrom is not null then update discountinfo SET availablefrom = _availablefrom , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _availableto is not null then update discountinfo SET availableto = _availableto , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _description is not null then update discountinfo SET description = _description , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _daysofweek is not null then update discountinfo SET daysofweek = _daysofweek , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _descriptionlanguage is not null then update discountinfo SET descriptionlanguage = _descriptionlanguage , updatedat = now(), updatedby = _updatedby where id = _id; end if;

if _branchids is not null
  then
     delete from discountbranch where discountid = _id;
     foreach brid in array _branchids loop
           INSERT INTO public.discountbranch(branchid,discountid)
	       VALUES(brid,_id);
        end loop;
end if;

if _channelids is not null
   then
       delete from discountchannel where discountid = _id;
       foreach chid in array _channelids loop
           INSERT INTO public.discountchannel(channelid,discountid)
	       VALUES(chid,_id);
        end loop;
end if;

if _customerids is not null
   then
       delete from discountcustomers where discountid = _id;
       foreach cus in array _customerids loop
           INSERT INTO public.discountcustomers(customerid,discountid)
	       VALUES(cus,_id);
        end loop;
end if;

if (_attributeids is null) then
    if(_productids is null) then --only categoryids
    if _categoryids is not null then 
     delete from discountproduct where discountid = _id;
     foreach cid in array _categoryids loop
      FOR pid IN (select product.id from product where categoryid = cid and product.isdeleted = false and product.ispublished = true)
	  LOOP
	  INSERT INTO public.discountproduct(productid, discountid)
	       VALUES(pid,_id);
	END LOOP;
   end loop;
   end if;
else
        --there is products
        if _productids is not null then
           delete from discountproduct where discountid = _id;
           foreach pid in array _productids loop
             INSERT INTO public.discountproduct(productid, discountid)
	         VALUES(pid,_id);
           end loop;
       end if;
end if;
    else
        --there is attributes
        if _attributeids is not null then
           delete from discountproduct where discountid = _id;
           delete from discountattribute where discountid = _id;
           foreach attid in array _attributeids loop
                   INSERT INTO public.discountattribute(attributeid,discountid)
	               VALUES(attid,_id);
                   end loop;
        end if;
end if;

end;
$$;


--
-- Name: updateenabledbranch(uuid, boolean, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updateenabledbranch(IN _companyid uuid, IN _enabled boolean, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
DECLARE _status INT; 
begin
if(_enabled) then _status = 1; else _status = 0; end if;
if _companyid is not null then update branch SET status = _status , updatedat = now(), updatedby = _updatedby where companyid = _companyid; end if;
end;
$$;


--
-- Name: updateholdordertofinished(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updateholdordertofinished(IN _paymentorderid uuid, IN _sessionid public.citext)
    LANGUAGE plpgsql
    AS $$
begin
update paymentonholdorders
        set finished = true
        where orderpaymentid = _paymentorderid and
        sessionid = _sessionid;
        end;
$$;


--
-- Name: updateintegrationcompany(uuid, public.citext, public.citext, public.citext, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updateintegrationcompany(IN _id uuid, IN _name public.citext DEFAULT NULL::public.citext, IN _logo public.citext DEFAULT NULL::public.citext, IN _type public.citext DEFAULT NULL::public.citext, IN _phone public.citext DEFAULT NULL::public.citext, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select ispublished from integrationcompany where id = _id) = true) and ((select isdeleted from branch where id = _id) = false)) then 
if _id is not null then update integrationcompany SET id = _id , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _name is not null then update integrationcompany SET name = _name , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _logo is not null then update integrationcompany SET logo = _logo , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _type is not null then update integrationcompany SET type = _type , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _phone is not null then update integrationcompany SET phone = _phone , updatedat = now(), updatedby = _updatedby where id = _id; end if;

END if;
end;
$$;


--
-- Name: updateintegrationmiddlewarerequestlog(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updateintegrationmiddlewarerequestlog(IN _id uuid, IN _response public.citext)
    LANGUAGE plpgsql
    AS $$
begin
    update integrationmiddlewarerequestlog
    set response = _response, responsetime = now()
    where id = _id;
END;
$$;


--
-- Name: updateintegrationrequest(uuid, uuid, public.citext, boolean, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updateintegrationrequest(IN _companyid uuid, IN _channelid uuid, IN _status public.citext, IN _isactive boolean, IN _reason public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
update companyactiveintegrations set status=_status,isactive=_isactive,reason=_reason where companyid=_companyid and channelid =_channelid;
end
$$;


--
-- Name: updateinterfaceapirequestlog(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updateinterfaceapirequestlog(IN _id uuid, IN _response public.citext)
    LANGUAGE plpgsql
    AS $$

begin
    update interfaceapirequestlog
    set response = _response, responsetime = now()
    where id = _id;
END;
$$;


--
-- Name: updateishbekproduct(uuid, jsonb, jsonb, uuid, jsonb); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updateishbekproduct(IN _id uuid DEFAULT NULL::uuid, IN _name jsonb DEFAULT NULL::jsonb, IN _shortdescription jsonb DEFAULT NULL::jsonb, IN _categoryid uuid DEFAULT NULL::uuid, IN _price jsonb DEFAULT NULL::jsonb)
    LANGUAGE plpgsql
    AS $$

begin
if (((select isdeleted from product where id = _id) = false)) then
if _categoryid is not null then update product SET categoryid = _categoryid , updatedat = now(), updatedby = 'Moayyad' where id = _id; end if;
if _name is not null then update product SET name = _name , updatedat = now(), updatedby = 'Moayyad' where id = _id; end if;
if _shortdescription is not null then update product SET shortdescription = _shortdescription , updatedat = now(), updatedby = 'Moayyad' where id = _id; end if;
if _price is not null then update product SET price = _price , updatedat = now(), updatedby = 'Moayyad' where id = _id; end if;
END if;
end;
$$;


--
-- Name: updateishbekproduct(uuid, jsonb, jsonb, uuid, jsonb, jsonb, public.citext, boolean, jsonb, jsonb, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updateishbekproduct(IN _id uuid DEFAULT NULL::uuid, IN _name jsonb DEFAULT NULL::jsonb, IN _shortdescription jsonb DEFAULT NULL::jsonb, IN _categoryid uuid DEFAULT NULL::uuid, IN _price jsonb DEFAULT NULL::jsonb, IN _branchprice jsonb DEFAULT NULL::jsonb, IN _imagepath public.citext DEFAULT NULL::public.citext, IN _is_deleted boolean DEFAULT false, IN _aliasname jsonb DEFAULT '{}'::jsonb, IN _aliasdescription jsonb DEFAULT '{}'::jsonb, IN _externalposid public.citext DEFAULT NULL::public.citext)
    LANGUAGE plpgsql
    AS $$
begin
    if _categoryid is not null then
        update product
        SET categoryid = _categoryid,
            updatedat  = (now() AT TIME ZONE 'Asia/Amman'::text),
            updatedby  = 'Moayyad'
        where id = _id;
    end if;
    if _externalposid is not null then
        update product
        SET external_pos_id = _externalposid,
            updatedat  = (now() AT TIME ZONE 'Asia/Amman'::text),
            updatedby  = 'Moayyad'
        where id = _id;
    end if;
    if (_name ->> 'ar' <> '') is not false then
        update product
        SET name['ar'] = _name['ar'],
            updatedat  = (now() AT TIME ZONE 'Asia/Amman'::text),
            updatedby  = 'Moayyad'
        where id = _id;
    else
        update product
        SET name['ar'] = (select name -> 'ar'
                          from product
                          where id = _id),
            updatedat  = (now() AT TIME ZONE 'Asia/Amman'::text),
            updatedby  = 'Moayyad'
        where id = _id;
    end if;
    if (_name ->> 'en' <> '') is not false then
        update product
        SET name['en'] = _name['en'],
            updatedat  = (now() AT TIME ZONE 'Asia/Amman'::text),
            updatedby  = 'Moayyad'
        where id = _id;
    else
        update product
        SET name['en'] = (select name -> 'en'
                          from product
                          where id = _id),
            updatedat  = (now() AT TIME ZONE 'Asia/Amman'::text),
            updatedby  = 'Moayyad'
        where id = _id;
    end if;
    if (_shortdescription ->> 'ar' <> '') is not false then
        update product
        SET shortdescription['ar'] = _shortdescription['ar'],
            updatedat              = (now() AT TIME ZONE 'Asia/Amman'::text),
            updatedby              = 'Moayyad'
        where id = _id;
    else
        update product
        SET shortdescription['ar'] = (select shortdescription -> 'ar'
                                      from product
                                      where id = _id),
            updatedat              = (now() AT TIME ZONE 'Asia/Amman'::text),
            updatedby              = 'Moayyad'
        where id = _id;
    end if;
    if (_shortdescription ->> 'en' <> '') is not false then
        update product
        SET shortdescription['en'] = _shortdescription['en'],
            updatedat              = (now() AT TIME ZONE 'Asia/Amman'::text),
            updatedby              = 'Moayyad'
        where id = _id;
    else
        update product
        SET shortdescription['en'] = (select shortdescription -> 'en'
                                      from product
                                      where id = _id),
            updatedat              = (now() AT TIME ZONE 'Asia/Amman'::text),
            updatedby              = 'Moayyad'
        where id = _id;

    end if;
    update product
    set aliasname        = _aliasname,
        aliasdescription = _aliasdescription,
        updatedat = (now() AT TIME ZONE 'Asia/Amman'::text),
        updatedby        = 'Moayyad'
    where id = _id;
    -- if _shortdescription is not null then
--     update product SET shortdescription =
--         case when _shortdescription = '{}'
--             then (select product.shortdescription['ar'] from public.product where id = _id)
--             ,
--     updatedat = (now() AT TIME ZONE 'Asia/Amman'::text), updatedby = 'Moayyad' where id = _id;
-- end if;
    if _price is not null then
        update product
        SET price     = _price,
            updatedat = (now() AT TIME ZONE 'Asia/Amman'::text),
            updatedby = 'Moayyad'
        where id = _id;
    end if;
    if _is_deleted is not null then
        update product
        SET isdeleted = _is_deleted,
            updatedat = (now() AT TIME ZONE 'Asia/Amman'::text),
            updatedby = 'Moayyad'
        where id = _id;
    end if;
    if _branchprice is not null then
        update product
        SET branchprice = _branchprice,
            updatedat   = (now() AT TIME ZONE 'Asia/Amman'::text),
            updatedby   = 'Moayyad'
        where id = _id;
    end if;
    if _is_deleted is not null then
        update product
        SET isdeleted   = _is_deleted,
            ispublished = Not _is_deleted,
            updatedat   = (now() AT TIME ZONE 'Asia/Amman'::text),
            updatedby   = 'Moayyad'
        where id = _id;
    end if;
    if _imagepath is not null then
        update product
        SET imagepath = _imagepath,
            updatedat = (now() AT TIME ZONE 'Asia/Amman'::text),
            updatedby = 'Moayyad'
        where id = _id;
    end if;
end;
$$;


--
-- Name: updateisseen(uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updateisseen(IN _orderid uuid)
    LANGUAGE plpgsql
    AS $$
begin 
UPDATE "order"
	SET  isseen = (now() AT TIME ZONE 'Asia/Amman'::text)::date
	WHERE id = _orderid;
	END;
$$;


--
-- Name: updatelanguageresource(uuid, public.citext, uuid, public.citext, public.citext, uuid, integer, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatelanguageresource(IN _id uuid, IN _languagecode public.citext DEFAULT NULL::public.citext, IN _languageid uuid DEFAULT NULL::uuid, IN _key public.citext DEFAULT NULL::public.citext, IN _value public.citext DEFAULT NULL::public.citext, IN _objectid uuid DEFAULT NULL::uuid, IN _type integer DEFAULT NULL::integer, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select ispublished from languageresource where id = _id) = true) and ((select isdeleted from languageresource where id = _id) = false)) then 
if _languagecode is not null then update languageresource SET languagecode = _languagecode , languageid = getlanguageid(_languagecode) , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _languageid is not null then update languageresource SET languageid = _languageid, languagecode = (select languagecode from language where id = _languageid )  , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _key is not null then update languageresource SET key = _key , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _value is not null then update languageresource SET value = _value , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _objectid is not null then update languageresource SET objectid = _objectid , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _type is not null then update languageresource SET type = _type , updatedat = now(), updatedby = _updatedby where id = _id; end if;
end if;
END;
$$;


--
-- Name: updatemenu(uuid, uuid[], uuid[], uuid[], public.citext, boolean, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatemenu(IN _id uuid, IN _productids uuid[], IN _channelids uuid[], IN _branchids uuid[], IN _name public.citext DEFAULT NULL::public.citext, IN _isavailable boolean DEFAULT NULL::boolean, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
declare pid uuid ;
declare cid uuid;
begin
--updating name (CHECK IF NAME IS NOT NULL)
if _name is not null then update menu SET name = _name , updatedat = now(), updatedby = _updatedby where menu.id = _id; end if;

--updating isavailable (CHECK IF isavailable IS NOT NULL)
if _isavailable is not null then update menu SET isavailable = _isavailable , updatedat = now(), updatedby = _updatedby where menu.id = _id; end if;

--updating menu for selected branches
--update branch set menuid = null where menuid = _id  ;
if  (select ((select id from namelookup where tabletype = 'ordersource' and name = 'callcenter')  = any(_channelids)))
    then
        update branch set menuid = null where branch.menuid = _id;
update branch set menuid  = _id where branch.id = any(_branchids);
end if;
-- deleting all product
delete from menuproduct where menuid = _id;
-- inserting all products
FOREACH pid IN ARRAY _productids LOOP
	INSERT INTO menuproduct(menuid, productid,createdby) VALUES (_id, pid, _updatedby);
   END LOOP;

delete from menucategories where menuid = _id;

foreach cid in  array (select array_agg(distinct categoryid )from product where id = any(_productids))loop
    insert into menucategories (menuid, categoryid) values (_id,cid);
end loop;

   delete from menuchannel where menuid = _id;
   FOREACH pid IN ARRAY _channelids LOOP
     FOREACH cid IN ARRAY _branchids LOOP
       insert into menuchannel values (_id ,pid,cid);
      END LOOP;
   END LOOP;

   FOREACH pid IN ARRAY _channelids LOOP
       update menuintegratiosync SET issync = false WHERE channelid = pid and menuid = _id;
   END LOOP;

end;
$$;


--
-- Name: updatemenuavailability(uuid, boolean, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatemenuavailability(IN _id uuid, IN _isavailable boolean, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select ispublished from menu where id = _id) = true) and ((select isdeleted from menu where id = _id) = false)) then 
if _isavailable is not null then update menu SET isavailable = _isavailable , updatedat = now(), updatedby = _updatedby where id = _id; end if;
end if ;
END;
$$;


--
-- Name: updatemenuintegrationsync(uuid, uuid, boolean, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatemenuintegrationsync(IN _menuid uuid, IN _channelid uuid, IN _issync boolean, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin
IF((Select nlk.name from namelookup nlk WHERE nlk.id = _channelid and nlk.tabletype ='ordersource') != 'callcenter')
THEN
delete from menuintegratiosync mis
WHERE mis.channelid NOT IN (
   SELECT mc.channelid
   FROM menuchannel mc WHERE mc.menuid = _menuid 
   );

IF((select count(mis.*) from menuintegratiosync mis where mis.menuid =_menuid and mis.channelid = _channelid) > 0)
THEN
update menuintegratiosync SET issync = coalesce(_issync, false), updatedat = now(), updatedby = _updatedby where menuid=_menuid and channelid =_channelid ;
    ELSE
    INSERT INTO menuintegratiosync (menuid, channelid, issync, createdat, createdby)
			  VALUES (_menuid,_channelid,_issync,now(),_updatedby);
end if;

END IF;
END;
$$;


--
-- Name: updatemenuintegrationtalabatsync(uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatemenuintegrationtalabatsync(IN _companyid uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
begin
update menuintegratiosync
set  issync= true
    where menuid in (select id from menu where companyid = _companyid)
    and channelid= (select id from getchannelsformenu() where name like 'talabat');
END;
$$;


--
-- Name: updatemenuproduct(uuid, uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatemenuproduct(IN _menuid uuid, IN _productid uuid, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select ispublished from menuproduct where menuid = _menuid) = true) and ((select isdeleted from menuproduct where menuid = _menuid) = false)) then 
if _productid is not null then update menuproduct SET productid = _productid , updatedat = now(), updatedby = _updatedby where menuid = _menuid; end if;
END if;
end;
$$;


--
-- Name: updatemenurequestlog(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatemenurequestlog(IN _id uuid, IN _response public.citext)
    LANGUAGE plpgsql
    AS $$

begin
    update menurequestlog
    set response = _response, responsetime = now()
    where id = _id;
END;
$$;


--
-- Name: updatenamelookup(uuid, public.citext, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatenamelookup(IN _id uuid, IN _name public.citext DEFAULT NULL::public.citext, IN _type public.citext DEFAULT NULL::public.citext, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select ispublished from namelookup where id = _id) = true) and ((select isdeleted from namelookup where id = _id) = false)) then 
if _name is not null then update namelookup SET name = _name , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _type is not null then update namelookup SET tabletype = _type , updatedat = now(), updatedby = _updatedby where id = _id; end if;
end if;
END;
$$;


--
-- Name: updatenotification(uuid, text, integer, uuid[], timestamp without time zone, timestamp without time zone, boolean, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatenotification(IN _id uuid, IN _subject text, IN _priority integer, IN _branchid uuid[], IN _startdate timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _starttime timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _urgent boolean DEFAULT false, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if _subject is not null then update notification SET subject = _subject , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _priority is not null then update notification SET priority = _priority , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _startdate is not null then update notification SET startdate = _startdate , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _starttime is not null then update notification SET starttime = _starttime , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _urgent is not null then update notification SET urgent = _urgent , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _branchid is not null then update notificationfollowup SET branchid = _branchid where notificationid = _id; end if;

END;
$$;


--
-- Name: updateoffer(uuid, integer, uuid, uuid, uuid[], uuid[], timestamp without time zone, timestamp without time zone, timestamp without time zone, timestamp without time zone, integer[], integer, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updateoffer(IN _id uuid, IN _offertype integer DEFAULT NULL::integer, IN _categoryid uuid DEFAULT NULL::uuid, IN _productid uuid DEFAULT NULL::uuid, IN _branchids uuid[] DEFAULT NULL::uuid[], IN _channelids uuid[] DEFAULT NULL::uuid[], IN _fromdate timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _todate timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _fromtime timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _totime timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _daysofweek integer[] DEFAULT NULL::integer[], IN _priority integer DEFAULT NULL::integer, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select ispublished from offer where id = _id) = true) and ((select isdeleted from offer where id = _id) = false)) then 
if _offertype is not null then update offer SET offertype = _offertype , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _categoryid is not null then update offer SET categoryid = _categoryid , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _productid is not null then update offer SET productid = _productid , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _branchids is not null then update offer SET branchids = _branchids , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _channelids is not null then update offer SET channelids = _channelids , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _fromdate is not null then update offer SET fromdate = _fromdate , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _todate is not null then update offer SET todate = _todate , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _fromtime is not null then update offer SET fromtime = _fromtime , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _totime is not null then update offer SET totime = _totime , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _daysofweek is not null then update offer SET daysofweek = _daysofweek , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _priority is not null then update offer SET priority = _priority , updatedat = now(), updatedby = _updatedby where id = _id; end if;

END if;
end;
$$;


--
-- Name: updateofferaction(uuid, integer, uuid, uuid, integer[], uuid, numeric, boolean, numeric, numeric, numeric, integer, integer, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updateofferaction(IN _id uuid, IN _quantity integer DEFAULT NULL::integer, IN _categoryid uuid DEFAULT NULL::uuid, IN _productid uuid DEFAULT NULL::uuid, IN _attributes integer[] DEFAULT NULL::integer[], IN _offerid uuid DEFAULT NULL::uuid, IN _newprice numeric DEFAULT NULL::numeric, IN _ispercentage boolean DEFAULT false, IN _discountvalue numeric DEFAULT NULL::numeric, IN _maxdiscountprice numeric DEFAULT NULL::numeric, IN _mindiscountprice numeric DEFAULT NULL::numeric, IN _maxdiscountquantity integer DEFAULT NULL::integer, IN _mindiscountquantity integer DEFAULT NULL::integer, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select ispublished from offeraction where id = _id) = true) and ((select isdeleted from offeraction where id = _id) = false)) then 
if _quantity is not null then update offeraction SET quantity = _quantity , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _categoryid is not null then update offeraction SET categoryid = _categoryid , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _productid is not null then update offeraction SET productid = _productid , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _attributes is not null then update offeraction SET attributes = _attributes , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _offerid is not null then update offeraction SET offerid = _offerid , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _newprice is not null then update offeraction SET newprice = _newprice , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _ispercentage is not null then update offeraction SET ispercentage = _ispercentage , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _discountvalue is not null then update offeraction SET discountvalue = _discountvalue , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _maxdiscountprice is not null then update offeraction SET maxdiscountprice = _maxdiscountprice , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _mindiscountprice is not null then update offeraction SET mindiscountprice = _mindiscountprice , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _maxdiscountquantity is not null then update offeraction SET maxdiscountquantity = _maxdiscountquantity , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _mindiscountquantity is not null then update offeraction SET mindiscountquantity = _mindiscountquantity , updatedat = now(), updatedby = _updatedby where id = _id; end if;

END if;
end;
$$;


--
-- Name: updateoption(uuid, public.citext, public.citext, uuid, uuid, integer, jsonb, boolean, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updateoption(IN _id uuid, IN _languagecode public.citext, IN _name public.citext DEFAULT NULL::public.citext, IN _suboptionid uuid DEFAULT NULL::uuid, IN _attributeid uuid DEFAULT NULL::uuid, IN _quantity integer DEFAULT NULL::integer, IN _price jsonb DEFAULT NULL::jsonb, IN _ispreselected boolean DEFAULT NULL::boolean, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select ispublished from option where id = _id) = true) and ((select isdeleted from option where id = _id) = false)) then 
if _suboptionid is not null then update option SET suboptionid = _suboptionid , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _attributeid is not null then update option SET attributeid = _attributeid , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _quantity is not null then update option SET quantity = _quantity , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _price is not null then update option SET price = _price , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _ispreselected is not null then update option SET ispreselected = _ispreselected , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _name is not null then call createlanguageresource('optionName' , _name , _id , _languagecode ,1 , _updatedby) ; end if;
END if;
end;
$$;


--
-- Name: updateorder(uuid, public.citext, uuid, timestamp without time zone, uuid, uuid, uuid, public.citext, numeric, numeric, public.citext, numeric, public.citext, public.citext, public.citext, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updateorder(IN _id uuid, IN _branchorderid public.citext DEFAULT NULL::public.citext, IN _ordersource uuid DEFAULT NULL::uuid, IN _scheduled timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _deliverytype uuid DEFAULT NULL::uuid, IN _customerid uuid DEFAULT NULL::uuid, IN _branchid uuid DEFAULT NULL::uuid, IN _notes public.citext DEFAULT NULL::public.citext, IN _totalprice numeric DEFAULT NULL::numeric, IN _deliveryprice numeric DEFAULT NULL::numeric, IN _deliveryaddress public.citext DEFAULT NULL::public.citext, IN _subtotalprice numeric DEFAULT NULL::numeric, IN _referencenumber public.citext DEFAULT NULL::public.citext, IN _totalpreparingtime public.citext DEFAULT NULL::public.citext, IN _deliverystatus public.citext DEFAULT NULL::public.citext, IN _paymenttype public.citext DEFAULT NULL::public.citext, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select ispublished from "order" where id = _id) = true) and ((select isdeleted from "order" where id = _id) = false)) then 
if _branchorderid is not null then update "order" SET branchorderid = _branchorderid , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _ordersource is not null then update "order" SET ordersource = _ordersource , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _scheduled is not null then update "order" SET scheduled = _scheduled , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _deliverytype is not null then update "order" SET deliverytype = _deliverytype , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _customerid is not null then update "order" SET customerid = _customerid , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _branchid is not null then update "order" SET branchid = _branchid , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _notes is not null then update "order" SET notes = _notes , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _totalprice is not null then update "order" SET totalprice = _totalprice , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _deliveryprice is not null then update "order" SET deliveryprice = _deliveryprice , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _deliveryaddress is not null then update "order" SET deliveryaddress = _deliveryaddress , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _subtotalprice is not null then update "order" SET subtotalprice = _subtotalprice , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _referencenumber is not null then update "order" SET referencenumber = _referencenumber , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _totalpreparingtime is not null then update "order" SET totalpreparingtime = _totalpreparingtime , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _deliverystatus is not null then update "order" SET deliverystatus = _deliverystatus , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _paymenttype is not null then update "order" SET paymenttype = _paymenttype , updatedat = now(), updatedby = _updatedby where id = _id; end if;
END if;
end;
$$;


--
-- Name: updateorderbytalabat(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updateorderbytalabat(IN _id uuid, IN _talabatorderid public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
update "order" SET referencenumber = _talabatorderid  where id = _id;
end;
$$;


--
-- Name: updateordercurrentstatus(uuid, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updateordercurrentstatus(IN _id uuid, IN _status public.citext, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select ispublished from "order" where id = _id) = true) and ((select isdeleted from "order" where id = _id) = false)) then 
if _status is not null then 
update "order" SET currentstatus = _status , updatedat = now(), updatedby = _updatedby where id = _id; 
INSERT INTO  orderhistory (id,status,createdat,createdby) VALUES (_id,_status,now(),_updatedby); end if;
END if;
end;
$$;


--
-- Name: updateorderdeliverystatus(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updateorderdeliverystatus(IN _orderid uuid, IN _deliverystatus public.citext)
    LANGUAGE plpgsql
    AS $$
begin
    update "order"
    set deliverystatus = _deliverystatus
    where id = _orderid;
END;
$$;


--
-- Name: updateorderfollowup(uuid, uuid, public.citext, public.citext, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updateorderfollowup(IN _orderid uuid, IN _customerid uuid, IN _status public.citext, IN _complaincategory public.citext DEFAULT NULL::public.citext, IN _complainsubcategory public.citext DEFAULT NULL::public.citext, IN _updatedby public.citext DEFAULT 'system'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select ispublished from "orderfollowup" where id = _orderid) = true) and ((select isdeleted from "orderfollowup" where id = _orderid) = false)) then 
if _complaincategory is not null then update "orderfollowup" SET category = _complaincategory , updatedat = now(), updatedby = _updatedby where id = _orderid; end if;
if _complainsubcategory is not null then update "orderfollowup" SET subcategory = _complainsubcategory , updatedat = now(), updatedby = _updatedby where id = _orderid; end if;
if _status is not null then update "orderfollowup" SET status = _status , updatedat = now(), updatedby = _updatedby where id = _orderid; end if;

END if;
end;
$$;


--
-- Name: updateorderfollowupdetails(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updateorderfollowupdetails(IN _orderid uuid, IN _adminnote public.citext DEFAULT 'system'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin
    update orderfollowupdetails set adminnote=_adminnote where orderid=_orderid;
end;
$$;


--
-- Name: updateorderreference(uuid, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updateorderreference(IN _id uuid, IN _key public.citext, IN _value public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
update "order" SET referencenumber = (select jsonupdateproperties(referencenumber::json,_key,_value)::jsonb ), updatedat = now() where id = _id;
end;
$$;


--
-- Name: updateorderstatuspossibilities(uuid, uuid, public.citext, uuid, boolean, boolean, public.citext, boolean, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updateorderstatuspossibilities(IN _id uuid, IN _branchid uuid DEFAULT NULL::uuid, IN _status public.citext DEFAULT NULL::public.citext, IN _nextstatus uuid DEFAULT NULL::uuid, IN _cancancel boolean DEFAULT NULL::boolean, IN _islaststatus boolean DEFAULT NULL::boolean, IN _color public.citext DEFAULT 'gray'::public.citext, IN _first boolean DEFAULT NULL::boolean, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select ispublished from orderstatuspossibilities where id = _id) = true) and ((select isdeleted from orderstatuspossibilities where id = _id) = false)) then 
if _branchid is not null then update orderstatuspossibilities SET branchid = _branchid , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _status is not null then update orderstatuspossibilities SET status = _status , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _nextstatus is not null then update orderstatuspossibilities SET nextstatus = _nextstatus , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _cancancel is not null then update orderstatuspossibilities SET cancancel = _cancancel , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _islaststatus is not null then update orderstatuspossibilities SET islaststatus = _islaststatus , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _color is not null then update orderstatuspossibilities SET color = _color , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _first is not null then update orderstatuspossibilities SET isfirststatus = _first , updatedat = now(), updatedby = _updatedby where id = _id; end if;

END if;
END;
$$;


--
-- Name: updateotpcode(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updateotpcode(IN _id uuid, IN _code public.citext DEFAULT NULL::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
 UPDATE customer set verifycode = _code where id = _id;		
END;
$$;


--
-- Name: updatepaymentcredentials(uuid, public.citext, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatepaymentcredentials(IN _id uuid, IN _marchent public.citext, IN _username public.citext, IN _password public.citext)
    LANGUAGE plpgsql
    AS $$
begin
if((select count(*) from restaurantpaymentcredentials where rid =_id ) > 0) 
then 
if _marchent is not null then update "restaurantpaymentcredentials" SET marchent = _marchent  where rid = _id; end if;
if _username is not null then update "restaurantpaymentcredentials" SET username = _username  where rid = _id; end if;
if _password is not null then update "restaurantpaymentcredentials" SET password = _password  where rid = _id; end if;

else
INSERT INTO restaurantpaymentcredentials(rid,marchent,username,password,marchentname)
	VALUES (_id,_marchent,_username,_password,(select name from company where id =_id));
	
end if;
end;
$$;


--
-- Name: updatepaymentrequestlog(uuid, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatepaymentrequestlog(IN _id uuid, IN _checkoutid public.citext, IN _holdorderid uuid)
    LANGUAGE plpgsql
    AS $$
begin
    update paymentrequestlog set checkoutid = _checkoutid, holdorderid = _holdorderid, reponsetime = now() where id = _id;
END;
$$;


--
-- Name: updateprinterbranch(uuid, jsonb, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updateprinterbranch(IN _id uuid, IN _delay jsonb DEFAULT NULL::jsonb, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
--USE
if (((select ispublished from branch where id = _id) = true) and ((select isdeleted from branch where id = _id) = false)) then 
if _delay is not null then update branch SET delay = _delay , updatedat = now(), updatedby = _updatedby where id = _id; end if;
END if;
END;
$$;


--
-- Name: updateprinterrequestlog(uuid, public.citext, public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updateprinterrequestlog(IN _id uuid, IN _response public.citext, IN _printingtype public.citext, IN _template public.citext)
    LANGUAGE plpgsql
    AS $$
DECLARE templ citext;
begin

--USE
UPDATE orderprint SET isdeleted = true where jobid = _id ;

END;
$$;


--
-- Name: updateprinters(uuid, uuid[], uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updateprinters(IN _id uuid, IN _categoryids uuid[], IN _branchid uuid, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 

--use
update printers SET categoryids = _categoryids ,branchid= _branchid,updatedat = now(), updatedby = _updatedby where id = _id;
end;
$$;


--
-- Name: updateprintingorder(uuid, public.citext[], public.citext[]); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updateprintingorder(IN _jobid uuid, IN _printername public.citext[] DEFAULT NULL::public.citext[], IN _old public.citext[] DEFAULT NULL::public.citext[])
    LANGUAGE plpgsql
    AS $$
begin 
--USE
if _printername is not null then update printingorder SET printername = ARRAY_CAT(_old, _printername) where id = _jobid; end if;
if _printername is not null then update printingorderlogs SET printing = true where id = _jobid; end if;
if _printername is not null then update printingorder SET printername = ARRAY_CAT(_old, _printername) where id = _jobid; end if;
if _printername is not null then update printingorder SET printing = true where id = _jobid; end if;
if _jobid is not null then update printlogs SET isprint = true where orderid = _jobid; end if;
end;
$$;


--
-- Name: updateproduct(uuid, public.citext, uuid, public.citext, public.citext, jsonb, jsonb, public.citext, jsonb, jsonb, boolean, boolean, boolean, boolean, integer, integer, integer, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updateproduct(IN _id uuid, IN _languagecode public.citext DEFAULT 'en'::public.citext, IN _categoryid uuid DEFAULT NULL::uuid, IN _imagepath public.citext DEFAULT NULL::public.citext, IN _thumbimage public.citext DEFAULT NULL::public.citext, IN _name jsonb DEFAULT NULL::jsonb, IN _shortdescription jsonb DEFAULT NULL::jsonb, IN _sku public.citext DEFAULT NULL::public.citext, IN _producttags jsonb DEFAULT NULL::jsonb, IN _fulldescription jsonb DEFAULT NULL::jsonb, IN _isavailable boolean DEFAULT NULL::boolean, IN _ispublished boolean DEFAULT NULL::boolean, IN _isoffer boolean DEFAULT NULL::boolean, IN _istopselling boolean DEFAULT NULL::boolean, IN _hour integer DEFAULT NULL::integer, IN _min integer DEFAULT NULL::integer, IN _displaynumber integer DEFAULT 1, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$

begin
if (((select isdeleted from product where id = _id) = false)) then
if _categoryid is not null then update product SET categoryid = _categoryid , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _imagepath is not null then update product SET imagepath = _imagepath , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _thumbimage is not null then update product SET thumbimage = _thumbimage , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _name is not null then update product SET name = _name , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _shortdescription is not null then update product SET shortdescription = _shortdescription , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _sku is not null then update product SET sku = _sku , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _producttags is not null then update product SET producttags = _producttags , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _fulldescription is not null then update product SET fulldescription = _fulldescription , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _isavailable is not null then update product SET isavailable = _isavailable , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _displaynumber is not null then update product SET displaynumber = _displaynumber , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _ispublished is not null then update product SET ispublished = _ispublished , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _isoffer is not null then update product SET isoffer = _isoffer, updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _istopselling is not null then update product SET istopselling = _istopselling, updatedat = now(), updatedby = _updatedby where id = _id; end if;

END if;
end;
$$;


--
-- Name: updateproductattribute(uuid, public.citext, public.citext, integer, integer, boolean, boolean, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updateproductattribute(IN _id uuid, IN _languagecode public.citext, IN _name public.citext DEFAULT NULL::public.citext, IN _controltype integer DEFAULT NULL::integer, IN _noofselection integer DEFAULT NULL::integer, IN _isrequired boolean DEFAULT NULL::boolean, IN _istrackable boolean DEFAULT NULL::boolean, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select ispublished from productattribute where id = _id) = true) and ((select isdeleted from productattribute where id = _id) = false)) then 
if _controltype is not null then update productattribute SET controltype = _controltype , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _noofselection is not null then update productattribute SET noofselection = _noofselection , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _isrequired is not null then update productattribute SET isrequired = _isrequired , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _istrackable is not null then update productattribute SET istrackable = _istrackable , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _name is not null then call createlanguageresource('productattributeName' , _name , _id , _languagecode ,1 , _updatedby) ; end if;
END IF;
end;
$$;


--
-- Name: updateproductavailability(uuid, public.citext, uuid[], uuid[], uuid[], jsonb, uuid[], timestamp without time zone, timestamp without time zone, timestamp without time zone, timestamp without time zone, integer[], boolean, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updateproductavailability(IN _id uuid, IN _name public.citext DEFAULT NULL::public.citext, IN _productids uuid[] DEFAULT NULL::uuid[], IN _categoryids uuid[] DEFAULT NULL::uuid[], IN _channelids uuid[] DEFAULT NULL::uuid[], IN _beneficiarycategory jsonb DEFAULT NULL::jsonb, IN _attributeids uuid[] DEFAULT NULL::uuid[], IN _fromtime timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _totime timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _fromdate timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _todate timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _daysofweek integer[] DEFAULT NULL::integer[], IN _isavailable boolean DEFAULT NULL::boolean, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select ispublished from productavailability where id = _id) = true) and ((select isdeleted from productavailability where id = _id) = false)) then 
if _productids is not null then update productavailability SET productids = _productids , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _name is not null then update productavailability SET name = _name , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _categoryids is not null then update productavailability SET categoryids = _categoryids , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _channelids is not null then update productavailability SET channelids = _channelids , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _beneficiarycategory is not null then update productavailability SET beneficiary = _beneficiarycategory , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _attributeids is not null then update productavailability SET attributeids = _attributeids , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _fromtime is not null then update productavailability SET fromtime = _fromtime , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _totime is not null then update productavailability SET totime = _totime , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _fromdate is not null then update productavailability SET fromdate = _fromdate , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _todate is not null then update productavailability SET todate = _todate , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _daysofweek is not null then update productavailability SET daysofweek = _daysofweek , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _isavailable is not null then update productavailability SET isavailable = _isavailable , updatedat = now(), updatedby = _updatedby where id = _id; end if;
END if;
end;
$$;


--
-- Name: updateproductimages(uuid, public.citext, uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updateproductimages(IN _id uuid, IN _imagepath public.citext DEFAULT NULL::public.citext, IN _productid uuid DEFAULT NULL::uuid, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select ispublished from productimages where id = _id) = true) and ((select isdeleted from productimages where id = _id) = false)) then 
if _imagepath is not null then update productimages SET imagepath = _imagepath , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _productid is not null then update productimages SET productid = _productid , updatedat = now(), updatedby = _updatedby where id = _id; end if;
END if;
end;
$$;


--
-- Name: updateproductprice(uuid, jsonb); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updateproductprice(IN _productid uuid, IN _price jsonb)
    LANGUAGE plpgsql
    AS $$
begin 
UPDATE product
	SET  price = _price
	WHERE id = _productid;
	END;
$$;


--
-- Name: updatepromocode(uuid, public.citext, public.citext, uuid[], uuid[], uuid[], uuid[], numeric, integer, numeric, numeric, integer, boolean, timestamp without time zone, timestamp without time zone, integer[], public.citext, public.citext, boolean, integer, integer, jsonb); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatepromocode(IN _id uuid, IN _name public.citext DEFAULT NULL::public.citext, IN _type public.citext DEFAULT NULL::public.citext, IN _categoryids uuid[] DEFAULT NULL::uuid[], IN _channelids uuid[] DEFAULT NULL::uuid[], IN _branchids uuid[] DEFAULT NULL::uuid[], IN _customerids uuid[] DEFAULT NULL::uuid[], IN _value numeric DEFAULT NULL::numeric, IN _minquantity integer DEFAULT NULL::integer, IN _maxvalue numeric DEFAULT NULL::integer, IN _minprice numeric DEFAULT NULL::integer, IN _priority integer DEFAULT NULL::integer, IN _ispercentage boolean DEFAULT NULL::boolean, IN _availablefrom timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _availableto timestamp without time zone DEFAULT NULL::timestamp without time zone, IN _daysofweek integer[] DEFAULT NULL::integer[], IN _description public.citext DEFAULT NULL::public.citext, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext, IN _isdaily boolean DEFAULT false, IN _numberofusecustomer integer DEFAULT NULL::integer, IN _numberofuse integer DEFAULT NULL::integer, IN _descriptionlanguage jsonb DEFAULT NULL::jsonb)
    LANGUAGE plpgsql
    AS $$
declare cid uuid;
declare brid uuid;
declare chid uuid;
declare cus uuid;
begin 
if _name is not null then update promocode SET name = _name , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _type is not null then update promocode SET type = _type , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _value is not null then update promocode SET value = _value , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _minquantity is not null then update promocode SET minquantity = _minquantity , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _maxvalue is not null then update promocode SET maxvalue = _maxvalue , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _minprice is not null then update promocode SET minprice = _minprice , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _priority is not null then update promocode SET priority = _priority , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _ispercentage is not null then update promocode SET ispercentage = _ispercentage , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _availablefrom is not null then update promocode SET availablefrom = _availablefrom , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _availableto is not null then update promocode SET availableto = _availableto , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _description is not null then update promocode SET description = _description , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _daysofweek is not null then update promocode SET daysofweek = _daysofweek , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _isdaily is not null then update promocode SET isdaily = _isdaily , updatedat = now(), updatedby = _updatedby where id = _id; end if;

if _numberofusecustomer is not null then update promocode SET numberofusecustomer = _numberofusecustomer , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _numberofuse is not null then update promocode SET numberofuse = _numberofuse , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _descriptionlanguage is not null then update promocode SET descriptionlanguage = _descriptionlanguage , updatedat = now(), updatedby = _updatedby where id = _id; end if;

if _branchids is not null 
  then
     delete from promocodebranch where promocodeid = _id;
     foreach brid in array _branchids loop
           INSERT INTO public.promocodebranch(branchid,promocodeid)
	       VALUES(brid,_id);
        end loop; 
end if;

if _channelids is not null
   then 
       delete from promocodechannel where promocodeid = _id;
       foreach chid in array _channelids loop
           INSERT INTO public.promocodechannel(channelid,promocodeid)
	       VALUES(chid,_id);
        end loop; 
end if;

if _categoryids is not null
   then 
       delete from promocodecategory where promocodeid = _id;
       foreach cid in array _categoryids loop
           INSERT INTO public.promocodecategory(categoryid,promocodeid)
	       VALUES(cid,_id);
        end loop;
end if;

if _customerids is null 
    then
    delete from promocodecustomers where promocodeid = _id;
end if ;

if _customerids is not null
   then 
       delete from promocodecustomers where promocodeid = _id;
       foreach cus in array _customerids loop
           INSERT INTO public.promocodecustomers(customerid,promocodeid)
	       VALUES(cus,_id);
        end loop; 
   else
     delete from promocodecustomers where promocodeid = _id;
end if ;

end;
$$;


--
-- Name: updatepromocodeuse(uuid, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatepromocodeuse(IN _id uuid, IN _customerid uuid)
    LANGUAGE plpgsql
    AS $$
begin 





if _id is not null then update promocode SET numberofusage = ((select numberofusage from promocode where id = _id )+1) where id = _id; end if;


if _customerid is not null then update promocodecustomers SET lastusetime = (now() + interval '3 hour') where promocodeid = _id and customerid = _customerid; end if;


if _customerid is not null then update promocodecustomers SET numberofusage = ((select numberofusage from promocodecustomers where promocodeid = _id and customerid = _customerid)+1) where promocodeid = _id and customerid = _customerid; end if;




end;
$$;


--
-- Name: updaterequestlog(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updaterequestlog(IN _id uuid, IN _response public.citext)
    LANGUAGE plpgsql
    AS $$
begin
    update RequestLog
    set response = _response, responsetime = now()
    where id = _id;
END;
$$;


--
-- Name: updaterestaurantparams(uuid, integer, integer, integer, numeric); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updaterestaurantparams(IN _companyid uuid, IN _period integer, IN _loyalityperiod integer, IN _loyalitycount integer, IN _loyalityamount numeric)
    LANGUAGE plpgsql
    AS $$
declare
begin
    update restaurantparams set period         = _period,
                                loyalityperiod = _loyalityperiod,
                                loyalitycount  = _loyalitycount,
                                loyalityamount = _loyalityamount
    where restaurantid = _companyid;
end;
$$;


--
-- Name: updaterlookup(uuid, bigint, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updaterlookup(IN _rid uuid, IN _sid bigint, IN _rname public.citext)
    LANGUAGE plpgsql
    AS $$
begin
    update rlookup set rname = _rname where rid=_rid and sid=_sid;
end;
$$;


--
-- Name: updateservicesusebalance(uuid, uuid, integer); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updateservicesusebalance(IN _companyid uuid, IN _serviceid uuid, IN _value integer)
    LANGUAGE plpgsql
    AS $$
begin
   if((select count(cs.companyid) from companyservices cs where cs.companyid =_companyid and serviceid = _serviceid ) > 0)
    THEN
    update companyservices set availablebalance = ((SELECT cs.availablebalance FROM companyservices cs where cs.companyid =_companyid and serviceid = _serviceid)-_value), updatedat = now() where companyid = _companyid and serviceid = _serviceid;
    END IF;
end;
$$;


--
-- Name: updatetalabatorderdeliverystatus(public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatetalabatorderdeliverystatus(IN _talabatorderid public.citext, IN _deliverystatus public.citext)
    LANGUAGE plpgsql
    AS $$
begin
    update "order"
    set deliverystatus = _deliverystatus
    where referencenumber->>'Talabatdelivery'= _talabatorderid;
END;
$$;


--
-- Name: updatetax(uuid, numeric, public.citext, uuid, uuid, uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatetax(IN _id uuid, IN _value numeric DEFAULT NULL::numeric, IN _name public.citext DEFAULT NULL::public.citext, IN _taxcategoryid uuid DEFAULT NULL::uuid, IN _countryid uuid DEFAULT NULL::uuid, IN _cityid uuid DEFAULT NULL::uuid, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select ispublished from tax where id = _id) = true) and ((select isdeleted from tax where id = _id) = false)) then 
if _value is not null then update tax SET value = _value , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _name is not null then update tax SET name = _name , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _taxcategoryid is not null then update tax SET taxcategoryid = _taxcategoryid , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _countryid is not null then update tax SET countryid = _countryid , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _cityid is not null then update tax SET cityid = _cityid , updatedat = now(), updatedby = _updatedby where id = _id; end if;
end if ;
END;
$$;


--
-- Name: updatetaxcategory(uuid, public.citext, uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatetaxcategory(IN _id uuid, IN _name public.citext DEFAULT NULL::public.citext, IN _companyid uuid DEFAULT NULL::uuid, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select ispublished from taxcategory where id = _id) = true) and ((select isdeleted from taxcategory where id = _id) = false)) then 
if _name is not null then update taxcategory SET name = _name , updatedat = now(), updatedby = _updatedby where id = _id; end if;
if _companyid is not null then update taxcategory SET companyid = _companyid , updatedat = now(), updatedby = _updatedby where id = _id; end if;
end if ;
END;
$$;


--
-- Name: updatetoverifycsutomer(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatetoverifycsutomer(IN _id uuid, IN _code public.citext DEFAULT NULL::public.citext)
    LANGUAGE plpgsql
    AS $$
begin  
if (((select ispublished from "customer" where id = _id) = true) and ((select isdeleted from "customer" where id = _id) = false)) then 
if _code is not null then update
    "customer" SET 
                   updatedat = (now() AT TIME ZONE 'Asia/Amman'::text),
                   verifycodetime = (now() AT TIME ZONE 'Asia/Amman'::text),
                   verifycode = _code,
                   updatedby = 'mobile' where "customer".id =_id;
end if;
END if;
end;
$$;


--
-- Name: updatetoverifycsutomer_ai(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatetoverifycsutomer_ai(IN _id uuid, IN _code public.citext DEFAULT NULL::public.citext)
    LANGUAGE plpgsql
    AS $$
begin  
if (((select ispublished from "customer" where id = _id) = true) and ((select isdeleted from "customer" where id = _id) = false)) then 
if _code is not null then update "customer" SET verifycode = _code , updatedat = now(), updatedby = 'MobileApp' where "customer".id =_id; end if;
END if;
end;
$$;


--
-- Name: updatetransferbranch(uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatetransferbranch(IN _id uuid, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
update transferbranch SET isactive = false, updatedat = now(), updatedby = _updatedby where branchidselected = _id;

END;
$$;


--
-- Name: updatevisibility(uuid, public.citext, boolean, boolean, boolean, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatevisibility(IN _id uuid, IN _ordercase public.citext, IN _isagent boolean DEFAULT NULL::boolean, IN _isteamleader boolean DEFAULT NULL::boolean, IN _isbranch boolean DEFAULT NULL::boolean, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if (((select ispublished from orderfollowup where id = _id and ordercase = _ordercase) = true) and ((select isdeleted from orderfollowup where id = _id and ordercase = _ordercase) = false)) then 
if _isagent is not null then update orderfollowup SET isagent = _isagent , updatedat = now(), updatedby = _updatedby where id = _id and ordercase = _ordercase; end if;
if _isteamleader is not null then update orderfollowup SET isteamleader = _isteamleader , updatedat = now(), updatedby = _updatedby where id = _id and ordercase = _ordercase; end if;
if _isbranch is not null then update orderfollowup SET isbranch = _isbranch , updatedat = now(), updatedby = _updatedby where id = _id and ordercase = _ordercase; end if;
END if;
end;
$$;


--
-- Name: updatewaapilogs(jsonb, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatewaapilogs(IN _response jsonb, IN _sessionid uuid)
    LANGUAGE plpgsql
    AS $$
begin
UPDATE waapilogs SET response = _response WHERE id = _sessionid;
end;
$$;


--
-- Name: updatewhatsapptemplatestatus(public.citext, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.updatewhatsapptemplatestatus(IN _status public.citext, IN _whatsapptemplateid public.citext)
    LANGUAGE plpgsql
    AS $$
begin 

UPDATE whatsapptemplate SET status = _status WHERE whatsapptemplateid = _whatsapptemplateid;
			

END;
$$;


--
-- Name: uploadsound(uuid, public.citext, numeric, boolean); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.uploadsound(IN _branchid uuid, IN _sound public.citext, IN _volume numeric, IN _loops boolean)
    LANGUAGE plpgsql
    AS $$
begin 
delete from ordernotificationsettings where branchid = _branchid;
 INSERT INTO ordernotificationsettings (branchid,sound,volume,loop)
			  VALUES (_branchid,_sound,_volume,_loops);			

END;
$$;


--
-- Name: upsertelicashcustomer(public.citext, public.citext, public.citext); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.upsertelicashcustomer(_customername public.citext, _customerphonenumber public.citext, _customersource public.citext) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
DECLARE
    _id UUID;
BEGIN
    INSERT INTO elicashcustomers (customername, customerphonenumber, customersource, createdat)
    VALUES (_customername, _customerphonenumber, _customersource, now())
    ON CONFLICT (customerphonenumber) DO UPDATE SET customername   = _customername,
                                                    customersource = _customersource,
                                                    updatedat      = now()
    Returning id into _id;
    return _id;
END;
$$;


--
-- Name: upsertelicashoutgoingapilog(uuid, text, jsonb, jsonb, text, text, text, integer, jsonb); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.upsertelicashoutgoingapilog(_id uuid, _requesturl text, _headers jsonb, _requestbody jsonb, _customername text, _customerphonenumber text, _transactiontype text, _responsehttpcode integer, _responsebody jsonb) RETURNS uuid
    LANGUAGE plpgsql
    AS $$
BEGIN
    INSERT INTO elicashapilogs (
        id,
        requesturl,
        headers,
        requestbody,
        customername,
        customerphonenumber,
        transactiontype,
        responsehttpcode,
        responsebody
    )
    VALUES (
        _id,
        _requesturl,
        _headers,
        _requestbody,
        _customername,
        _customerphonenumber,
        _transactiontype,
        _responsehttpcode,
        _responsebody
    )
    ON CONFLICT (id) DO UPDATE SET
        requesturl          = _requesturl,
        headers             = _headers,
        requestbody         = _requestbody,
        customername        = _customername,
        customerphonenumber = _customerphonenumber,
        transactiontype     = _transactiontype,
        responsehttpcode    = _responsehttpcode,
        responsebody        = _responsebody;

    RETURN _id;
END;
$$;


--
-- Name: upsetattributeforintegration(uuid, uuid, jsonb, jsonb, boolean, boolean, boolean, uuid, public.citext, integer, boolean, boolean, public.citext, jsonb, uuid, public.citext, integer, integer, integer, boolean, boolean, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.upsetattributeforintegration(IN _attribute uuid DEFAULT NULL::uuid, IN _productid uuid DEFAULT NULL::uuid, IN _name jsonb DEFAULT NULL::jsonb, IN _description jsonb DEFAULT NULL::jsonb, IN _isrequired boolean DEFAULT NULL::boolean, IN _isalergy boolean DEFAULT NULL::boolean, IN _isavailable boolean DEFAULT NULL::boolean, IN _attributeid uuid DEFAULT NULL::uuid, IN _controltype public.citext DEFAULT NULL::public.citext, IN _priority integer DEFAULT NULL::integer, IN _ispreselected boolean DEFAULT NULL::boolean, IN _isglobal boolean DEFAULT NULL::boolean, IN _weight public.citext DEFAULT NULL::public.citext, IN _price jsonb DEFAULT NULL::jsonb, IN _companyid uuid DEFAULT NULL::uuid, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext, IN _noofselection integer DEFAULT NULL::integer, IN _minimumcount integer DEFAULT NULL::integer, IN _maximumcount integer DEFAULT NULL::integer, IN _ischatbotqestion boolean DEFAULT NULL::boolean, IN _is_deleted boolean DEFAULT NULL::boolean, IN _externalposid public.citext DEFAULT NULL::public.citext, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
begin 

if _attribute is not null then
call updateattributeforintegration(_attribute,_productid ,_name ,_description,_isrequired ,_isalergy ,_isavailable ,_attributeid ,_controltype ,_priority ,_ispreselected ,_isglobal ,_weight ,_price ,_companyid ,_updatedby ,_noofselection ,_minimumcount ,_maximumcount ,_ischatbotqestion
                                   ,_is_deleted,_externalposid );
_id = _attribute;
else
 INSERT INTO productattribute(price,attributeid,name,description,productid,isrequired,isalergy,isglobal,controltype,companyid,noofselection,priority,minimumcount,maximumcount,ischatbotquestion,createdby,isdeleted,external_pos_id)
                       VALUES(_price,_attributeid,_name,_description,_productid,_isrequired,_isalergy,_isglobal,_controltype,_companyid,_noofselection,_priority,_minimumcount,_maximumcount,_ischatbotqestion,_updatedby,_is_deleted,_externalposid)
                        returning  id into _id;
end if;
end;
$$;


--
-- Name: upsetproduct(jsonb, jsonb, jsonb, jsonb, jsonb, jsonb, public.citext, boolean, boolean, boolean, integer, integer, uuid, jsonb, public.citext, integer, public.citext, uuid, boolean, public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.upsetproduct(IN _name jsonb, IN _fulldescription jsonb, IN _shortdescription jsonb, IN _aliasname jsonb, IN _aliasdescription jsonb, IN _producttags jsonb, IN _sku public.citext, IN _isavailable boolean, IN _ispublished boolean, IN _isoffer boolean, IN _hour integer, IN _min integer, IN _categoryid uuid, IN _branchprice jsonb, IN _imagepath public.citext DEFAULT NULL::public.citext, IN _displaynumber integer DEFAULT 1, IN _createdby public.citext DEFAULT 'SYSTEM'::public.citext, IN _id uuid DEFAULT NULL::uuid, IN _is_deleted boolean DEFAULT false, IN _externalposid public.citext DEFAULT NULL::public.citext, INOUT _productid uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
begin
    if _id is not null then
        call updateishbekproduct(
                _id,
                _name,
                _shortdescription,
                _categoryid,
                NULL,
                _branchprice,
                _imagepath,
                _is_deleted,
                _aliasname,
                _aliasdescription,
                _externalposid
             );
        _productid = _id;
    else
        INSERT INTO product (name,
                             shortdescription,
                             fulldescription,
                             producttags,
                             sku,
                             isavailable,
                             ispublished,
                             isoffer,
                             hour,
                             min,
                             categoryid,
                             displaynumber,
                             imagepath,
                             createdby,
                             branchprice,
                             aliasname,
                             aliasdescription,
                             external_pos_id)
        VALUES (_name,
                _shortdescription,
                _fulldescription,
                _producttags,
                _sku,
                _isavailable,
                _ispublished,
                _isoffer,
                _hour,
                _min,
                _categoryid,
                _displaynumber,
                _imagepath,
                _createdby,
                _branchprice,
                _aliasname,
                _aliasdescription,
                _externalposid)
        returning id into _productid;
    end if;
END;
$$;


--
-- Name: userphone(public.citext, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.userphone(IN phone public.citext, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
begin 
 INSERT INTO users (phone)
			  VALUES (_phone)
			  returning id into _id;
END;
$$;


--
-- Name: userphone(public.citext, public.citext, boolean, public.citext, public.citext, public.citext, public.citext, uuid, uuid); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.userphone(IN name public.citext, IN email public.citext, IN verified boolean, IN lastlogin public.citext, IN lastloginip public.citext, IN image public.citext, IN phone public.citext, IN id uuid DEFAULT NULL::uuid, INOUT _id uuid DEFAULT NULL::uuid)
    LANGUAGE plpgsql
    AS $$
begin 
 INSERT INTO users (phone,name,email,verified,lastlogin,lastloginip,image)
			  VALUES (_phone,name,email,verified,lastlogin,lastloginip,image)
			  returning id into _id;
END;
$$;


--
-- Name: validatepromocode(public.citext, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.validatepromocode(_promo public.citext, _branchid uuid) RETURNS TABLE(discounttype public.citext, discountvalue numeric, discountpercent integer, maxdiscountprice numeric, mindiscountprice numeric, mindiscountquantity integer, ispercentage boolean)
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN QUERY
 select d.discounttype, d.discountvalue, d.discountpercent , d.maxdiscountprice , d.mindiscountprice , d.mindiscountquantity,d.ispercentage from discount d where promocode is not null and
--date is available by now
((fromdate is null ) or (fromdate::date <= (now() AT TIME ZONE 'Asia/Amman'::text)::date)) and
((todate is null ) or (todate::date >= (now() AT TIME ZONE 'Asia/Amman'::text)::date)) and
--today is actually on this offer
((daysofweek is null ) or (select to_char((now() AT TIME ZONE 'Asia/Amman'::text)::timestamp,'D')::integer = any(daysofweek)))
and isdeleted = false and ispublished = true
and promocode = _promo and _branchid =any(branchids);
END;
$$;


--
-- Name: verifycustomer(boolean, uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.verifycustomer(IN _isverify boolean, IN _id uuid DEFAULT NULL::uuid, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if _isverify is not null then update "customer" SET isverify = _isverify , updatedat = now(), updatedby = _updatedby where ("customer".id=_id ); end if;

end;
$$;


--
-- Name: verifycustomer_ai(boolean, uuid, public.citext); Type: PROCEDURE; Schema: public; Owner: -
--

CREATE PROCEDURE public.verifycustomer_ai(IN _isverify boolean, IN _id uuid DEFAULT NULL::uuid, IN _updatedby public.citext DEFAULT 'SYSTEM'::public.citext)
    LANGUAGE plpgsql
    AS $$
begin 
if _isverify is not null then update "customer" SET isverify = _isverify , updatedat = now(), updatedby = _updatedby where ("customer".id=_id ); end if;

end;
$$;


--
-- Name: workingcalculator(double precision, double precision, uuid); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION public.workingcalculator(lat1 double precision, lon1 double precision, _companyid uuid) RETURNS TABLE(id uuid, name public.citext, distance double precision)
    LANGUAGE plpgsql
    AS $$
BEGIN
			return query 
			select branch.id, branch.name , calculatedistance(lat1, lon1,branch.latitude,branch.longtitude,'K') distance from branch
			where branch.latitude is not null 
			and branch.longtitude is not null 
			and branch.companyid= _companyid  
			order by distance asc;
END;
$$;


--
-- Name: chatbotaiserver; Type: SERVER; Schema: -; Owner: -
--

CREATE SERVER chatbotaiserver FOREIGN DATA WRAPPER postgres_fdw OPTIONS (
    dbname 'IshbekChatbotAI',
    host '65.21.157.87',
    port '5432'
);


--
-- Name: USER MAPPING postgres SERVER chatbotaiserver; Type: USER MAPPING; Schema: -; Owner: -
--

CREATE USER MAPPING FOR postgres SERVER chatbotaiserver OPTIONS (
    password 'pBZEuh5enQvW45W8Lrn6SHk3Z27B2uwkJE2L2J5BWme8Xtw3h',
    "user" 'postgres'
);


--
-- Name: address; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.address (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    name public.citext,
    latitude numeric,
    longtitude numeric,
    countryname uuid,
    cityname uuid,
    areaname uuid,
    subareaname uuid,
    address1 public.citext,
    address2 public.citext,
    phoneno public.citext,
    buildingno public.citext,
    streetno public.citext,
    note public.citext,
    postalcode integer,
    zipcode integer,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT now() NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext
);


--
-- Name: address_temp; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.address_temp (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    companyid uuid,
    customerid uuid,
    ishbekcityid integer,
    ishbekareaid bigint,
    preferedsubarea public.citext,
    name public.citext,
    lat double precision,
    lng double precision,
    street public.citext,
    buildingnumber public.citext,
    otherdetails public.citext,
    creationsource uuid,
    notes public.citext,
    createdat timestamp without time zone DEFAULT now() NOT NULL,
    createdby public.citext DEFAULT 'SYSTEM'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext,
    ispublished boolean,
    isdeleted boolean
);


--
-- Name: addresses; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.addresses (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    companyid uuid,
    customerid uuid,
    ishbekcityid integer,
    ishbekareaid bigint,
    preferedsubarea public.citext,
    name public.citext,
    lat double precision,
    lng double precision,
    street public.citext,
    buildingnumber public.citext,
    otherdetails public.citext,
    creationsource uuid,
    notes public.citext,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text),
    createdby public.citext DEFAULT 'system'::public.citext,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext,
    ispublished boolean DEFAULT true,
    isdeleted boolean DEFAULT false NOT NULL,
    subareaid uuid
);


--
-- Name: ashyaeemappedentities; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.ashyaeemappedentities (
    ishbekid uuid NOT NULL,
    ashyaeeid integer,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text)
);


--
-- Name: ashyaeeorderlog; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.ashyaeeorderlog (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    eventid public.citext NOT NULL,
    occurredat timestamp without time zone NOT NULL,
    eventtype public.citext NOT NULL,
    details jsonb,
    createdat timestamp without time zone DEFAULT now(),
    branchid uuid DEFAULT public.uuid_nil()
);


--
-- Name: ashyaeerequestlog; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.ashyaeerequestlog (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    url public.citext NOT NULL,
    headers public.citext NOT NULL,
    requestbody public.citext,
    response public.citext,
    method public.citext,
    ishbekid uuid,
    creationtime timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text),
    responsetime timestamp without time zone
);


--
-- Name: attribute; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.attribute (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    name text
);


--
-- Name: attributemapd; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.attributemapd (
    mapdid uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    productid uuid,
    price numeric,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'System'::public.citext NOT NULL,
    attributeid uuid
);


--
-- Name: blacklist; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.blacklist (
    customerid uuid NOT NULL,
    companyid uuid NOT NULL,
    status public.citext NOT NULL,
    isapproved boolean,
    actiontime timestamp without time zone,
    actionby public.citext,
    createdby public.citext,
    createdat timestamp without time zone,
    notes public.citext
);


--
-- Name: branchaddress; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.branchaddress (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    branchid uuid NOT NULL,
    addressid uuid NOT NULL
);


--
-- Name: branchavailability; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.branchavailability (
    objectid uuid NOT NULL,
    objecttype public.citext NOT NULL,
    branchid uuid NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text),
    createdby public.citext DEFAULT 'system'::public.citext,
    channelid uuid,
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL
);


--
-- Name: branchcalculator; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.branchcalculator (
    branchid uuid NOT NULL,
    startperiod numeric NOT NULL,
    endperiod numeric NOT NULL,
    price numeric NOT NULL,
    createdat timestamp without time zone DEFAULT now() NOT NULL,
    createdby public.citext NOT NULL
);


--
-- Name: branchdelivery; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.branchdelivery (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    branchid uuid NOT NULL,
    deliverycompanyid uuid NOT NULL,
    maxdistance integer DEFAULT 10 NOT NULL,
    priority integer DEFAULT 1
);


--
-- Name: branchdeliveryaddress; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.branchdeliveryaddress (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    branchaddress uuid NOT NULL,
    branchdeliverycompany uuid NOT NULL,
    deliverycost numeric NOT NULL
);


--
-- Name: branchdeliverycharge; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.branchdeliverycharge (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    branchid uuid NOT NULL,
    city public.citext NOT NULL,
    area public.citext NOT NULL,
    subarea public.citext,
    fees numeric,
    createdat timestamp without time zone DEFAULT now() NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    companyid uuid
);


--
-- Name: branchorderconfig; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.branchorderconfig (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    type public.citext NOT NULL,
    companyid uuid NOT NULL,
    branchids uuid[],
    createdby public.citext DEFAULT 'SYSTEM'::public.citext NOT NULL
);


--
-- Name: branchorderseq; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.branchorderseq (
    branchid uuid NOT NULL,
    seq integer NOT NULL
);


--
-- Name: branchsubareafees; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.branchsubareafees (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    areacodeid integer,
    branchid uuid,
    fees numeric,
    areaid integer,
    cityid integer
);


--
-- Name: calllog; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.calllog (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    status public.citext NOT NULL,
    substatus public.citext NOT NULL,
    notes public.citext,
    customerphone public.citext NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/kuwait'::text) NOT NULL,
    createdby public.citext NOT NULL,
    companyid uuid NOT NULL
);


--
-- Name: callsubmission; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.callsubmission (
    status public.citext NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    parentstatus public.citext
);


--
-- Name: careemlog; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.careemlog (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    eventid public.citext NOT NULL,
    occurredat timestamp without time zone NOT NULL,
    eventtype public.citext NOT NULL,
    details jsonb,
    createdat timestamp without time zone DEFAULT now(),
    branchid uuid DEFAULT public.uuid_nil()
);


--
-- Name: category; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.category (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    image public.citext NOT NULL,
    parentcategoryid uuid,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext,
    companyid uuid NOT NULL,
    displaynumber integer DEFAULT 1,
    name jsonb,
    categorytag uuid,
    external_pos_id public.citext
);


--
-- Name: channellookup; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.channellookup (
    id uuid NOT NULL,
    name public.citext
);


--
-- Name: companyactiveintegrations; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.companyactiveintegrations (
    companyid uuid NOT NULL,
    channelid uuid NOT NULL,
    status public.citext DEFAULT 'pennding'::public.citext,
    isactive boolean DEFAULT false,
    reason public.citext,
    createdby public.citext,
    createdat timestamp without time zone DEFAULT now(),
    id uuid DEFAULT public.uuid_generate_v4()
);


--
-- Name: companychannels; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.companychannels (
    companyid uuid NOT NULL,
    channelid uuid NOT NULL,
    isactive boolean DEFAULT false NOT NULL,
    isdeleted boolean DEFAULT false NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext
);


--
-- Name: companyinfo; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.companyinfo (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    companyid uuid NOT NULL,
    type public.citext NOT NULL,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext,
    value text NOT NULL
);


--
-- Name: companynotification; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.companynotification (
    customerid uuid NOT NULL,
    notificationid uuid NOT NULL,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedby public.citext,
    deletedat public.citext
);


--
-- Name: companyservicechat; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.companyservicechat (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    companyid uuid NOT NULL,
    serviceid uuid,
    currentbalance integer DEFAULT 0 NOT NULL,
    chargebalance integer DEFAULT 0 NOT NULL,
    usebalance integer DEFAULT 0 NOT NULL,
    activeservice boolean DEFAULT false NOT NULL,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext
);


--
-- Name: companyservices; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.companyservices (
    companyid uuid NOT NULL,
    serviceid uuid NOT NULL,
    isactive boolean DEFAULT false NOT NULL,
    isdeleted boolean DEFAULT false NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext,
    phonenumber public.citext,
    whatsappid public.citext,
    whatsappcompanyid public.citext,
    availablebalance bigint DEFAULT 0 NOT NULL,
    chargebalance bigint DEFAULT 0 NOT NULL,
    counrtycode public.citext DEFAULT 962 NOT NULL,
    charlengthar bigint,
    charlengthen bigint
);


--
-- Name: companyservicescharge; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.companyservicescharge (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    companyid uuid NOT NULL,
    serviceid uuid NOT NULL,
    chargebalance bigint DEFAULT 0 NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext
);


--
-- Name: companysubarea; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.companysubarea (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    companyid uuid NOT NULL,
    cityid integer,
    areaid bigint,
    name public.citext,
    areacode integer
);


--
-- Name: companyuser; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.companyuser (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    usertype public.citext,
    username public.citext,
    email public.citext,
    name public.citext,
    phonenumber public.citext,
    isdeleted boolean DEFAULT false NOT NULL,
    isactive boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext,
    branchid uuid[],
    companyid uuid,
    keycloakid uuid
);


--
-- Name: companywaapiservicechat; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.companywaapiservicechat (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    name public.citext NOT NULL,
    companyid uuid NOT NULL,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext
);


--
-- Name: countries; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.countries (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    flag character varying NOT NULL,
    alpha2code public.citext NOT NULL,
    alpha3code public.citext NOT NULL,
    phonecode public.citext,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT now() NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext
);


--
-- Name: customer; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.customer (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    name public.citext,
    dateofbirth date,
    phoneno public.citext,
    phoneno2 public.citext,
    email public.citext,
    image public.citext,
    channel uuid,
    loyalitypoints numeric,
    fb public.citext,
    twitter public.citext,
    instagram public.citext,
    lastorderdate date,
    isblocked boolean DEFAULT false,
    blockdate jsonb,
    notes public.citext,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text),
    createdby public.citext DEFAULT 'system'::public.citext,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext,
    ispublished boolean DEFAULT true,
    isdeleted boolean DEFAULT false,
    isverify boolean DEFAULT false,
    verifycode public.citext,
    customertoken public.citext,
    countrycode public.citext,
    fullphonenumber public.citext,
    verifycodetime timestamp without time zone
);


--
-- Name: customeraddress; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.customeraddress (
    customerid uuid,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text),
    createdby public.citext DEFAULT 'system'::public.citext,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext,
    notes public.citext,
    buildingno public.citext,
    streetname public.citext,
    details public.citext,
    name public.citext,
    latitude numeric,
    longtitude numeric,
    addressid uuid,
    departmentno public.citext,
    labeladdressid uuid,
    isdeleted boolean DEFAULT false,
    georeflected boolean DEFAULT false
);


--
-- Name: customerpaymentdetail; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.customerpaymentdetail (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    hyperpayid public.citext,
    customerid uuid NOT NULL,
    companyid uuid NOT NULL,
    registrationid public.citext,
    paymentbrand public.citext,
    description public.citext,
    bin public.citext,
    bincountry public.citext,
    lastfourdigit public.citext,
    holder public.citext,
    expirymonth public.citext,
    expiryyear public.citext,
    bank public.citext,
    cardtype public.citext,
    level public.citext,
    createdat timestamp without time zone DEFAULT now()
);


--
-- Name: discountattribute; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.discountattribute (
    attributeid uuid NOT NULL,
    discountid uuid NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    isdeleted boolean DEFAULT false NOT NULL,
    updatedat timestamp without time zone[],
    deletedat timestamp without time zone,
    deletedby public.citext,
    updatedby public.citext,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL
);


--
-- Name: discountbranch; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.discountbranch (
    branchid uuid NOT NULL,
    discountid uuid NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedby public.citext,
    deletedat timestamp without time zone
);


--
-- Name: discountchannel; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.discountchannel (
    discountid uuid NOT NULL,
    channelid uuid NOT NULL,
    name public.citext,
    ispublished boolean DEFAULT true NOT NULL,
    isdeleted boolean DEFAULT false NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    updatedby public.citext,
    updatedat timestamp without time zone,
    deletedby public.citext,
    deletedat timestamp without time zone
);


--
-- Name: discountcustomers; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.discountcustomers (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    discountid uuid,
    customerid uuid
);


--
-- Name: discountproduct; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.discountproduct (
    productid uuid NOT NULL,
    discountid uuid NOT NULL,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedby public.citext,
    deletedat public.citext
);


--
-- Name: elicashapilogs; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.elicashapilogs (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    requesturl public.citext NOT NULL,
    headers jsonb NOT NULL,
    requestbody jsonb NOT NULL,
    customername character varying(255) NOT NULL,
    customerphonenumber character varying(20) NOT NULL,
    transactiontype character varying(100) NOT NULL,
    responsehttpcode integer NOT NULL,
    responsebody jsonb DEFAULT '{}'::jsonb NOT NULL,
    createdat timestamp without time zone DEFAULT now() NOT NULL,
    updatedat timestamp without time zone
);


--
-- Name: elicashcredentials; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.elicashcredentials (
    brandrefid public.citext NOT NULL,
    companyid uuid NOT NULL,
    createdat timestamp without time zone DEFAULT now()
);


--
-- Name: elicashcustomers; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.elicashcustomers (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    customername public.citext NOT NULL,
    customerphonenumber public.citext NOT NULL,
    customersource public.citext NOT NULL,
    createdat timestamp without time zone DEFAULT now() NOT NULL,
    updatedat timestamp without time zone
);


--
-- Name: generalcomplain; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.generalcomplain (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    customerid uuid NOT NULL,
    branchid uuid NOT NULL,
    orderstatuspossibilitiesid uuid NOT NULL,
    details public.citext,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext,
    category public.citext,
    subcategory public.citext,
    status public.citext
);


--
-- Name: integrationmiddlewarerequestlog; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.integrationmiddlewarerequestlog (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    url public.citext NOT NULL,
    headers public.citext NOT NULL,
    requestbody public.citext,
    response public.citext,
    method public.citext,
    creationtime timestamp without time zone DEFAULT now(),
    responsetime timestamp without time zone
);


--
-- Name: interfaceapirequestlog; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.interfaceapirequestlog (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    url public.citext NOT NULL,
    headers public.citext NOT NULL,
    requestbody public.citext,
    response public.citext,
    method public.citext,
    requestby public.citext,
    companyid uuid NOT NULL,
    authuserid uuid NOT NULL,
    creationtime timestamp without time zone DEFAULT now(),
    responsetime timestamp without time zone
);


--
-- Name: ishbekareas_serialid_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.ishbekareas_serialid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ishbekareas; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.ishbekareas (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    areaid bigint DEFAULT nextval('public.ishbekareas_serialid_seq'::regclass) NOT NULL,
    cityid integer NOT NULL,
    name public.citext,
    name_en public.citext,
    name_ar public.citext,
    lat double precision,
    lng double precision,
    is_other boolean DEFAULT false,
    searchable_text public.citext,
    url_name_ar public.citext,
    url_name_en public.citext,
    ispublished boolean DEFAULT true
);


--
-- Name: ishbekcities_serialid_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.ishbekcities_serialid_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: ishbekcities; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.ishbekcities (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    cityid integer DEFAULT nextval('public.ishbekcities_serialid_seq'::regclass) NOT NULL,
    name_ar public.citext NOT NULL,
    name_en public.citext NOT NULL,
    alias_name public.citext,
    ispublished boolean DEFAULT true,
    searchable_text public.citext
);


--
-- Name: ishbekcitiestemp; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.ishbekcitiestemp (
    id uuid,
    cityid integer,
    name_ar public.citext,
    name_en public.citext,
    alias_name public.citext,
    ispublished boolean,
    citycode text
);


--
-- Name: ishbekmapzones; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.ishbekmapzones (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    cityname public.citext NOT NULL,
    cityid integer NOT NULL,
    areaname public.citext NOT NULL,
    areaid integer NOT NULL,
    coordinates jsonb NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL
);


--
-- Name: ishbekmapzonestemp; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.ishbekmapzonestemp (
    id uuid,
    cityname public.citext,
    cityid integer,
    areaname public.citext,
    areaid integer,
    coordinates jsonb,
    createdat timestamp without time zone,
    createdby public.citext
);


--
-- Name: language; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.language (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    name public.citext NOT NULL,
    languagecode public.citext NOT NULL,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext
);


--
-- Name: linkeradditionalattributes; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.linkeradditionalattributes (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    connecterid uuid,
    additionalattributeid uuid,
    questionattributeid uuid
);


--
-- Name: lockup_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.lockup_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: lookup; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.lookup (
    id bigint DEFAULT nextval('public.lockup_id_seq'::regclass) NOT NULL,
    name public.citext
);


--
-- Name: manualprintingorder; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.manualprintingorder (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    printing boolean DEFAULT false NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    branchid uuid,
    orderid uuid,
    printername public.citext[]
);


--
-- Name: menu; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.menu (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    name public.citext NOT NULL,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext,
    isavailable boolean DEFAULT true,
    companyid uuid NOT NULL
);


--
-- Name: menucategories; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.menucategories (
    menuid uuid NOT NULL,
    categoryid uuid NOT NULL
);


--
-- Name: menuchannel; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.menuchannel (
    menuid uuid NOT NULL,
    channelid uuid NOT NULL,
    branchid uuid NOT NULL
);


--
-- Name: menuintegratiosync; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.menuintegratiosync (
    menuid uuid NOT NULL,
    channelid uuid NOT NULL,
    issync boolean DEFAULT false,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text),
    createdby public.citext DEFAULT 'system'::public.citext,
    updatedat timestamp without time zone,
    updatedby public.citext
);


--
-- Name: menuintegrators; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.menuintegrators (
    channelid uuid NOT NULL,
    name public.citext,
    isactive boolean,
    logo public.citext
);


--
-- Name: menuproduct; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.menuproduct (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    menuid uuid NOT NULL,
    productid uuid NOT NULL,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext
);


--
-- Name: menuqrcode; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.menuqrcode (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    menuid uuid NOT NULL,
    channelid uuid NOT NULL,
    branchid uuid NOT NULL,
    qrcode public.citext,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    deletedat timestamp without time zone,
    deletedby public.citext
);


--
-- Name: menurequestlog; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.menurequestlog (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    url public.citext NOT NULL,
    headers public.citext NOT NULL,
    requestbody public.citext,
    response public.citext,
    method public.citext,
    creationtime timestamp without time zone DEFAULT now(),
    responsetime timestamp without time zone,
    brandid public.citext,
    menuversion integer DEFAULT 0,
    companyid uuid
);


--
-- Name: mezaoutgoingdrequestlog; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.mezaoutgoingdrequestlog (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    url text NOT NULL,
    headers json NOT NULL,
    request json DEFAULT '{}'::json NOT NULL,
    responce json DEFAULT '{}'::json NOT NULL,
    httpcode integer DEFAULT 200 NOT NULL,
    createdat timestamp without time zone DEFAULT now() NOT NULL,
    updatedat timestamp without time zone DEFAULT now()
);


--
-- Name: notification; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.notification (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    type integer DEFAULT 1,
    startdate date,
    starttime time without time zone,
    companyid uuid NOT NULL,
    urgent boolean DEFAULT false,
    priority integer DEFAULT 1,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext,
    isdeleted boolean DEFAULT false NOT NULL,
    title public.citext,
    subject public.citext,
    category integer[]
);


--
-- Name: notificationfollowup; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.notificationfollowup (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    notificationid uuid NOT NULL,
    isview boolean DEFAULT false NOT NULL,
    customerid uuid NOT NULL
);


--
-- Name: offerimage; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.offerimage (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    imagepath public.citext,
    ispublished boolean DEFAULT true,
    isdeleted boolean DEFAULT false,
    createdat timestamp without time zone DEFAULT now(),
    createdby public.citext DEFAULT 'system'::public.citext,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    companyid uuid
);


--
-- Name: order_2025; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.order_2025 (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    branchorderid public.citext,
    scheduled timestamp without time zone,
    deliverytype uuid,
    customerid uuid NOT NULL,
    branchid uuid NOT NULL,
    notes public.citext,
    totalprice numeric NOT NULL,
    deliveryprice numeric,
    deliveryaddress uuid,
    subtotalprice numeric NOT NULL,
    totalpreparingtime public.citext,
    deliverystatus public.citext,
    paymenttype public.citext NOT NULL,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext,
    ordersource uuid,
    channelid uuid,
    currentstatus uuid,
    iscanceled boolean DEFAULT false NOT NULL,
    iscomplained boolean DEFAULT false NOT NULL,
    isedited boolean DEFAULT false NOT NULL,
    isdeclined boolean DEFAULT false NOT NULL,
    reminder timestamp without time zone,
    numberofpeople public.citext,
    referencenumber jsonb DEFAULT '{}'::jsonb NOT NULL,
    isseen timestamp without time zone,
    price jsonb,
    deliverytrackinglink public.citext,
    responsetime jsonb,
    referencenumber2 public.citext,
    ishbekserial bigint NOT NULL,
    isready boolean DEFAULT false
);


--
-- Name: order_2025_ishbekserial_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.order_2025_ishbekserial_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: order_2025_ishbekserial_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.order_2025_ishbekserial_seq OWNED BY public.order_2025.ishbekserial;


--
-- Name: order_ishbekserial_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.order_ishbekserial_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: order_ishbekserial_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE public.order_ishbekserial_seq OWNED BY public."order".ishbekserial;


--
-- Name: ordercomplain; Type: VIEW; Schema: public; Owner: -
--

CREATE VIEW public.ordercomplain AS
 SELECT ordfp.id,
    br.name,
    ord.branchid,
    ord.currentstatus,
    ordfp.createdat
   FROM ((public.orderfollowupdetails ordfp
     JOIN public."order" ord ON ((ordfp.orderid = ord.id)))
     JOIN public.branch br ON ((ord.branchid = br.id)))
  WHERE ((ordfp.createdby OPERATOR(public.=) 'agent'::public.citext) AND (ordfp.isdeleted = false) AND (ordfp.ispublished = true));


--
-- Name: orderconfig; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.orderconfig (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    language public.citext,
    selectedservices uuid[],
    logo public.citext,
    registrationphoto public.citext,
    themecolor public.citext DEFAULT 'black'::public.citext,
    buttoncolor public.citext,
    reservationtime timestamp without time zone,
    ordertime timestamp without time zone,
    preparetime timestamp without time zone,
    restaurantdomain public.citext,
    issms boolean DEFAULT false,
    istrackorder boolean DEFAULT false,
    ispublished boolean DEFAULT true NOT NULL,
    isdeleted boolean DEFAULT false NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext,
    companyid uuid NOT NULL,
    pickupbranchids uuid[],
    dineinbranchids uuid[],
    deliverybranchids uuid[],
    offerlogo public.citext
);


--
-- Name: orderfollowup; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.orderfollowup (
    id uuid NOT NULL,
    ordercase public.citext NOT NULL,
    isagent boolean DEFAULT false,
    isteamleader boolean DEFAULT true,
    isbranch boolean DEFAULT false,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext,
    category public.citext,
    subcategory public.citext,
    customerid uuid,
    status public.citext DEFAULT 'Open'::public.citext NOT NULL
);


--
-- Name: orderhistoryprice; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.orderhistoryprice (
    id uuid DEFAULT public.uuid_generate_v4(),
    itemid uuid,
    itemtype public.citext,
    price jsonb,
    tax numeric,
    taxedprice jsonb,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text),
    createdby public.citext
);


--
-- Name: orderprice; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.orderprice (
    id uuid DEFAULT public.uuid_generate_v4(),
    orderid uuid,
    branchid uuid,
    ordersourceid uuid,
    customerid uuid,
    ordertotal numeric DEFAULT 0,
    ordertotalwithouttax numeric DEFAULT 0,
    deliveryprice numeric DEFAULT 0,
    orderdiscount numeric DEFAULT 0,
    deliverydiscount numeric DEFAULT 0,
    ordertax numeric DEFAULT 0,
    grandtotal numeric DEFAULT 0,
    servicefee numeric DEFAULT 0,
    discounttype jsonb,
    orderprice jsonb,
    createdat timestamp without time zone DEFAULT now(),
    tax jsonb,
    discountnames public.citext
);


--
-- Name: orderpricedetails; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.orderpricedetails (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    referencenumber public.citext NOT NULL,
    referencenumberexternalnumber public.citext DEFAULT '0'::public.citext NOT NULL,
    totalpaidamount numeric DEFAULT 0 NOT NULL,
    servicefee numeric DEFAULT 0 NOT NULL,
    taxfee numeric DEFAULT 0 NOT NULL,
    deliveryvalue numeric DEFAULT 0 NOT NULL,
    totalproductsoriginalprice numeric DEFAULT 0 NOT NULL,
    totalproductsorderprice numeric DEFAULT 0 NOT NULL,
    totalproductsmerchentdiscountamount numeric DEFAULT 0 NOT NULL,
    totalproductsoperatordiscountamount numeric DEFAULT 0 NOT NULL,
    customerprostatus boolean DEFAULT false NOT NULL,
    paymentmethod public.citext DEFAULT 'cash'::public.citext NOT NULL,
    createdat timestamp without time zone DEFAULT now() NOT NULL,
    updatedat timestamp without time zone,
    ordersourceid uuid DEFAULT public.uuid_nil() NOT NULL
);


--
-- Name: orderprint; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.orderprint (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    jobid uuid NOT NULL,
    taxnumber public.citext,
    restaurantname public.citext,
    copies integer,
    branchname public.citext,
    branchid uuid NOT NULL,
    branchlogo public.citext,
    branchphone public.citext,
    printer public.citext NOT NULL,
    template public.citext NOT NULL,
    orderinfo json,
    clientinfo json,
    items json,
    isdeleted boolean DEFAULT false NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext,
    printerid uuid NOT NULL
);


--
-- Name: orderproduct; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.orderproduct (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    orderid uuid,
    productid uuid,
    pricesubtotal numeric,
    pricetaxvalue numeric,
    pricetaxpercentage numeric,
    notes public.citext,
    itemcount integer DEFAULT 1,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext,
    price jsonb
);


--
-- Name: orderproduct_2025; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.orderproduct_2025 (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    orderid uuid,
    productid uuid,
    pricesubtotal numeric,
    pricetaxvalue numeric,
    pricetaxpercentage numeric,
    notes public.citext,
    itemcount integer DEFAULT 1,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext,
    price jsonb
);


--
-- Name: orderproductattribute; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.orderproductattribute (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    orderproductid uuid,
    attributeid uuid,
    pricesubtotal numeric,
    pricetaxvalue numeric,
    pricetaxpercentage numeric,
    notes public.citext,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext,
    children jsonb
);


--
-- Name: orderproductattribute_2025; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.orderproductattribute_2025 (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    orderproductid uuid,
    attributeid uuid,
    pricesubtotal numeric,
    pricetaxvalue numeric,
    pricetaxpercentage numeric,
    notes public.citext,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext,
    children jsonb
);


--
-- Name: ordersreport; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.ordersreport (
    orderid uuid,
    companyid uuid,
    companyname character varying(255),
    branchid uuid,
    branchname character varying(255),
    customerid uuid,
    customerphone character varying(25),
    customername character varying(500),
    deliveryid uuid,
    deliveryname character varying(255),
    ordersourceid uuid,
    ordersourcename character varying(255),
    orderfirststatus character varying(50),
    orderfirststatusby character varying(50),
    orderfirststatusat character varying(50),
    orderstatusid uuid,
    orderstatusname character varying(25),
    isschedule boolean,
    schedule timestamp without time zone,
    hasnote boolean,
    paymenttype character varying(100),
    isdeclined boolean,
    iscanceled boolean,
    createdat timestamp without time zone,
    createdby character varying(50),
    orderreference character varying(50),
    serial bigint NOT NULL,
    branchorderid integer DEFAULT 0,
    ordernote text,
    ordertype text,
    updatedat timestamp without time zone,
    deliveryaddress uuid DEFAULT public.uuid_nil() NOT NULL,
    referencenumber jsonb DEFAULT '{}'::jsonb NOT NULL,
    deliverystatus text DEFAULT ''::text NOT NULL,
    priceobject jsonb DEFAULT '{}'::jsonb NOT NULL,
    delivaryaddressobject json DEFAULT '{}'::json NOT NULL
);


--
-- Name: orderstatuspossibilities1; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.orderstatuspossibilities1 (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    status public.citext NOT NULL,
    nextstatus uuid,
    isfirststatus boolean DEFAULT false,
    islaststatus boolean DEFAULT false NOT NULL,
    color public.citext DEFAULT 'gray'::public.citext NOT NULL,
    isfoodready boolean DEFAULT false
);


--
-- Name: ourintegration; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.ourintegration (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    name public.citext,
    type public.citext,
    typename public.citext,
    referenceid uuid,
    image public.citext,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text)
);


--
-- Name: paymentonholdorders; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.paymentonholdorders (
    orderpaymentid uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    sessionid public.citext NOT NULL,
    resultind public.citext,
    response public.citext,
    finished boolean DEFAULT false NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    orderdetails jsonb,
    branchorderid public.citext,
    scheduled timestamp without time zone,
    deliverytype uuid,
    customerid uuid NOT NULL,
    branchid uuid NOT NULL,
    notes public.citext,
    totalprice numeric NOT NULL,
    deliveryprice numeric,
    deliveryaddress uuid,
    subtotalprice numeric NOT NULL,
    totalpreparingtime public.citext,
    deliverystatus public.citext,
    paymenttype public.citext NOT NULL,
    ordersource uuid,
    channelid uuid,
    currentstatus uuid,
    referencenumber jsonb DEFAULT '{}'::jsonb NOT NULL,
    price jsonb,
    referencenumber2 public.citext
);


--
-- Name: paymentrequestlog; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.paymentrequestlog (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    companyid uuid NOT NULL,
    customerid uuid NOT NULL,
    merchanttransactionid public.citext NOT NULL,
    entityid public.citext,
    amount public.citext,
    request public.citext,
    checkoutid public.citext,
    holdorderid uuid,
    method public.citext,
    url public.citext,
    createdat timestamp without time zone DEFAULT now(),
    reponsetime timestamp without time zone
);


--
-- Name: pointlog; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.pointlog (
    crid uuid NOT NULL,
    createdat timestamp without time zone DEFAULT now() NOT NULL,
    amount double precision,
    customerid uuid,
    restaurantid uuid,
    channelid uuid,
    orderid uuid
);


--
-- Name: posintegration; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.posintegration (
    companyid uuid NOT NULL,
    integrationcompanyid uuid NOT NULL,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext,
    autorepushfailedorders boolean DEFAULT false NOT NULL
);


--
-- Name: printingorderlogs; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.printingorderlogs (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    printing boolean DEFAULT false,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text),
    branchid uuid,
    orderid uuid,
    printername public.citext[]
);


--
-- Name: productimages; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.productimages (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    imagepath public.citext NOT NULL,
    productid uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext
);


--
-- Name: productquestions; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.productquestions (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    productid uuid,
    questionid uuid
);


--
-- Name: productselectedattribute; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.productselectedattribute (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    product uuid NOT NULL,
    attribute jsonb NOT NULL,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext
);


--
-- Name: producttt; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.producttt (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    name jsonb
);


--
-- Name: promocode; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.promocode (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    name public.citext,
    type public.citext,
    daysofweek integer[],
    value numeric,
    maxvalue numeric,
    minquantity integer,
    minprice numeric,
    priority integer DEFAULT 1 NOT NULL,
    numberofusecustomer integer,
    numberofusage integer DEFAULT 0,
    isdaily boolean DEFAULT false NOT NULL,
    isavailable boolean DEFAULT true NOT NULL,
    ispercentage boolean DEFAULT false NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    companyid uuid,
    description public.citext,
    numberofuse bigint,
    availablefrom timestamp without time zone,
    availableto timestamp without time zone,
    descriptionlanguage jsonb
);


--
-- Name: promocodebranch; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.promocodebranch (
    branchid uuid NOT NULL,
    promocodeid uuid NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedby public.citext,
    deletedat timestamp without time zone
);


--
-- Name: promocodecategory; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.promocodecategory (
    categoryid uuid NOT NULL,
    promocodeid uuid NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedby public.citext,
    deletedat timestamp without time zone
);


--
-- Name: promocodechannel; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.promocodechannel (
    promocodeid uuid NOT NULL,
    channelid uuid NOT NULL,
    name public.citext,
    ispublished boolean DEFAULT true NOT NULL,
    isdeleted boolean DEFAULT false NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    updatedby public.citext,
    updatedat timestamp without time zone,
    deletedby public.citext,
    deletedat timestamp without time zone
);


--
-- Name: promocodecustomers; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.promocodecustomers (
    promocodeid uuid NOT NULL,
    customerid uuid NOT NULL,
    lastusetime timestamp without time zone,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    updatedby public.citext,
    updatedat timestamp without time zone,
    deletedby public.citext,
    deletedat timestamp without time zone,
    numberofusage bigint DEFAULT 0
);


--
-- Name: questionattributes; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.questionattributes (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    productquestionid uuid,
    attributeid uuid
);


--
-- Name: questions; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.questions (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    name text
);


--
-- Name: relatedproduct; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.relatedproduct (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    productid uuid NOT NULL,
    relatedproductid uuid NOT NULL,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext
);


--
-- Name: requestlog; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.requestlog (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    url public.citext NOT NULL,
    headers public.citext NOT NULL,
    requestbody public.citext,
    response public.citext,
    method public.citext,
    creationtime timestamp without time zone DEFAULT now(),
    responsetime timestamp without time zone,
    remoteid uuid,
    talabatbrandid public.citext,
    deliveryplatformid public.citext
);


--
-- Name: restaurantcustomer; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.restaurantcustomer (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    customerid uuid,
    restaurantid uuid,
    lastpointdate timestamp without time zone,
    currentpoints numeric DEFAULT 0,
    currentstatus integer DEFAULT 1,
    isactive boolean DEFAULT false,
    isblocked boolean DEFAULT false,
    createdat timestamp without time zone DEFAULT now()
);


--
-- Name: restaurantcustomercopy; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.restaurantcustomercopy (
    id uuid,
    customerid uuid,
    restaurantid uuid,
    lastpointdate timestamp without time zone,
    currentpoints numeric,
    currentstatus integer,
    isactive boolean,
    isblocked boolean,
    updatedat timestamp without time zone
);


--
-- Name: restaurantcustomercopy2; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.restaurantcustomercopy2 (
    id uuid,
    customerid uuid,
    restaurantid uuid,
    lastpointdate timestamp without time zone,
    currentpoints numeric,
    currentstatus integer,
    isactive boolean,
    isblocked boolean
);


--
-- Name: restaurantparams; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.restaurantparams (
    restaurantid uuid NOT NULL,
    period integer,
    loyalityperiod integer,
    loyalitycount integer,
    loyalityamount numeric,
    createdat timestamp without time zone DEFAULT now(),
    createdby public.citext,
    restaurantname public.citext
);


--
-- Name: rlookup; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.rlookup (
    rid uuid,
    sid bigint NOT NULL,
    rname public.citext
);


--
-- Name: scheduledeliveryorderrequest; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.scheduledeliveryorderrequest (
    id uuid DEFAULT public.uuid_generate_v4(),
    orderid uuid NOT NULL,
    deliverycompanyid uuid NOT NULL,
    name public.citext NOT NULL,
    baseurl public.citext NOT NULL,
    apiurl public.citext NOT NULL,
    body jsonb,
    reponse jsonb,
    executiontime timestamp without time zone,
    isexecuted boolean DEFAULT false,
    createdat timestamp without time zone DEFAULT now()
);


--
-- Name: statuslog; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.statuslog (
    crid uuid,
    status integer,
    previousstatus integer,
    createdat timestamp without time zone DEFAULT now(),
    customerid uuid,
    restaurantid uuid
);


--
-- Name: talabatcredential; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.talabatcredential (
    ishbekbranchid uuid,
    talabatbranchid public.citext,
    talabatbrandid public.citext,
    companyid uuid,
    createdat timestamp without time zone DEFAULT now(),
    istaxable boolean DEFAULT true
);


--
-- Name: talabatdelivery; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.talabatdelivery (
    orderid uuid NOT NULL,
    request jsonb,
    response jsonb,
    requesttype public.citext NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    talabatorderid public.citext
);


--
-- Name: talabatmenu; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.talabatmenu (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    brandid public.citext NOT NULL,
    companyid uuid NOT NULL,
    menu json NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    status boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT false NOT NULL,
    version public.citext,
    versiontime timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    menuversionnumber integer DEFAULT 1 NOT NULL
);


--
-- Name: talabatprerequestlog; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.talabatprerequestlog (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    body jsonb,
    headers jsonb,
    branchid uuid,
    deliveryplatformid public.citext DEFAULT ''::public.citext NOT NULL,
    createdat timestamp without time zone DEFAULT now()
);


--
-- Name: tempaddress; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.tempaddress (
    customerid uuid,
    ishbekcityid integer,
    ishbekareaid bigint,
    name public.citext,
    lat double precision,
    lng double precision
);


--
-- Name: transaction; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.transaction (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    hyperpayid public.citext,
    customerid uuid NOT NULL,
    companyid uuid NOT NULL,
    amount public.citext,
    descriptor public.citext,
    description public.citext,
    extendeddescription public.citext,
    transactionid public.citext,
    orderid public.citext,
    paymenttype public.citext,
    ip public.citext,
    "timestamp" public.citext,
    alldetails jsonb,
    createdat timestamp without time zone DEFAULT now()
);


--
-- Name: transferbranch; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.transferbranch (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    branchidselected uuid NOT NULL,
    transfertobranchid uuid NOT NULL,
    fromdate timestamp without time zone,
    todate timestamp without time zone,
    isactive boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    isdeleted boolean DEFAULT false NOT NULL
);


--
-- Name: userauth; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.userauth (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    username public.citext NOT NULL,
    passowrd public.citext NOT NULL,
    companyid uuid NOT NULL,
    isdeleted boolean DEFAULT false NOT NULL,
    ispublished boolean DEFAULT true NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext
);


--
-- Name: viciphonenumber; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.viciphonenumber (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    companyname public.citext NOT NULL,
    companyid uuid NOT NULL,
    companyphone public.citext NOT NULL,
    createdat timestamp without time zone DEFAULT (now() AT TIME ZONE 'Asia/Amman'::text) NOT NULL,
    createdby public.citext DEFAULT 'system'::public.citext NOT NULL,
    updatedat timestamp without time zone,
    updatedby public.citext,
    deletedat timestamp without time zone,
    deletedby public.citext
);


--
-- Name: viewprinter; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.viewprinter (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    name public.citext NOT NULL,
    branchid uuid NOT NULL,
    companyid uuid NOT NULL
);


--
-- Name: waapiclients; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.waapiclients (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    companyid uuid NOT NULL,
    instanceid integer,
    owner public.citext,
    name public.citext,
    webhooks public.citext[],
    phonenumber public.citext,
    createdat timestamp without time zone DEFAULT now(),
    deletedat timestamp without time zone,
    isdeleted boolean DEFAULT false,
    isactive boolean DEFAULT true,
    createdby public.citext DEFAULT 'system'::public.citext,
    integrationtype public.citext
);


--
-- Name: waapilogs; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE public.waapilogs (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    request json NOT NULL,
    response json NOT NULL,
    createdat timestamp without time zone DEFAULT now(),
    endpoint character varying
);


--
-- Name: wizoo_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE public.wizoo_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: order ishbekserial; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public."order" ALTER COLUMN ishbekserial SET DEFAULT nextval('public.order_ishbekserial_seq'::regclass);


--
-- Name: order_2025 ishbekserial; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.order_2025 ALTER COLUMN ishbekserial SET DEFAULT nextval('public.order_2025_ishbekserial_seq'::regclass);


--
-- Name: tax Tax_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.tax
    ADD CONSTRAINT "Tax_pkey" PRIMARY KEY (id);


--
-- Name: companywaapiservicechat Uni_Companyid; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.companywaapiservicechat
    ADD CONSTRAINT "Uni_Companyid" UNIQUE (companyid);


--
-- Name: address address_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.address
    ADD CONSTRAINT address_pkey PRIMARY KEY (id);


--
-- Name: address_temp address_temp_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.address_temp
    ADD CONSTRAINT address_temp_pkey PRIMARY KEY (id);


--
-- Name: addresses addresses_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.addresses
    ADD CONSTRAINT addresses_pkey PRIMARY KEY (id);


--
-- Name: ashyaeerequestlog ashayaeerequestlog_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ashyaeerequestlog
    ADD CONSTRAINT ashayaeerequestlog_pkey PRIMARY KEY (id);


--
-- Name: ashyaeemappedentities ashyaeemappedentities_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ashyaeemappedentities
    ADD CONSTRAINT ashyaeemappedentities_pkey PRIMARY KEY (ishbekid);


--
-- Name: ashyaeeorderlog ashyaeeorderlog_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ashyaeeorderlog
    ADD CONSTRAINT ashyaeeorderlog_pkey PRIMARY KEY (id);


--
-- Name: attribute attribute_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.attribute
    ADD CONSTRAINT attribute_pkey PRIMARY KEY (id);


--
-- Name: attributemapd attributemapd_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.attributemapd
    ADD CONSTRAINT attributemapd_pkey PRIMARY KEY (mapdid);


--
-- Name: benefeciary benefeciary_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.benefeciary
    ADD CONSTRAINT benefeciary_pkey PRIMARY KEY (id);


--
-- Name: blacklist blacklist_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.blacklist
    ADD CONSTRAINT blacklist_pkey PRIMARY KEY (customerid, companyid);


--
-- Name: branch branch_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.branch
    ADD CONSTRAINT branch_pkey PRIMARY KEY (id);


--
-- Name: branchaddress branchaddress_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.branchaddress
    ADD CONSTRAINT branchaddress_pkey PRIMARY KEY (id);


--
-- Name: branchavailability branchavailability_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.branchavailability
    ADD CONSTRAINT branchavailability_pkey PRIMARY KEY (id);


--
-- Name: branchcalculator branchcalculator_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.branchcalculator
    ADD CONSTRAINT branchcalculator_pkey PRIMARY KEY (branchid, startperiod);


--
-- Name: branchdelivery branchdelivery_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.branchdelivery
    ADD CONSTRAINT branchdelivery_pkey PRIMARY KEY (id);


--
-- Name: branchdeliveryaddress branchdeliveryaddress_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.branchdeliveryaddress
    ADD CONSTRAINT branchdeliveryaddress_pkey PRIMARY KEY (id);


--
-- Name: branchorderconfig branchorderconfig_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.branchorderconfig
    ADD CONSTRAINT branchorderconfig_pkey PRIMARY KEY (id, type);


--
-- Name: branchorderseq branchorderseq_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.branchorderseq
    ADD CONSTRAINT branchorderseq_pkey PRIMARY KEY (branchid);


--
-- Name: branchsubareafees branchsubareafees_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.branchsubareafees
    ADD CONSTRAINT branchsubareafees_pkey PRIMARY KEY (id);


--
-- Name: branchtemplate branchtemplate_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.branchtemplate
    ADD CONSTRAINT branchtemplate_pkey PRIMARY KEY (branchid, type);


--
-- Name: calllog calllog_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.calllog
    ADD CONSTRAINT calllog_pkey PRIMARY KEY (id);


--
-- Name: callsubmission callsubmission_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.callsubmission
    ADD CONSTRAINT callsubmission_pkey PRIMARY KEY (status);


--
-- Name: careemlog careemlog_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.careemlog
    ADD CONSTRAINT careemlog_pkey PRIMARY KEY (id);


--
-- Name: category category_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.category
    ADD CONSTRAINT category_pkey PRIMARY KEY (id);


--
-- Name: channellookup channellookup_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.channellookup
    ADD CONSTRAINT channellookup_pkey PRIMARY KEY (id);


--
-- Name: chatconversation chatconversation_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.chatconversation
    ADD CONSTRAINT chatconversation_pkey PRIMARY KEY (id);


--
-- Name: clientintegration clientintegration_companyidintcompanyidpkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.clientintegration
    ADD CONSTRAINT clientintegration_companyidintcompanyidpkey PRIMARY KEY (companyid, intcompanyid);


--
-- Name: company company_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.company
    ADD CONSTRAINT company_pkey PRIMARY KEY (id);


--
-- Name: companyactiveintegrations companyactiveintegrations_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.companyactiveintegrations
    ADD CONSTRAINT companyactiveintegrations_pkey PRIMARY KEY (channelid, companyid);


--
-- Name: companyfaq companyfaq_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.companyfaq
    ADD CONSTRAINT companyfaq_pkey PRIMARY KEY (id);


--
-- Name: viciphonenumber companyid; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.viciphonenumber
    ADD CONSTRAINT companyid UNIQUE (companyid);


--
-- Name: companyinfo companyinfo_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.companyinfo
    ADD CONSTRAINT companyinfo_pkey PRIMARY KEY (id);


--
-- Name: companynotification companynotification_pk; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.companynotification
    ADD CONSTRAINT companynotification_pk PRIMARY KEY (customerid, notificationid);


--
-- Name: companyservicechat companyservicechat_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.companyservicechat
    ADD CONSTRAINT companyservicechat_pkey PRIMARY KEY (id);


--
-- Name: companyservicescharge companyservicescharge_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.companyservicescharge
    ADD CONSTRAINT companyservicescharge_pkey PRIMARY KEY (id);


--
-- Name: companysubarea companysubarea_pk; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.companysubarea
    ADD CONSTRAINT companysubarea_pk PRIMARY KEY (id);


--
-- Name: companyuser companyuser_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.companyuser
    ADD CONSTRAINT companyuser_pkey PRIMARY KEY (id);


--
-- Name: orderconfig configorder_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.orderconfig
    ADD CONSTRAINT configorder_pkey PRIMARY KEY (id);


--
-- Name: countries countries_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.countries
    ADD CONSTRAINT countries_pkey PRIMARY KEY (id);


--
-- Name: coupon coupon_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.coupon
    ADD CONSTRAINT coupon_pkey PRIMARY KEY (id);


--
-- Name: customer customer_pkey1; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.customer
    ADD CONSTRAINT customer_pkey1 PRIMARY KEY (id);


--
-- Name: customerbillingdetails customerbillingdetails_pk; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.customerbillingdetails
    ADD CONSTRAINT customerbillingdetails_pk UNIQUE (customerid);


--
-- Name: customerbillingdetails customerbillingdetails_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.customerbillingdetails
    ADD CONSTRAINT customerbillingdetails_pkey PRIMARY KEY (id);


--
-- Name: customerpaymentdetail customerpaymentdetail_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.customerpaymentdetail
    ADD CONSTRAINT customerpaymentdetail_pkey PRIMARY KEY (id);


--
-- Name: customer customerphoneno; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.customer
    ADD CONSTRAINT customerphoneno UNIQUE (phoneno);


--
-- Name: delayedorders delayedorders_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.delayedorders
    ADD CONSTRAINT delayedorders_pkey PRIMARY KEY (orderid);


--
-- Name: deliverycompany deliverycompany_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.deliverycompany
    ADD CONSTRAINT deliverycompany_pkey PRIMARY KEY (id);


--
-- Name: discountchannel discounchannal			_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.discountchannel
    ADD CONSTRAINT "discounchannal			_pkey" PRIMARY KEY (discountid, channelid);


--
-- Name: discountattribute discountattribute_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.discountattribute
    ADD CONSTRAINT discountattribute_pkey PRIMARY KEY (attributeid, discountid);


--
-- Name: discountbranch discountbranch_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.discountbranch
    ADD CONSTRAINT discountbranch_pkey PRIMARY KEY (branchid, discountid);


--
-- Name: discountcustomers discountcustomers_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.discountcustomers
    ADD CONSTRAINT discountcustomers_pkey PRIMARY KEY (id);


--
-- Name: discountinfo discountinfo_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.discountinfo
    ADD CONSTRAINT discountinfo_pkey PRIMARY KEY (id);


--
-- Name: discountproduct discountproduct_pk; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.discountproduct
    ADD CONSTRAINT discountproduct_pk PRIMARY KEY (productid, discountid);


--
-- Name: elicashapilogs elicashapilogs_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.elicashapilogs
    ADD CONSTRAINT elicashapilogs_pkey PRIMARY KEY (id);


--
-- Name: elicashcredentials elicashcredentials_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.elicashcredentials
    ADD CONSTRAINT elicashcredentials_pkey PRIMARY KEY (companyid);


--
-- Name: elicashcustomers elicashcustomers_customerphonenumber_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.elicashcustomers
    ADD CONSTRAINT elicashcustomers_customerphonenumber_key UNIQUE (customerphonenumber);


--
-- Name: elicashcustomers elicashcustomers_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.elicashcustomers
    ADD CONSTRAINT elicashcustomers_pkey PRIMARY KEY (id);


--
-- Name: generalcomplain id_pk; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.generalcomplain
    ADD CONSTRAINT id_pk PRIMARY KEY (id);


--
-- Name: integrationcompany integrationcompany_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.integrationcompany
    ADD CONSTRAINT integrationcompany_pkey PRIMARY KEY (id);


--
-- Name: integrationmiddlewarerequestlog integrationmiddlewarerequestlog_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.integrationmiddlewarerequestlog
    ADD CONSTRAINT integrationmiddlewarerequestlog_pkey PRIMARY KEY (id);


--
-- Name: interfaceapirequestlog interfaceapirequestlog_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.interfaceapirequestlog
    ADD CONSTRAINT interfaceapirequestlog_pkey PRIMARY KEY (id);


--
-- Name: ishbekcities ishbek_city_id; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ishbekcities
    ADD CONSTRAINT ishbek_city_id UNIQUE (cityid);


--
-- Name: ishbekareas ishbekareas_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ishbekareas
    ADD CONSTRAINT ishbekareas_pkey PRIMARY KEY (id);


--
-- Name: ishbekcities ishbekcities_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ishbekcities
    ADD CONSTRAINT ishbekcities_pkey PRIMARY KEY (id);


--
-- Name: ishbekmapzones ishbekmapzones_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ishbekmapzones
    ADD CONSTRAINT ishbekmapzones_pkey PRIMARY KEY (id);


--
-- Name: language language_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.language
    ADD CONSTRAINT language_pkey PRIMARY KEY (id);


--
-- Name: linkeradditionalattributes linkeradditionalattributes_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.linkeradditionalattributes
    ADD CONSTRAINT linkeradditionalattributes_pkey PRIMARY KEY (id);


--
-- Name: lookup lookup_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.lookup
    ADD CONSTRAINT lookup_pkey PRIMARY KEY (id);


--
-- Name: manualprintingorder manualprintingorder_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.manualprintingorder
    ADD CONSTRAINT manualprintingorder_pkey PRIMARY KEY (id);


--
-- Name: menucategories menu_categories_uniqe; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.menucategories
    ADD CONSTRAINT menu_categories_uniqe UNIQUE (menuid, categoryid);


--
-- Name: menu menu_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.menu
    ADD CONSTRAINT menu_pkey PRIMARY KEY (id);


--
-- Name: menuchannel menuchannel_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.menuchannel
    ADD CONSTRAINT menuchannel_pkey PRIMARY KEY (menuid, channelid, branchid);


--
-- Name: menuintegratiosync menuintegratiosync_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.menuintegratiosync
    ADD CONSTRAINT menuintegratiosync_pkey PRIMARY KEY (menuid, channelid);


--
-- Name: menuintegrators menuintegrators_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.menuintegrators
    ADD CONSTRAINT menuintegrators_pkey PRIMARY KEY (channelid);


--
-- Name: menuproduct menuproduct_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.menuproduct
    ADD CONSTRAINT menuproduct_pkey PRIMARY KEY (id);


--
-- Name: menuqrcode menuqrcode_channelid_branchid_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.menuqrcode
    ADD CONSTRAINT menuqrcode_channelid_branchid_key UNIQUE (channelid, branchid);


--
-- Name: menuqrcode menuqrcode_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.menuqrcode
    ADD CONSTRAINT menuqrcode_pkey PRIMARY KEY (id);


--
-- Name: menurequestlog menurequestlog_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.menurequestlog
    ADD CONSTRAINT menurequestlog_pkey PRIMARY KEY (id);


--
-- Name: mezaoutgoingdrequestlog mezaoutgoingdrequestlog_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.mezaoutgoingdrequestlog
    ADD CONSTRAINT mezaoutgoingdrequestlog_pkey PRIMARY KEY (id);


--
-- Name: namelookup namelookup_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.namelookup
    ADD CONSTRAINT namelookup_pkey PRIMARY KEY (id);


--
-- Name: notification notification_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.notification
    ADD CONSTRAINT notification_pkey PRIMARY KEY (id);


--
-- Name: notificationfollowup notificationfollowup_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.notificationfollowup
    ADD CONSTRAINT notificationfollowup_pkey PRIMARY KEY (id);


--
-- Name: offerimage offerimage_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.offerimage
    ADD CONSTRAINT offerimage_pkey PRIMARY KEY (id);


--
-- Name: order_2025 order_2025_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.order_2025
    ADD CONSTRAINT order_2025_pkey PRIMARY KEY (id);


--
-- Name: order order_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public."order"
    ADD CONSTRAINT order_pkey PRIMARY KEY (id);


--
-- Name: orderfollowup orderfollowup_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.orderfollowup
    ADD CONSTRAINT orderfollowup_pkey PRIMARY KEY (id, ordercase);


--
-- Name: orderfollowupdetails orderfollowupdetails_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.orderfollowupdetails
    ADD CONSTRAINT orderfollowupdetails_pkey PRIMARY KEY (id);


--
-- Name: orderhistory orderhistory_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.orderhistory
    ADD CONSTRAINT orderhistory_pkey PRIMARY KEY (id, status);


--
-- Name: ordernotificationsettings ordernotificationsettings_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ordernotificationsettings
    ADD CONSTRAINT ordernotificationsettings_pkey PRIMARY KEY (branchid, sound);


--
-- Name: orderprice orderprice_orderid_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.orderprice
    ADD CONSTRAINT orderprice_orderid_key UNIQUE (orderid);


--
-- Name: orderpricedetails orderpricedetails_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.orderpricedetails
    ADD CONSTRAINT orderpricedetails_pkey PRIMARY KEY (id);


--
-- Name: orderpricedetails orderpricedetails_referencenumber_referencenumberexternalnu_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.orderpricedetails
    ADD CONSTRAINT orderpricedetails_referencenumber_referencenumberexternalnu_key UNIQUE (referencenumber, referencenumberexternalnumber);


--
-- Name: orderprint orderprint_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.orderprint
    ADD CONSTRAINT orderprint_pkey PRIMARY KEY (id, jobid, branchid, printer, template, printerid);


--
-- Name: orderproduct_2025 orderproduct_2025_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.orderproduct_2025
    ADD CONSTRAINT orderproduct_2025_pkey PRIMARY KEY (id);


--
-- Name: orderproduct orderproduct_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.orderproduct
    ADD CONSTRAINT orderproduct_pkey PRIMARY KEY (id);


--
-- Name: orderproductattribute_2025 orderproductattribute_2025_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.orderproductattribute_2025
    ADD CONSTRAINT orderproductattribute_2025_pkey PRIMARY KEY (id);


--
-- Name: orderproductattribute orderproductattribute_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.orderproductattribute
    ADD CONSTRAINT orderproductattribute_pkey PRIMARY KEY (id);


--
-- Name: ordersreport ordersreport_orderid_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ordersreport
    ADD CONSTRAINT ordersreport_orderid_key UNIQUE (orderid);


--
-- Name: ordersreport ordersreport_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ordersreport
    ADD CONSTRAINT ordersreport_pkey PRIMARY KEY (serial);


--
-- Name: orderstatuspossibilities orderstatus_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.orderstatuspossibilities
    ADD CONSTRAINT orderstatus_pkey PRIMARY KEY (id);


--
-- Name: ourintegration ourintegration_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ourintegration
    ADD CONSTRAINT ourintegration_pkey PRIMARY KEY (id);


--
-- Name: payment payment_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.payment
    ADD CONSTRAINT payment_pkey PRIMARY KEY (id);


--
-- Name: paymentonholdorders paymentonholdorders_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.paymentonholdorders
    ADD CONSTRAINT paymentonholdorders_pkey PRIMARY KEY (orderpaymentid, sessionid);


--
-- Name: paymentrequestlog paymentrequestlog_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.paymentrequestlog
    ADD CONSTRAINT paymentrequestlog_pkey PRIMARY KEY (id);


--
-- Name: pointlog pointlog_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.pointlog
    ADD CONSTRAINT pointlog_pkey PRIMARY KEY (crid, createdat);


--
-- Name: posintegration posintegration_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.posintegration
    ADD CONSTRAINT posintegration_pkey PRIMARY KEY (companyid);


--
-- Name: printers printers_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.printers
    ADD CONSTRAINT printers_pkey PRIMARY KEY (id);


--
-- Name: printingorderlogs printinglogs_orderid; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.printingorderlogs
    ADD CONSTRAINT printinglogs_orderid UNIQUE (orderid);


--
-- Name: printingorderlogs printingorderlogs_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.printingorderlogs
    ADD CONSTRAINT printingorderlogs_pkey PRIMARY KEY (id);


--
-- Name: product product_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.product
    ADD CONSTRAINT product_pkey PRIMARY KEY (id);


--
-- Name: productattribute productattribute_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.productattribute
    ADD CONSTRAINT productattribute_pkey PRIMARY KEY (id);


--
-- Name: productavailability productavailability_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.productavailability
    ADD CONSTRAINT productavailability_pkey PRIMARY KEY (id);


--
-- Name: productimages productimages_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.productimages
    ADD CONSTRAINT productimages_pkey PRIMARY KEY (id);


--
-- Name: productquestions productquestions_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.productquestions
    ADD CONSTRAINT productquestions_pkey PRIMARY KEY (id);


--
-- Name: productselectedattribute productselectedattribute_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.productselectedattribute
    ADD CONSTRAINT productselectedattribute_pkey PRIMARY KEY (id);


--
-- Name: producttags producttags_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.producttags
    ADD CONSTRAINT producttags_pkey PRIMARY KEY (productid);


--
-- Name: producttt producttt_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.producttt
    ADD CONSTRAINT producttt_pkey PRIMARY KEY (id);


--
-- Name: promocode promocode_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.promocode
    ADD CONSTRAINT promocode_pkey PRIMARY KEY (id);


--
-- Name: promocodebranch promocodebranch_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.promocodebranch
    ADD CONSTRAINT promocodebranch_pkey PRIMARY KEY (branchid, promocodeid);


--
-- Name: promocodecategory promocodecategory_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.promocodecategory
    ADD CONSTRAINT promocodecategory_pkey PRIMARY KEY (categoryid, promocodeid);


--
-- Name: promocodechannel promocodechannal_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.promocodechannel
    ADD CONSTRAINT promocodechannal_pkey PRIMARY KEY (promocodeid, channelid);


--
-- Name: questionattributes questionattributes_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.questionattributes
    ADD CONSTRAINT questionattributes_pkey PRIMARY KEY (id);


--
-- Name: questions questions_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.questions
    ADD CONSTRAINT questions_pkey PRIMARY KEY (id);


--
-- Name: relatedproduct relatedproduct_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.relatedproduct
    ADD CONSTRAINT relatedproduct_pkey PRIMARY KEY (id);


--
-- Name: requestlog requestlog_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.requestlog
    ADD CONSTRAINT requestlog_pkey PRIMARY KEY (id);


--
-- Name: companywaapiservicechat restaurantchatservices_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.companywaapiservicechat
    ADD CONSTRAINT restaurantchatservices_pkey PRIMARY KEY (id);


--
-- Name: restaurantcustomer restaurantcustomer_customerid_restaurantid_key; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.restaurantcustomer
    ADD CONSTRAINT restaurantcustomer_customerid_restaurantid_key UNIQUE (customerid, restaurantid);


--
-- Name: restaurantcustomer restaurantcustomer_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.restaurantcustomer
    ADD CONSTRAINT restaurantcustomer_pkey PRIMARY KEY (id);


--
-- Name: restaurantparams restaurantparams_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.restaurantparams
    ADD CONSTRAINT restaurantparams_pkey PRIMARY KEY (restaurantid);


--
-- Name: restaurantpaymentcredentials restaurantpaymentcredentials_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.restaurantpaymentcredentials
    ADD CONSTRAINT restaurantpaymentcredentials_pkey PRIMARY KEY (rid);


--
-- Name: talabatmenu talabatmenu_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.talabatmenu
    ADD CONSTRAINT talabatmenu_pkey PRIMARY KEY (id);


--
-- Name: talabatprerequestlog talabatprerequestlog_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.talabatprerequestlog
    ADD CONSTRAINT talabatprerequestlog_pkey PRIMARY KEY (id);


--
-- Name: taxcategory taxCategory_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.taxcategory
    ADD CONSTRAINT "taxCategory_pkey" PRIMARY KEY (id);


--
-- Name: transaction transaction_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.transaction
    ADD CONSTRAINT transaction_pkey PRIMARY KEY (id);


--
-- Name: transferbranch transferbranche_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.transferbranch
    ADD CONSTRAINT transferbranche_pkey PRIMARY KEY (id);


--
-- Name: ishbekareas unique_areaid; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ishbekareas
    ADD CONSTRAINT unique_areaid UNIQUE (areaid);


--
-- Name: branchsubareafees unique_branch_subarea_fees; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.branchsubareafees
    ADD CONSTRAINT unique_branch_subarea_fees UNIQUE (areacodeid, branchid, cityid, areaid);


--
-- Name: menuchannel unique_channel_branch; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.menuchannel
    ADD CONSTRAINT unique_channel_branch UNIQUE (channelid, branchid);


--
-- Name: companysubarea unique_company_subarea; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.companysubarea
    ADD CONSTRAINT unique_company_subarea UNIQUE (companyid, cityid, areaid, areacode);


--
-- Name: ashyaeemappedentities unique_ishbek_ashyaee; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ashyaeemappedentities
    ADD CONSTRAINT unique_ishbek_ashyaee UNIQUE (ishbekid, ashyaeeid);


--
-- Name: userauth userauth_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.userauth
    ADD CONSTRAINT userauth_pkey PRIMARY KEY (id);


--
-- Name: userauth username_userauth; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.userauth
    ADD CONSTRAINT username_userauth UNIQUE (username);


--
-- Name: viciphonenumber viciphonenumber_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.viciphonenumber
    ADD CONSTRAINT viciphonenumber_pkey PRIMARY KEY (id);


--
-- Name: viewprinter viewprinter_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.viewprinter
    ADD CONSTRAINT viewprinter_pkey PRIMARY KEY (id);


--
-- Name: waapiclients waapiclients_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.waapiclients
    ADD CONSTRAINT waapiclients_pkey PRIMARY KEY (id);


--
-- Name: waapilogs wappilogs_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.waapilogs
    ADD CONSTRAINT wappilogs_pkey PRIMARY KEY (id);


--
-- Name: whatsapptemplate whatsapptemplate_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.whatsapptemplate
    ADD CONSTRAINT whatsapptemplate_pkey PRIMARY KEY (id);


--
-- Name: address_createdatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX address_createdatx ON public.address USING btree (createdat);


--
-- Name: address_deletedatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX address_deletedatx ON public.address USING btree (deletedat);


--
-- Name: address_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX address_idx ON public.address USING btree (id);


--
-- Name: address_isdeletedx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX address_isdeletedx ON public.address USING btree (isdeleted);


--
-- Name: address_ispublishedx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX address_ispublishedx ON public.address USING btree (ispublished);


--
-- Name: address_updatedatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX address_updatedatx ON public.address USING btree (updatedat);


--
-- Name: ashyaeeorderlog_branch_brand_id_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ashyaeeorderlog_branch_brand_id_idx ON public.ashyaeeorderlog USING btree ((((details -> 'branch'::text) -> 'brand_id'::text)));


--
-- Name: ashyaeeorderlog_branch_id_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ashyaeeorderlog_branch_id_idx ON public.ashyaeeorderlog USING btree ((((details -> 'branch'::text) -> 'id'::text)));


--
-- Name: ashyaeeorderlog_createdat_indx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ashyaeeorderlog_createdat_indx ON public.ashyaeeorderlog USING btree (createdat);


--
-- Name: ashyaeeorderlog_eventid_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ashyaeeorderlog_eventid_idx ON public.ashyaeeorderlog USING btree (eventid);


--
-- Name: ashyaeeorderlog_eventtype_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ashyaeeorderlog_eventtype_idx ON public.ashyaeeorderlog USING btree (eventtype);


--
-- Name: ashyaeeorderlog_id_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ashyaeeorderlog_id_idx ON public.ashyaeeorderlog USING btree (((details -> 'id'::text)));


--
-- Name: branch_addressidx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX branch_addressidx ON public.branch USING btree (addressid);


--
-- Name: branch_companyidx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX branch_companyidx ON public.branch USING btree (companyid);


--
-- Name: branch_createdatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX branch_createdatx ON public.branch USING btree (createdat);


--
-- Name: branch_deletedatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX branch_deletedatx ON public.branch USING btree (deletedat);


--
-- Name: branch_id_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX branch_id_idx ON public.ordersreport USING btree (branchid);


--
-- Name: branch_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX branch_idx ON public.branch USING btree (id);


--
-- Name: branch_isdeletedx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX branch_isdeletedx ON public.branch USING btree (isdeleted);


--
-- Name: branch_ispublishedx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX branch_ispublishedx ON public.branch USING btree (ispublished);


--
-- Name: branch_name_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX branch_name_idx ON public.ordersreport USING btree (branchname);


--
-- Name: branch_statusx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX branch_statusx ON public.branch USING btree (status);


--
-- Name: branch_updatedatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX branch_updatedatx ON public.branch USING btree (updatedat);


--
-- Name: branchaddress_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX branchaddress_idx ON public.branchaddress USING btree (id);


--
-- Name: branchdelivery_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX branchdelivery_idx ON public.branchdelivery USING btree (id);


--
-- Name: branchdeliverycharge_branchid_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX branchdeliverycharge_branchid_idx ON public.branchdeliverycharge USING btree (branchid);


--
-- Name: branchdeliverycharge_companyid_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX branchdeliverycharge_companyid_idx ON public.branchdeliverycharge USING btree (companyid);


--
-- Name: branchid_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX branchid_idx ON public."order" USING btree (branchid);


--
-- Name: branchid_orderprice; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX branchid_orderprice ON public.orderprice USING btree (branchid);


--
-- Name: careemlog_branch_brand_id_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX careemlog_branch_brand_id_idx ON public.careemlog USING btree ((((details -> 'branch'::text) -> 'brand_id'::text)));


--
-- Name: careemlog_branch_id_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX careemlog_branch_id_idx ON public.careemlog USING btree ((((details -> 'branch'::text) -> 'id'::text)));


--
-- Name: careemlog_createdat_indx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX careemlog_createdat_indx ON public.careemlog USING btree (createdat);


--
-- Name: careemlog_eventid_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX careemlog_eventid_idx ON public.careemlog USING btree (eventid);


--
-- Name: careemlog_eventtype_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX careemlog_eventtype_idx ON public.careemlog USING btree (eventtype);


--
-- Name: careemlog_id_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX careemlog_id_idx ON public.careemlog USING btree (((details -> 'id'::text)));


--
-- Name: category_createdatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX category_createdatx ON public.category USING btree (createdat);


--
-- Name: category_deletedatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX category_deletedatx ON public.category USING btree (deletedat);


--
-- Name: category_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX category_idx ON public.category USING btree (id);


--
-- Name: category_isdeletedx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX category_isdeletedx ON public.category USING btree (isdeleted);


--
-- Name: category_ispublishedx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX category_ispublishedx ON public.category USING btree (ispublished);


--
-- Name: category_updatedatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX category_updatedatx ON public.category USING btree (updatedat);


--
-- Name: company_id_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX company_id_idx ON public.ordersreport USING btree (companyid);


--
-- Name: company_name_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX company_name_idx ON public.ordersreport USING btree (companyname);


--
-- Name: companyinfo_companyidx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX companyinfo_companyidx ON public.companyinfo USING btree (companyid);


--
-- Name: companyinfo_createdatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX companyinfo_createdatx ON public.companyinfo USING btree (createdat);


--
-- Name: companyinfo_deletedatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX companyinfo_deletedatx ON public.companyinfo USING btree (deletedat);


--
-- Name: companyinfo_isdeletedx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX companyinfo_isdeletedx ON public.companyinfo USING btree (isdeleted);


--
-- Name: companyinfo_ispublishedx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX companyinfo_ispublishedx ON public.companyinfo USING btree (ispublished);


--
-- Name: companyinfo_updatedatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX companyinfo_updatedatx ON public.companyinfo USING btree (updatedat);


--
-- Name: coupon_createdatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX coupon_createdatx ON public.coupon USING btree (createdat);


--
-- Name: coupon_deletedatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX coupon_deletedatx ON public.coupon USING btree (deletedat);


--
-- Name: coupon_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX coupon_idx ON public.coupon USING btree (id);


--
-- Name: coupon_isdeletedx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX coupon_isdeletedx ON public.coupon USING btree (isdeleted);


--
-- Name: coupon_ispublishedx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX coupon_ispublishedx ON public.coupon USING btree (ispublished);


--
-- Name: coupon_updatedatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX coupon_updatedatx ON public.coupon USING btree (updatedat);


--
-- Name: createdat_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX createdat_idx ON public.orderfollowupdetails USING btree (createdat);


--
-- Name: customeraddress_addressid_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX customeraddress_addressid_idx ON public.customeraddress USING btree (addressid);


--
-- Name: customeraddress_customerid_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX customeraddress_customerid_idx ON public.customeraddress USING btree (customerid);


--
-- Name: customeraddress_labeladdressid_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX customeraddress_labeladdressid_idx ON public.customeraddress USING btree (labeladdressid);


--
-- Name: customerbillingdetails_customerid_index; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX customerbillingdetails_customerid_index ON public.customerbillingdetails USING btree (customerid);


--
-- Name: customerid_orderprice; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX customerid_orderprice ON public.orderprice USING btree (ordersourceid);


--
-- Name: deliverycompany_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX deliverycompany_idx ON public.deliverycompany USING btree (id);


--
-- Name: deliverycompany_isdeletedx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX deliverycompany_isdeletedx ON public.deliverycompany USING btree (isdeleted);


--
-- Name: deliverycompany_ispublishedx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX deliverycompany_ispublishedx ON public.deliverycompany USING btree (ispublished);


--
-- Name: discountbranch_branchid_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX discountbranch_branchid_idx ON public.discountbranch USING btree (branchid);


--
-- Name: discountbranch_discountid_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX discountbranch_discountid_idx ON public.discountbranch USING btree (discountid);


--
-- Name: discountchannel_channelid_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX discountchannel_channelid_idx ON public.discountchannel USING btree (channelid);


--
-- Name: discountchannel_discountid_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX discountchannel_discountid_idx ON public.discountchannel USING btree (discountid);


--
-- Name: discountinfo_companyid_isx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX discountinfo_companyid_isx ON public.discountinfo USING btree (companyid);


--
-- Name: discountproduct_discountid_isx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX discountproduct_discountid_isx ON public.discountproduct USING btree (discountid);


--
-- Name: discountproduct_productid_isx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX discountproduct_productid_isx ON public.discountproduct USING btree (productid);


--
-- Name: fki_branchid_fkey; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX fki_branchid_fkey ON public.generalcomplain USING btree (branchid);


--
-- Name: fki_customerid_fkey; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX fki_customerid_fkey ON public.generalcomplain USING btree (customerid);


--
-- Name: fki_fk_branchaddress_branchid; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX fki_fk_branchaddress_branchid ON public.branchaddress USING btree (branchid);


--
-- Name: fki_fk_branchdelivery_deliverycompanyid; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX fki_fk_branchdelivery_deliverycompanyid ON public.branchdelivery USING btree (deliverycompanyid);


--
-- Name: fki_fk_branchdeliveryaddress_branchdeliverycompany; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX fki_fk_branchdeliveryaddress_branchdeliverycompany ON public.branchdeliveryaddress USING btree (branchdeliverycompany);


--
-- Name: fki_fk_branchdeliveyaddress_branchaddressid; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX fki_fk_branchdeliveyaddress_branchaddressid ON public.branchdeliveryaddress USING btree (branchaddress);


--
-- Name: fki_fk_deliverycompany_branchid; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX fki_fk_deliverycompany_branchid ON public.branchdelivery USING btree (branchid);


--
-- Name: fki_fk_generalcomplain_branchid; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX fki_fk_generalcomplain_branchid ON public.generalcomplain USING btree (branchid);


--
-- Name: fki_fk_menucategories_category; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX fki_fk_menucategories_category ON public.menucategories USING btree (categoryid);


--
-- Name: fki_fk_namelookup_referanceid; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX fki_fk_namelookup_referanceid ON public.namelookup USING btree (referenceid);


--
-- Name: fki_fk_notificationfollowup_notificationid; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX fki_fk_notificationfollowup_notificationid ON public.notificationfollowup USING btree (notificationid);


--
-- Name: fki_fk_online_company; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX fki_fk_online_company ON public.orderconfig USING btree (companyid);


--
-- Name: fki_fk_ordersettings_next; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX fki_fk_ordersettings_next ON public.orderstatuspossibilities USING btree (nextstatus);


--
-- Name: fki_fk_product_category_categoryid; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX fki_fk_product_category_categoryid ON public.product USING btree (categoryid);


--
-- Name: fki_m; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX fki_m ON public.menuproduct USING btree (menuid);


--
-- Name: fki_menucategories_menu; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX fki_menucategories_menu ON public.menucategories USING btree (menuid);


--
-- Name: fki_o; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX fki_o ON public.orderstatuspossibilities USING btree (companyid);


--
-- Name: fki_orderfollowupcustomerid; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX fki_orderfollowupcustomerid ON public.orderfollowup USING btree (customerid);


--
-- Name: fki_orderstatuspossibilitiesid_fkey; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX fki_orderstatuspossibilitiesid_fkey ON public.generalcomplain USING btree (orderstatuspossibilitiesid);


--
-- Name: fki_status_status_fkey; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX fki_status_status_fkey ON public.callsubmission USING btree (status);


--
-- Name: fki_status_substatus_fkey; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX fki_status_substatus_fkey ON public.callsubmission USING btree (parentstatus);


--
-- Name: idx_areacode; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_areacode ON public.companysubarea USING btree (areacode);


--
-- Name: idx_areaid; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_areaid ON public.companysubarea USING btree (areaid);


--
-- Name: idx_brandid; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_brandid ON public.menurequestlog USING btree (brandid);


--
-- Name: idx_cityid; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_cityid ON public.ishbekareas USING btree (cityid);


--
-- Name: idx_companyid; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_companyid ON public.menurequestlog USING btree (companyid);


--
-- Name: idx_companyphone; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_companyphone ON public.viciphonenumber USING btree (companyphone);


--
-- Name: idx_ishbek_city_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_ishbek_city_id ON public.ishbekcities USING btree (cityid);


--
-- Name: idx_methodlogtype; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_methodlogtype ON public.requestlog USING btree (method);


--
-- Name: idx_object; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_object ON public.branchavailability USING btree (objectid);


--
-- Name: idx_objectid_branchid; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_objectid_branchid ON public.branchavailability USING btree (objectid, branchid);


--
-- Name: idx_objectid_channelid; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_objectid_channelid ON public.branchavailability USING btree (objectid, channelid);


--
-- Name: idx_phonenumber2; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_phonenumber2 ON public.customer USING btree (phoneno2);


--
-- Name: idx_remoteid; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_remoteid ON public.requestlog USING btree (remoteid);


--
-- Name: idx_talabatbrandid; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_talabatbrandid ON public.requestlog USING btree (talabatbrandid);


--
-- Name: language_createdatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX language_createdatx ON public.language USING btree (createdat);


--
-- Name: language_deletedatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX language_deletedatx ON public.language USING btree (deletedat);


--
-- Name: language_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX language_idx ON public.language USING btree (id);


--
-- Name: language_isdeletedx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX language_isdeletedx ON public.language USING btree (isdeleted);


--
-- Name: language_ispublishedx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX language_ispublishedx ON public.language USING btree (ispublished);


--
-- Name: language_languagecodex; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX language_languagecodex ON public.language USING btree (languagecode);


--
-- Name: language_updatedatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX language_updatedatx ON public.language USING btree (updatedat);


--
-- Name: menu_createdatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX menu_createdatx ON public.menu USING btree (createdat);


--
-- Name: menu_deletedatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX menu_deletedatx ON public.menu USING btree (deletedat);


--
-- Name: menu_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX menu_idx ON public.menu USING btree (id);


--
-- Name: menu_isdeletedx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX menu_isdeletedx ON public.menu USING btree (isdeleted);


--
-- Name: menu_ispublishedx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX menu_ispublishedx ON public.menu USING btree (ispublished);


--
-- Name: menu_updatedatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX menu_updatedatx ON public.menu USING btree (updatedat);


--
-- Name: menuchannel_branchid_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX menuchannel_branchid_idx ON public.menuchannel USING btree (branchid);


--
-- Name: menuchannel_channelid_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX menuchannel_channelid_idx ON public.menuchannel USING btree (channelid);


--
-- Name: menuchannel_menuid_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX menuchannel_menuid_idx ON public.menuchannel USING btree (menuid);


--
-- Name: menuproduct_createdatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX menuproduct_createdatx ON public.menuproduct USING btree (createdat);


--
-- Name: menuproduct_deletedatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX menuproduct_deletedatx ON public.menuproduct USING btree (deletedat);


--
-- Name: menuproduct_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX menuproduct_idx ON public.menuproduct USING btree (id);


--
-- Name: menuproduct_isdeletedx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX menuproduct_isdeletedx ON public.menuproduct USING btree (isdeleted);


--
-- Name: menuproduct_ispublishedx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX menuproduct_ispublishedx ON public.menuproduct USING btree (ispublished);


--
-- Name: menuproduct_menuidx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX menuproduct_menuidx ON public.menuproduct USING btree (menuid);


--
-- Name: menuproduct_productid_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX menuproduct_productid_idx ON public.menuproduct USING btree (productid);


--
-- Name: menuproduct_updatedatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX menuproduct_updatedatx ON public.menuproduct USING btree (updatedat);


--
-- Name: menuqrcode_branchid_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX menuqrcode_branchid_idx ON public.menuqrcode USING btree (branchid);


--
-- Name: namelookup_createdatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX namelookup_createdatx ON public.namelookup USING btree (createdat);


--
-- Name: namelookup_deletedatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX namelookup_deletedatx ON public.namelookup USING btree (deletedat);


--
-- Name: namelookup_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX namelookup_idx ON public.namelookup USING btree (id);


--
-- Name: namelookup_isdeletedx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX namelookup_isdeletedx ON public.namelookup USING btree (isdeleted);


--
-- Name: namelookup_ispublishedx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX namelookup_ispublishedx ON public.namelookup USING btree (ispublished);


--
-- Name: namelookup_tabletypex; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX namelookup_tabletypex ON public.namelookup USING btree (tabletype);


--
-- Name: namelookup_updatedatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX namelookup_updatedatx ON public.namelookup USING btree (updatedat);


--
-- Name: object_channelid; Type: INDEX; Schema: public; Owner: -
--

CREATE UNIQUE INDEX object_channelid ON public.branchavailability USING btree (objectid, channelid, branchid);


--
-- Name: order_customerid_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX order_customerid_idx ON public."order" USING btree (customerid);


--
-- Name: order_ordersource; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX order_ordersource ON public."order" USING btree (ordersource);


--
-- Name: order_ordersource_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX order_ordersource_idx ON public."order" USING btree (ordersource);


--
-- Name: order_referencenumber2_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX order_referencenumber2_idx ON public."order" USING btree (referencenumber2);


--
-- Name: order_referencenumber_careem_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX order_referencenumber_careem_idx ON public."order" USING btree (((referencenumber ->> 'careem'::text)));


--
-- Name: order_referencenumber_talabat; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX order_referencenumber_talabat ON public."order" USING btree (((referencenumber ->> 'deliveryPlatformID'::text)));


--
-- Name: orderfollowupdetailsid_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX orderfollowupdetailsid_idx ON public.orderfollowupdetails USING btree (id);


--
-- Name: orderid_orderprice; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX orderid_orderprice ON public.orderprice USING btree (orderid);


--
-- Name: orderproduct_orderid_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX orderproduct_orderid_idx ON public.orderproduct USING btree (orderid);


--
-- Name: orderproduct_productid_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX orderproduct_productid_idx ON public.orderproduct USING btree (productid);


--
-- Name: orderproductattribute_attributeid_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX orderproductattribute_attributeid_idx ON public.orderproductattribute USING btree (attributeid);


--
-- Name: orderproductattribute_orderproductid_isx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX orderproductattribute_orderproductid_isx ON public.orderproductattribute USING btree (orderproductid);


--
-- Name: ordersourceid_orderprice; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ordersourceid_orderprice ON public.orderprice USING btree (ordersourceid);


--
-- Name: ordersreport_customerid_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ordersreport_customerid_idx ON public.ordersreport USING btree (customerid);


--
-- Name: ordersreport_deliveryid; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ordersreport_deliveryid ON public.ordersreport USING btree (deliveryid);


--
-- Name: ordersreport_deliveryname; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ordersreport_deliveryname ON public.ordersreport USING btree (deliveryname);


--
-- Name: ordersreport_iscanceled_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ordersreport_iscanceled_idx ON public.ordersreport USING btree (iscanceled);


--
-- Name: ordersreport_orderstatusid; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX ordersreport_orderstatusid ON public.ordersreport USING btree (orderstatusid);


--
-- Name: pointlog_channelid_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX pointlog_channelid_idx ON public.pointlog USING btree (channelid);


--
-- Name: pointlog_customerid_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX pointlog_customerid_idx ON public.pointlog USING btree (customerid);


--
-- Name: pointlog_restaurantid_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX pointlog_restaurantid_idx ON public.pointlog USING btree (restaurantid);


--
-- Name: product_createdatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX product_createdatx ON public.product USING btree (createdat);


--
-- Name: product_deletedatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX product_deletedatx ON public.product USING btree (deletedat);


--
-- Name: product_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX product_idx ON public.product USING btree (id);


--
-- Name: product_isdeletedx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX product_isdeletedx ON public.product USING btree (isdeleted);


--
-- Name: product_ispublishedx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX product_ispublishedx ON public.product USING btree (ispublished);


--
-- Name: product_updatedatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX product_updatedatx ON public.product USING btree (updatedat);


--
-- Name: productattribute_attributeid_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX productattribute_attributeid_idx ON public.productattribute USING btree (attributeid);


--
-- Name: productattribute_companyid_isx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX productattribute_companyid_isx ON public.productattribute USING btree (companyid);


--
-- Name: productattribute_isdeleted_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX productattribute_isdeleted_idx ON public.productattribute USING btree (isdeleted);


--
-- Name: productattribute_ispublished_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX productattribute_ispublished_idx ON public.productattribute USING btree (ispublished);


--
-- Name: productattribute_productid_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX productattribute_productid_idx ON public.productattribute USING btree (productid);


--
-- Name: productavailability_createdatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX productavailability_createdatx ON public.productavailability USING btree (createdat);


--
-- Name: productavailability_deletedatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX productavailability_deletedatx ON public.productavailability USING btree (deletedat);


--
-- Name: productavailability_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX productavailability_idx ON public.productavailability USING btree (id);


--
-- Name: productavailability_isdeletedx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX productavailability_isdeletedx ON public.productavailability USING btree (isdeleted);


--
-- Name: productavailability_ispublishedx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX productavailability_ispublishedx ON public.productavailability USING btree (ispublished);


--
-- Name: productavailability_updatedatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX productavailability_updatedatx ON public.productavailability USING btree (updatedat);


--
-- Name: productimages_createdatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX productimages_createdatx ON public.productimages USING btree (createdat);


--
-- Name: productimages_deletedatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX productimages_deletedatx ON public.productimages USING btree (deletedat);


--
-- Name: productimages_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX productimages_idx ON public.productimages USING btree (id);


--
-- Name: productimages_isdeletedx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX productimages_isdeletedx ON public.productimages USING btree (isdeleted);


--
-- Name: productimages_ispublishedx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX productimages_ispublishedx ON public.productimages USING btree (ispublished);


--
-- Name: productimages_updatedatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX productimages_updatedatx ON public.productimages USING btree (updatedat);


--
-- Name: productselectedattribute_createdatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX productselectedattribute_createdatx ON public.productselectedattribute USING btree (createdat);


--
-- Name: productselectedattribute_deletedatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX productselectedattribute_deletedatx ON public.productselectedattribute USING btree (deletedat);


--
-- Name: productselectedattribute_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX productselectedattribute_idx ON public.productselectedattribute USING btree (id);


--
-- Name: productselectedattribute_isdeletedx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX productselectedattribute_isdeletedx ON public.productselectedattribute USING btree (isdeleted);


--
-- Name: productselectedattribute_ispublishedx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX productselectedattribute_ispublishedx ON public.productselectedattribute USING btree (ispublished);


--
-- Name: productselectedattribute_updatedatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX productselectedattribute_updatedatx ON public.productselectedattribute USING btree (updatedat);


--
-- Name: relatedproduct_createdatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX relatedproduct_createdatx ON public.relatedproduct USING btree (createdat);


--
-- Name: relatedproduct_deletedatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX relatedproduct_deletedatx ON public.relatedproduct USING btree (deletedat);


--
-- Name: relatedproduct_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX relatedproduct_idx ON public.relatedproduct USING btree (id);


--
-- Name: relatedproduct_isdeletedx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX relatedproduct_isdeletedx ON public.relatedproduct USING btree (isdeleted);


--
-- Name: relatedproduct_ispublishedx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX relatedproduct_ispublishedx ON public.relatedproduct USING btree (ispublished);


--
-- Name: relatedproduct_updatedatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX relatedproduct_updatedatx ON public.relatedproduct USING btree (updatedat);


--
-- Name: requestlog_method_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX requestlog_method_idx ON public.requestlog USING btree (method);


--
-- Name: requestlog_requestbody_code_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX requestlog_requestbody_code_idx ON public.requestlog USING btree (((((requestbody)::json -> 'order'::text) ->> 'Code'::text)));


--
-- Name: restaurantcustomer_customerid_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX restaurantcustomer_customerid_idx ON public.restaurantcustomer USING btree (customerid);


--
-- Name: restaurantcustomer_restaurantid_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX restaurantcustomer_restaurantid_idx ON public.restaurantcustomer USING btree (restaurantid);


--
-- Name: status_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX status_idx ON public.orderstatuspossibilities USING btree (status);


--
-- Name: statuslog_customerid_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX statuslog_customerid_idx ON public.statuslog USING btree (customerid);


--
-- Name: statuslog_restaurantid_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX statuslog_restaurantid_idx ON public.statuslog USING btree (restaurantid);


--
-- Name: tax_cityidx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX tax_cityidx ON public.tax USING btree (cityid);


--
-- Name: tax_countryidx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX tax_countryidx ON public.tax USING btree (countryid);


--
-- Name: tax_createdatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX tax_createdatx ON public.tax USING btree (createdat);


--
-- Name: tax_deletedatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX tax_deletedatx ON public.tax USING btree (deletedat);


--
-- Name: tax_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX tax_idx ON public.tax USING btree (id);


--
-- Name: tax_isdeletedx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX tax_isdeletedx ON public.tax USING btree (isdeleted);


--
-- Name: tax_ispublishedx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX tax_ispublishedx ON public.tax USING btree (ispublished);


--
-- Name: tax_taxcategoryidx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX tax_taxcategoryidx ON public.tax USING btree (taxcategoryid);


--
-- Name: tax_updatedatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX tax_updatedatx ON public.tax USING btree (updatedat);


--
-- Name: taxcategory_companyidx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX taxcategory_companyidx ON public.taxcategory USING btree (companyid);


--
-- Name: taxcategory_createdatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX taxcategory_createdatx ON public.taxcategory USING btree (createdat);


--
-- Name: taxcategory_deletedatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX taxcategory_deletedatx ON public.taxcategory USING btree (deletedat);


--
-- Name: taxcategory_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX taxcategory_idx ON public.taxcategory USING btree (id);


--
-- Name: taxcategory_isdeletedx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX taxcategory_isdeletedx ON public.taxcategory USING btree (isdeleted);


--
-- Name: taxcategory_ispublishedx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX taxcategory_ispublishedx ON public.taxcategory USING btree (ispublished);


--
-- Name: taxcategory_updatedatx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX taxcategory_updatedatx ON public.taxcategory USING btree (updatedat);


--
-- Name: branch branch_companyid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.branch
    ADD CONSTRAINT branch_companyid_fkey FOREIGN KEY (companyid) REFERENCES public.company(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: branchavailability branchid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.branchavailability
    ADD CONSTRAINT branchid_fkey FOREIGN KEY (branchid) REFERENCES public.branch(id);


--
-- Name: menuintegratiosync channelid_fk_namelookup; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.menuintegratiosync
    ADD CONSTRAINT channelid_fk_namelookup FOREIGN KEY (channelid) REFERENCES public.namelookup(id);


--
-- Name: pointlog channelidpointlog_idchannellookup; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.pointlog
    ADD CONSTRAINT channelidpointlog_idchannellookup FOREIGN KEY (channelid) REFERENCES public.channellookup(id);


--
-- Name: chatconversation chatconversation_companyid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.chatconversation
    ADD CONSTRAINT chatconversation_companyid_fkey FOREIGN KEY (companyid) REFERENCES public.company(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: clientintegration clientintegration_intcompanyid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.clientintegration
    ADD CONSTRAINT clientintegration_intcompanyid_fkey FOREIGN KEY (intcompanyid) REFERENCES public.company(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: companyfaq companyfaq_companyid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.companyfaq
    ADD CONSTRAINT companyfaq_companyid_fkey FOREIGN KEY (companyid) REFERENCES public.company(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: companyinfo companyinfo_companyid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.companyinfo
    ADD CONSTRAINT companyinfo_companyid_fkey FOREIGN KEY (companyid) REFERENCES public.company(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: companyservicechat companyservicechat_companyid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.companyservicechat
    ADD CONSTRAINT companyservicechat_companyid_fkey FOREIGN KEY (companyid) REFERENCES public.company(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: companyuser companyuser_companyid; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.companyuser
    ADD CONSTRAINT companyuser_companyid FOREIGN KEY (companyid) REFERENCES public.company(id);


--
-- Name: pointlog cridpointlog_idrecus; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.pointlog
    ADD CONSTRAINT cridpointlog_idrecus FOREIGN KEY (crid) REFERENCES public.restaurantcustomer(id);


--
-- Name: statuslog cridstatuslog_idrescus; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.statuslog
    ADD CONSTRAINT cridstatuslog_idrescus FOREIGN KEY (crid) REFERENCES public.restaurantcustomer(id);


--
-- Name: discountchannel discounchannal_discountid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.discountchannel
    ADD CONSTRAINT discounchannal_discountid_fkey FOREIGN KEY (discountid) REFERENCES public.discountinfo(id);


--
-- Name: discountattribute discountattribute_attributeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.discountattribute
    ADD CONSTRAINT discountattribute_attributeid_fkey FOREIGN KEY (attributeid) REFERENCES public.productattribute(id);


--
-- Name: discountattribute discountattribute_discountid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.discountattribute
    ADD CONSTRAINT discountattribute_discountid_fkey FOREIGN KEY (discountid) REFERENCES public.discountinfo(id);


--
-- Name: discountbranch discountbranch_branchid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.discountbranch
    ADD CONSTRAINT discountbranch_branchid_fkey FOREIGN KEY (branchid) REFERENCES public.branch(id);


--
-- Name: discountbranch discountbranch_discountid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.discountbranch
    ADD CONSTRAINT discountbranch_discountid_fkey FOREIGN KEY (discountid) REFERENCES public.discountinfo(id);


--
-- Name: discountcustomers discountinfoid; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.discountcustomers
    ADD CONSTRAINT discountinfoid FOREIGN KEY (discountid) REFERENCES public.discountinfo(id);


--
-- Name: discountproduct discountproduct_discountid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.discountproduct
    ADD CONSTRAINT discountproduct_discountid_fkey FOREIGN KEY (discountid) REFERENCES public.discountinfo(id);


--
-- Name: discountproduct discountproduct_productid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.discountproduct
    ADD CONSTRAINT discountproduct_productid_fkey FOREIGN KEY (productid) REFERENCES public.product(id);


--
-- Name: addresses fk_addresses_cityid_ishbekcities_cityid; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.addresses
    ADD CONSTRAINT fk_addresses_cityid_ishbekcities_cityid FOREIGN KEY (ishbekcityid) REFERENCES public.ishbekcities(cityid);


--
-- Name: tempaddress fk_addresses_cityid_ishbekcities_cityid; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.tempaddress
    ADD CONSTRAINT fk_addresses_cityid_ishbekcities_cityid FOREIGN KEY (ishbekcityid) REFERENCES public.ishbekcities(cityid);


--
-- Name: addresses fk_addresses_ishbekareaid_ishbekareas_areaid; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.addresses
    ADD CONSTRAINT fk_addresses_ishbekareaid_ishbekareas_areaid FOREIGN KEY (ishbekareaid) REFERENCES public.ishbekareas(areaid);


--
-- Name: tempaddress fk_addresses_ishbekareaid_ishbekareas_areaid; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.tempaddress
    ADD CONSTRAINT fk_addresses_ishbekareaid_ishbekareas_areaid FOREIGN KEY (ishbekareaid) REFERENCES public.ishbekareas(areaid);


--
-- Name: branchaddress fk_branchaddress_branchid; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.branchaddress
    ADD CONSTRAINT fk_branchaddress_branchid FOREIGN KEY (branchid) REFERENCES public.branch(id) NOT VALID;


--
-- Name: branchdelivery fk_branchdelivery_deliverycompanyid; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.branchdelivery
    ADD CONSTRAINT fk_branchdelivery_deliverycompanyid FOREIGN KEY (deliverycompanyid) REFERENCES public.deliverycompany(id);


--
-- Name: branchdeliveryaddress fk_branchdeliveryaddress_branchdeliverycompany; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.branchdeliveryaddress
    ADD CONSTRAINT fk_branchdeliveryaddress_branchdeliverycompany FOREIGN KEY (branchdeliverycompany) REFERENCES public.branchdelivery(id) ON UPDATE CASCADE ON DELETE CASCADE NOT VALID;


--
-- Name: branchdeliveryaddress fk_branchdeliveyaddress_branchaddressid; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.branchdeliveryaddress
    ADD CONSTRAINT fk_branchdeliveyaddress_branchaddressid FOREIGN KEY (branchaddress) REFERENCES public.branchaddress(id) ON UPDATE CASCADE ON DELETE CASCADE NOT VALID;


--
-- Name: branchorderseq fk_branchid_seq; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.branchorderseq
    ADD CONSTRAINT fk_branchid_seq FOREIGN KEY (branchid) REFERENCES public.branch(id);


--
-- Name: branchorderconfig fk_branchorderconfig_company; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.branchorderconfig
    ADD CONSTRAINT fk_branchorderconfig_company FOREIGN KEY (companyid) REFERENCES public.company(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: delayedorders fk_delayedorder_order; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.delayedorders
    ADD CONSTRAINT fk_delayedorder_order FOREIGN KEY (orderid) REFERENCES public."order"(id);


--
-- Name: branchdelivery fk_deliverycompany_branchid; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.branchdelivery
    ADD CONSTRAINT fk_deliverycompany_branchid FOREIGN KEY (branchid) REFERENCES public.branch(id);


--
-- Name: generalcomplain fk_generalcomplain_branchid; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.generalcomplain
    ADD CONSTRAINT fk_generalcomplain_branchid FOREIGN KEY (branchid) REFERENCES public.branch(id) ON DELETE CASCADE NOT VALID;


--
-- Name: posintegration fk_integrationcompanyid; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.posintegration
    ADD CONSTRAINT fk_integrationcompanyid FOREIGN KEY (integrationcompanyid) REFERENCES public.integrationcompany(id);


--
-- Name: ishbekareas fk_ishbekareas_cityid_ishbekcities_cityid; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ishbekareas
    ADD CONSTRAINT fk_ishbekareas_cityid_ishbekcities_cityid FOREIGN KEY (cityid) REFERENCES public.ishbekcities(cityid);


--
-- Name: branch fk_menu; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.branch
    ADD CONSTRAINT fk_menu FOREIGN KEY (menuid) REFERENCES public.menu(id) ON UPDATE CASCADE ON DELETE SET NULL;


--
-- Name: menucategories fk_menucategories_category; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.menucategories
    ADD CONSTRAINT fk_menucategories_category FOREIGN KEY (categoryid) REFERENCES public.category(id) NOT VALID;


--
-- Name: menuproduct fk_menuproduct_menuid; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.menuproduct
    ADD CONSTRAINT fk_menuproduct_menuid FOREIGN KEY (menuid) REFERENCES public.menu(id) ON DELETE CASCADE;


--
-- Name: menuproduct fk_menuproduct_productid; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.menuproduct
    ADD CONSTRAINT fk_menuproduct_productid FOREIGN KEY (productid) REFERENCES public.product(id);


--
-- Name: namelookup fk_namelookup_referanceid; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.namelookup
    ADD CONSTRAINT fk_namelookup_referanceid FOREIGN KEY (referenceid) REFERENCES public.namelookup(id);


--
-- Name: notificationfollowup fk_notificationfollowup_notificationid; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.notificationfollowup
    ADD CONSTRAINT fk_notificationfollowup_notificationid FOREIGN KEY (notificationid) REFERENCES public.notification(id);


--
-- Name: orderconfig fk_online_company; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.orderconfig
    ADD CONSTRAINT fk_online_company FOREIGN KEY (companyid) REFERENCES public.company(id) NOT VALID;


--
-- Name: order fk_order_branchid; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public."order"
    ADD CONSTRAINT fk_order_branchid FOREIGN KEY (branchid) REFERENCES public.branch(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: orderfollowup fk_orderfollowup_orderid; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.orderfollowup
    ADD CONSTRAINT fk_orderfollowup_orderid FOREIGN KEY (id) REFERENCES public."order"(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: orderfollowupdetails fk_orderfollowupdetails_orderid; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.orderfollowupdetails
    ADD CONSTRAINT fk_orderfollowupdetails_orderid FOREIGN KEY (orderid) REFERENCES public."order"(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: orderproduct fk_orderproduct_orderid; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.orderproduct
    ADD CONSTRAINT fk_orderproduct_orderid FOREIGN KEY (orderid) REFERENCES public."order"(id);


--
-- Name: orderproductattribute fk_orderproductatribute_attributeid; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.orderproductattribute
    ADD CONSTRAINT fk_orderproductatribute_attributeid FOREIGN KEY (attributeid) REFERENCES public.productattribute(id);


--
-- Name: orderproductattribute fk_orderproductatribute_orderproductid; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.orderproductattribute
    ADD CONSTRAINT fk_orderproductatribute_orderproductid FOREIGN KEY (orderproductid) REFERENCES public.orderproduct(id);


--
-- Name: orderstatuspossibilities fk_ordersettings_next; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.orderstatuspossibilities
    ADD CONSTRAINT fk_ordersettings_next FOREIGN KEY (nextstatus) REFERENCES public.orderstatuspossibilities(id) ON DELETE CASCADE;


--
-- Name: orderstatuspossibilities fk_possibilities_companyid; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.orderstatuspossibilities
    ADD CONSTRAINT fk_possibilities_companyid FOREIGN KEY (companyid) REFERENCES public.company(id);


--
-- Name: product fk_product_category_categoryid; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.product
    ADD CONSTRAINT fk_product_category_categoryid FOREIGN KEY (categoryid) REFERENCES public.category(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: taxcategory fk_taxcategorycompanyid_companyid; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.taxcategory
    ADD CONSTRAINT fk_taxcategorycompanyid_companyid FOREIGN KEY (companyid) REFERENCES public.company(id) ON UPDATE CASCADE ON DELETE CASCADE NOT VALID;


--
-- Name: tax fk_taxcategoryid_taxcategoryid; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.tax
    ADD CONSTRAINT fk_taxcategoryid_taxcategoryid FOREIGN KEY (taxcategoryid) REFERENCES public.taxcategory(id) ON UPDATE CASCADE ON DELETE CASCADE NOT VALID;


--
-- Name: customeraddress fkcustomeraddress_customer; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.customeraddress
    ADD CONSTRAINT fkcustomeraddress_customer FOREIGN KEY (customerid) REFERENCES public.customer(id);


--
-- Name: offerimage fki_fk_offerimage_company; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.offerimage
    ADD CONSTRAINT fki_fk_offerimage_company FOREIGN KEY (companyid) REFERENCES public.company(id);


--
-- Name: linkeradditionalattributes linkeradditionalattributes_connecterid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.linkeradditionalattributes
    ADD CONSTRAINT linkeradditionalattributes_connecterid_fkey FOREIGN KEY (connecterid) REFERENCES public.attribute(id);


--
-- Name: linkeradditionalattributes linkeradditionalattributes_questionattributeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.linkeradditionalattributes
    ADD CONSTRAINT linkeradditionalattributes_questionattributeid_fkey FOREIGN KEY (questionattributeid) REFERENCES public.questionattributes(id);


--
-- Name: menucategories menucategories_menu; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.menucategories
    ADD CONSTRAINT menucategories_menu FOREIGN KEY (menuid) REFERENCES public.menu(id) NOT VALID;


--
-- Name: menuintegratiosync menuid_fk_menu; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.menuintegratiosync
    ADD CONSTRAINT menuid_fk_menu FOREIGN KEY (menuid) REFERENCES public.menu(id);


--
-- Name: ordernotificationsettings ordernotificationsettings_branchid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.ordernotificationsettings
    ADD CONSTRAINT ordernotificationsettings_branchid_fkey FOREIGN KEY (branchid) REFERENCES public.branch(id);


--
-- Name: orderproduct_2025 orderproduct_2025_productid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.orderproduct_2025
    ADD CONSTRAINT orderproduct_2025_productid_fkey FOREIGN KEY (productid) REFERENCES public.product(id);


--
-- Name: orderproduct orderproduct_productid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.orderproduct
    ADD CONSTRAINT orderproduct_productid_fkey FOREIGN KEY (productid) REFERENCES public.product(id);


--
-- Name: orderstatuspossibilities orderstatus_branchid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.orderstatuspossibilities
    ADD CONSTRAINT orderstatus_branchid_fkey FOREIGN KEY (branchid) REFERENCES public.branch(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: generalcomplain orderstatuspossibilitiesid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.generalcomplain
    ADD CONSTRAINT orderstatuspossibilitiesid_fkey FOREIGN KEY (orderstatuspossibilitiesid) REFERENCES public.orderstatuspossibilities(id);


--
-- Name: posintegration posintegration_companyid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.posintegration
    ADD CONSTRAINT posintegration_companyid_fkey FOREIGN KEY (companyid) REFERENCES public.company(id);


--
-- Name: branchtemplate printers_fk_branchid; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.branchtemplate
    ADD CONSTRAINT printers_fk_branchid FOREIGN KEY (branchid) REFERENCES public.branch(id);


--
-- Name: promocodecustomers procutom_promocode_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.promocodecustomers
    ADD CONSTRAINT procutom_promocode_fkey FOREIGN KEY (promocodeid) REFERENCES public.promocode(id);


--
-- Name: productattribute productattribute_productid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.productattribute
    ADD CONSTRAINT productattribute_productid_fkey FOREIGN KEY (productid) REFERENCES public.product(id);


--
-- Name: productquestions productquestions_productid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.productquestions
    ADD CONSTRAINT productquestions_productid_fkey FOREIGN KEY (productid) REFERENCES public.producttt(id);


--
-- Name: productquestions productquestions_questionid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.productquestions
    ADD CONSTRAINT productquestions_questionid_fkey FOREIGN KEY (questionid) REFERENCES public.questions(id);


--
-- Name: productselectedattribute productselectedattribute_product_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.productselectedattribute
    ADD CONSTRAINT productselectedattribute_product_fkey FOREIGN KEY (product) REFERENCES public.product(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: promocode promocode_companyid_fk; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.promocode
    ADD CONSTRAINT promocode_companyid_fk FOREIGN KEY (companyid) REFERENCES public.company(id);


--
-- Name: promocodebranch promocodebranch_branchid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.promocodebranch
    ADD CONSTRAINT promocodebranch_branchid_fkey FOREIGN KEY (branchid) REFERENCES public.branch(id);


--
-- Name: promocodebranch promocodebranch_promocodeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.promocodebranch
    ADD CONSTRAINT promocodebranch_promocodeid_fkey FOREIGN KEY (promocodeid) REFERENCES public.promocode(id);


--
-- Name: promocodecategory promocodecategory_categoryid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.promocodecategory
    ADD CONSTRAINT promocodecategory_categoryid_fkey FOREIGN KEY (categoryid) REFERENCES public.category(id);


--
-- Name: promocodecategory promocodecategory_promocodeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.promocodecategory
    ADD CONSTRAINT promocodecategory_promocodeid_fkey FOREIGN KEY (promocodeid) REFERENCES public.promocode(id);


--
-- Name: promocodechannel promocodechannal_promocodeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.promocodechannel
    ADD CONSTRAINT promocodechannal_promocodeid_fkey FOREIGN KEY (promocodeid) REFERENCES public.promocode(id);


--
-- Name: questionattributes questionattributes_attributeid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.questionattributes
    ADD CONSTRAINT questionattributes_attributeid_fkey FOREIGN KEY (attributeid) REFERENCES public.attribute(id);


--
-- Name: questionattributes questionattributes_productquestionid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.questionattributes
    ADD CONSTRAINT questionattributes_productquestionid_fkey FOREIGN KEY (productquestionid) REFERENCES public.productquestions(id);


--
-- Name: relatedproduct relatedproduct_productid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.relatedproduct
    ADD CONSTRAINT relatedproduct_productid_fkey FOREIGN KEY (productid) REFERENCES public.product(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: relatedproduct relatedproduct_relatedproductid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.relatedproduct
    ADD CONSTRAINT relatedproduct_relatedproductid_fkey FOREIGN KEY (relatedproductid) REFERENCES public.product(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: pointlog restidpointlog_restidrestparams; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.pointlog
    ADD CONSTRAINT restidpointlog_restidrestparams FOREIGN KEY (restaurantid) REFERENCES public.restaurantparams(restaurantid);


--
-- Name: statuslog restidstatuslog_restidrestparams; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.statuslog
    ADD CONSTRAINT restidstatuslog_restidrestparams FOREIGN KEY (restaurantid) REFERENCES public.restaurantparams(restaurantid);


--
-- Name: rlookup sidrlookup_idlookup; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.rlookup
    ADD CONSTRAINT sidrlookup_idlookup FOREIGN KEY (sid) REFERENCES public.lookup(id);


--
-- Name: callsubmission status_substatus_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.callsubmission
    ADD CONSTRAINT status_substatus_fkey FOREIGN KEY (parentstatus) REFERENCES public.callsubmission(status);


--
-- Name: userauth userauth_companyid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.userauth
    ADD CONSTRAINT userauth_companyid_fkey FOREIGN KEY (companyid) REFERENCES public.company(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- Name: whatsapptemplate whatsapptemplate_companyid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY public.whatsapptemplate
    ADD CONSTRAINT whatsapptemplate_companyid_fkey FOREIGN KEY (companyid) REFERENCES public.company(id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- PostgreSQL database dump complete
--

\unrestrict 0a1ZAxETmGuIa7r6N7gOITP2Ti2BvDDMcNhsSaQAGZupOMJWqwkoPj14DpmYJKQ

